// This file is generated by rust-protobuf 2.0.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct GenSeedRequest {
    // message fields
    pub aezeed_passphrase: ::std::vec::Vec<u8>,
    pub seed_entropy: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GenSeedRequest {
    pub fn new() -> GenSeedRequest {
        ::std::default::Default::default()
    }

    // bytes aezeed_passphrase = 1;

    pub fn clear_aezeed_passphrase(&mut self) {
        self.aezeed_passphrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_aezeed_passphrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.aezeed_passphrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aezeed_passphrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.aezeed_passphrase
    }

    // Take field
    pub fn take_aezeed_passphrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.aezeed_passphrase, ::std::vec::Vec::new())
    }

    pub fn get_aezeed_passphrase(&self) -> &[u8] {
        &self.aezeed_passphrase
    }

    // bytes seed_entropy = 2;

    pub fn clear_seed_entropy(&mut self) {
        self.seed_entropy.clear();
    }

    // Param is passed by value, moved
    pub fn set_seed_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.seed_entropy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.seed_entropy
    }

    // Take field
    pub fn take_seed_entropy(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.seed_entropy, ::std::vec::Vec::new())
    }

    pub fn get_seed_entropy(&self) -> &[u8] {
        &self.seed_entropy
    }
}

impl ::protobuf::Message for GenSeedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.aezeed_passphrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.seed_entropy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.aezeed_passphrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.aezeed_passphrase);
        }
        if !self.seed_entropy.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.seed_entropy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.aezeed_passphrase.is_empty() {
            os.write_bytes(1, &self.aezeed_passphrase)?;
        }
        if !self.seed_entropy.is_empty() {
            os.write_bytes(2, &self.seed_entropy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenSeedRequest {
        GenSeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "aezeed_passphrase",
                    |m: &GenSeedRequest| { &m.aezeed_passphrase },
                    |m: &mut GenSeedRequest| { &mut m.aezeed_passphrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "seed_entropy",
                    |m: &GenSeedRequest| { &m.seed_entropy },
                    |m: &mut GenSeedRequest| { &mut m.seed_entropy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenSeedRequest>(
                    "GenSeedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenSeedRequest {
        static mut instance: ::protobuf::lazy::Lazy<GenSeedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenSeedRequest,
        };
        unsafe {
            instance.get(GenSeedRequest::new)
        }
    }
}

impl ::protobuf::Clear for GenSeedRequest {
    fn clear(&mut self) {
        self.clear_aezeed_passphrase();
        self.clear_seed_entropy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenSeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenSeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenSeedResponse {
    // message fields
    pub cipher_seed_mnemonic: ::protobuf::RepeatedField<::std::string::String>,
    pub enciphered_seed: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GenSeedResponse {
    pub fn new() -> GenSeedResponse {
        ::std::default::Default::default()
    }

    // repeated string cipher_seed_mnemonic = 1;

    pub fn clear_cipher_seed_mnemonic(&mut self) {
        self.cipher_seed_mnemonic.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipher_seed_mnemonic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cipher_seed_mnemonic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipher_seed_mnemonic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cipher_seed_mnemonic
    }

    // Take field
    pub fn take_cipher_seed_mnemonic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cipher_seed_mnemonic, ::protobuf::RepeatedField::new())
    }

    pub fn get_cipher_seed_mnemonic(&self) -> &[::std::string::String] {
        &self.cipher_seed_mnemonic
    }

    // bytes enciphered_seed = 2;

    pub fn clear_enciphered_seed(&mut self) {
        self.enciphered_seed.clear();
    }

    // Param is passed by value, moved
    pub fn set_enciphered_seed(&mut self, v: ::std::vec::Vec<u8>) {
        self.enciphered_seed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enciphered_seed(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.enciphered_seed
    }

    // Take field
    pub fn take_enciphered_seed(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.enciphered_seed, ::std::vec::Vec::new())
    }

    pub fn get_enciphered_seed(&self) -> &[u8] {
        &self.enciphered_seed
    }
}

impl ::protobuf::Message for GenSeedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cipher_seed_mnemonic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.enciphered_seed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cipher_seed_mnemonic {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.enciphered_seed.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.enciphered_seed);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cipher_seed_mnemonic {
            os.write_string(1, &v)?;
        };
        if !self.enciphered_seed.is_empty() {
            os.write_bytes(2, &self.enciphered_seed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenSeedResponse {
        GenSeedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cipher_seed_mnemonic",
                    |m: &GenSeedResponse| { &m.cipher_seed_mnemonic },
                    |m: &mut GenSeedResponse| { &mut m.cipher_seed_mnemonic },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "enciphered_seed",
                    |m: &GenSeedResponse| { &m.enciphered_seed },
                    |m: &mut GenSeedResponse| { &mut m.enciphered_seed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenSeedResponse>(
                    "GenSeedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenSeedResponse {
        static mut instance: ::protobuf::lazy::Lazy<GenSeedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenSeedResponse,
        };
        unsafe {
            instance.get(GenSeedResponse::new)
        }
    }
}

impl ::protobuf::Clear for GenSeedResponse {
    fn clear(&mut self) {
        self.clear_cipher_seed_mnemonic();
        self.clear_enciphered_seed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenSeedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenSeedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InitWalletRequest {
    // message fields
    pub wallet_password: ::std::vec::Vec<u8>,
    pub cipher_seed_mnemonic: ::protobuf::RepeatedField<::std::string::String>,
    pub aezeed_passphrase: ::std::vec::Vec<u8>,
    pub recovery_window: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl InitWalletRequest {
    pub fn new() -> InitWalletRequest {
        ::std::default::Default::default()
    }

    // bytes wallet_password = 1;

    pub fn clear_wallet_password(&mut self) {
        self.wallet_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_wallet_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.wallet_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wallet_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.wallet_password
    }

    // Take field
    pub fn take_wallet_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.wallet_password, ::std::vec::Vec::new())
    }

    pub fn get_wallet_password(&self) -> &[u8] {
        &self.wallet_password
    }

    // repeated string cipher_seed_mnemonic = 2;

    pub fn clear_cipher_seed_mnemonic(&mut self) {
        self.cipher_seed_mnemonic.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipher_seed_mnemonic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cipher_seed_mnemonic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipher_seed_mnemonic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cipher_seed_mnemonic
    }

    // Take field
    pub fn take_cipher_seed_mnemonic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cipher_seed_mnemonic, ::protobuf::RepeatedField::new())
    }

    pub fn get_cipher_seed_mnemonic(&self) -> &[::std::string::String] {
        &self.cipher_seed_mnemonic
    }

    // bytes aezeed_passphrase = 3;

    pub fn clear_aezeed_passphrase(&mut self) {
        self.aezeed_passphrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_aezeed_passphrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.aezeed_passphrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aezeed_passphrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.aezeed_passphrase
    }

    // Take field
    pub fn take_aezeed_passphrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.aezeed_passphrase, ::std::vec::Vec::new())
    }

    pub fn get_aezeed_passphrase(&self) -> &[u8] {
        &self.aezeed_passphrase
    }

    // int32 recovery_window = 4;

    pub fn clear_recovery_window(&mut self) {
        self.recovery_window = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovery_window(&mut self, v: i32) {
        self.recovery_window = v;
    }

    pub fn get_recovery_window(&self) -> i32 {
        self.recovery_window
    }
}

impl ::protobuf::Message for InitWalletRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.wallet_password)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cipher_seed_mnemonic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.aezeed_passphrase)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recovery_window = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.wallet_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_password);
        }
        for value in &self.cipher_seed_mnemonic {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.aezeed_passphrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.aezeed_passphrase);
        }
        if self.recovery_window != 0 {
            my_size += ::protobuf::rt::value_size(4, self.recovery_window, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.wallet_password.is_empty() {
            os.write_bytes(1, &self.wallet_password)?;
        }
        for v in &self.cipher_seed_mnemonic {
            os.write_string(2, &v)?;
        };
        if !self.aezeed_passphrase.is_empty() {
            os.write_bytes(3, &self.aezeed_passphrase)?;
        }
        if self.recovery_window != 0 {
            os.write_int32(4, self.recovery_window)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitWalletRequest {
        InitWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "wallet_password",
                    |m: &InitWalletRequest| { &m.wallet_password },
                    |m: &mut InitWalletRequest| { &mut m.wallet_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cipher_seed_mnemonic",
                    |m: &InitWalletRequest| { &m.cipher_seed_mnemonic },
                    |m: &mut InitWalletRequest| { &mut m.cipher_seed_mnemonic },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "aezeed_passphrase",
                    |m: &InitWalletRequest| { &m.aezeed_passphrase },
                    |m: &mut InitWalletRequest| { &mut m.aezeed_passphrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "recovery_window",
                    |m: &InitWalletRequest| { &m.recovery_window },
                    |m: &mut InitWalletRequest| { &mut m.recovery_window },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InitWalletRequest>(
                    "InitWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InitWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<InitWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InitWalletRequest,
        };
        unsafe {
            instance.get(InitWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for InitWalletRequest {
    fn clear(&mut self) {
        self.clear_wallet_password();
        self.clear_cipher_seed_mnemonic();
        self.clear_aezeed_passphrase();
        self.clear_recovery_window();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InitWalletResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl InitWalletResponse {
    pub fn new() -> InitWalletResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InitWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitWalletResponse {
        InitWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<InitWalletResponse>(
                    "InitWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InitWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<InitWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InitWalletResponse,
        };
        unsafe {
            instance.get(InitWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for InitWalletResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlockWalletRequest {
    // message fields
    pub wallet_password: ::std::vec::Vec<u8>,
    pub recovery_window: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl UnlockWalletRequest {
    pub fn new() -> UnlockWalletRequest {
        ::std::default::Default::default()
    }

    // bytes wallet_password = 1;

    pub fn clear_wallet_password(&mut self) {
        self.wallet_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_wallet_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.wallet_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wallet_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.wallet_password
    }

    // Take field
    pub fn take_wallet_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.wallet_password, ::std::vec::Vec::new())
    }

    pub fn get_wallet_password(&self) -> &[u8] {
        &self.wallet_password
    }

    // int32 recovery_window = 2;

    pub fn clear_recovery_window(&mut self) {
        self.recovery_window = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovery_window(&mut self, v: i32) {
        self.recovery_window = v;
    }

    pub fn get_recovery_window(&self) -> i32 {
        self.recovery_window
    }
}

impl ::protobuf::Message for UnlockWalletRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.wallet_password)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recovery_window = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.wallet_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_password);
        }
        if self.recovery_window != 0 {
            my_size += ::protobuf::rt::value_size(2, self.recovery_window, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.wallet_password.is_empty() {
            os.write_bytes(1, &self.wallet_password)?;
        }
        if self.recovery_window != 0 {
            os.write_int32(2, self.recovery_window)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlockWalletRequest {
        UnlockWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "wallet_password",
                    |m: &UnlockWalletRequest| { &m.wallet_password },
                    |m: &mut UnlockWalletRequest| { &mut m.wallet_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "recovery_window",
                    |m: &UnlockWalletRequest| { &m.recovery_window },
                    |m: &mut UnlockWalletRequest| { &mut m.recovery_window },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnlockWalletRequest>(
                    "UnlockWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnlockWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<UnlockWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnlockWalletRequest,
        };
        unsafe {
            instance.get(UnlockWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for UnlockWalletRequest {
    fn clear(&mut self) {
        self.clear_wallet_password();
        self.clear_recovery_window();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlockWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlockWalletResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl UnlockWalletResponse {
    pub fn new() -> UnlockWalletResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnlockWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlockWalletResponse {
        UnlockWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UnlockWalletResponse>(
                    "UnlockWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnlockWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<UnlockWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnlockWalletResponse,
        };
        unsafe {
            instance.get(UnlockWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for UnlockWalletResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlockWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangePasswordRequest {
    // message fields
    pub current_password: ::std::vec::Vec<u8>,
    pub new_password: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChangePasswordRequest {
    pub fn new() -> ChangePasswordRequest {
        ::std::default::Default::default()
    }

    // bytes current_password = 1;

    pub fn clear_current_password(&mut self) {
        self.current_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.current_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.current_password
    }

    // Take field
    pub fn take_current_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.current_password, ::std::vec::Vec::new())
    }

    pub fn get_current_password(&self) -> &[u8] {
        &self.current_password
    }

    // bytes new_password = 2;

    pub fn clear_new_password(&mut self) {
        self.new_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.new_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.new_password
    }

    // Take field
    pub fn take_new_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.new_password, ::std::vec::Vec::new())
    }

    pub fn get_new_password(&self) -> &[u8] {
        &self.new_password
    }
}

impl ::protobuf::Message for ChangePasswordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.current_password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.new_password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.current_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.current_password);
        }
        if !self.new_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.new_password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.current_password.is_empty() {
            os.write_bytes(1, &self.current_password)?;
        }
        if !self.new_password.is_empty() {
            os.write_bytes(2, &self.new_password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePasswordRequest {
        ChangePasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "current_password",
                    |m: &ChangePasswordRequest| { &m.current_password },
                    |m: &mut ChangePasswordRequest| { &mut m.current_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "new_password",
                    |m: &ChangePasswordRequest| { &m.new_password },
                    |m: &mut ChangePasswordRequest| { &mut m.new_password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangePasswordRequest>(
                    "ChangePasswordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangePasswordRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChangePasswordRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangePasswordRequest,
        };
        unsafe {
            instance.get(ChangePasswordRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChangePasswordRequest {
    fn clear(&mut self) {
        self.clear_current_password();
        self.clear_new_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangePasswordResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChangePasswordResponse {
    pub fn new() -> ChangePasswordResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChangePasswordResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePasswordResponse {
        ChangePasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ChangePasswordResponse>(
                    "ChangePasswordResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangePasswordResponse {
        static mut instance: ::protobuf::lazy::Lazy<ChangePasswordResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangePasswordResponse,
        };
        unsafe {
            instance.get(ChangePasswordResponse::new)
        }
    }
}

impl ::protobuf::Clear for ChangePasswordResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub tx_hash: ::std::string::String,
    pub amount: i64,
    pub num_confirmations: i32,
    pub block_hash: ::std::string::String,
    pub block_height: i32,
    pub time_stamp: i64,
    pub total_fees: i64,
    pub dest_addresses: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // string tx_hash = 1;

    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }

    // int64 amount = 2;

    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    pub fn get_amount(&self) -> i64 {
        self.amount
    }

    // int32 num_confirmations = 3;

    pub fn clear_num_confirmations(&mut self) {
        self.num_confirmations = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_confirmations(&mut self, v: i32) {
        self.num_confirmations = v;
    }

    pub fn get_num_confirmations(&self) -> i32 {
        self.num_confirmations
    }

    // string block_hash = 4;

    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }

    // int32 block_height = 5;

    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }

    // int64 time_stamp = 6;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: i64) {
        self.time_stamp = v;
    }

    pub fn get_time_stamp(&self) -> i64 {
        self.time_stamp
    }

    // int64 total_fees = 7;

    pub fn clear_total_fees(&mut self) {
        self.total_fees = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees(&mut self, v: i64) {
        self.total_fees = v;
    }

    pub fn get_total_fees(&self) -> i64 {
        self.total_fees
    }

    // repeated string dest_addresses = 8;

    pub fn clear_dest_addresses(&mut self) {
        self.dest_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dest_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dest_addresses
    }

    // Take field
    pub fn take_dest_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dest_addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_dest_addresses(&self) -> &[::std::string::String] {
        &self.dest_addresses
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_confirmations = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_stamp = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dest_addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tx_hash);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_confirmations != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_confirmations, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block_hash);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_stamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.time_stamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_fees != 0 {
            my_size += ::protobuf::rt::value_size(7, self.total_fees, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dest_addresses {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.tx_hash.is_empty() {
            os.write_string(1, &self.tx_hash)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if self.num_confirmations != 0 {
            os.write_int32(3, self.num_confirmations)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(4, &self.block_hash)?;
        }
        if self.block_height != 0 {
            os.write_int32(5, self.block_height)?;
        }
        if self.time_stamp != 0 {
            os.write_int64(6, self.time_stamp)?;
        }
        if self.total_fees != 0 {
            os.write_int64(7, self.total_fees)?;
        }
        for v in &self.dest_addresses {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &Transaction| { &m.tx_hash },
                    |m: &mut Transaction| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &Transaction| { &m.amount },
                    |m: &mut Transaction| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_confirmations",
                    |m: &Transaction| { &m.num_confirmations },
                    |m: &mut Transaction| { &mut m.num_confirmations },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block_hash",
                    |m: &Transaction| { &m.block_hash },
                    |m: &mut Transaction| { &mut m.block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "block_height",
                    |m: &Transaction| { &m.block_height },
                    |m: &mut Transaction| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "time_stamp",
                    |m: &Transaction| { &m.time_stamp },
                    |m: &mut Transaction| { &mut m.time_stamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_fees",
                    |m: &Transaction| { &m.total_fees },
                    |m: &mut Transaction| { &mut m.total_fees },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dest_addresses",
                    |m: &Transaction| { &m.dest_addresses },
                    |m: &mut Transaction| { &mut m.dest_addresses },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction,
        };
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.clear_tx_hash();
        self.clear_amount();
        self.clear_num_confirmations();
        self.clear_block_hash();
        self.clear_block_height();
        self.clear_time_stamp();
        self.clear_total_fees();
        self.clear_dest_addresses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTransactionsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetTransactionsRequest {
    pub fn new() -> GetTransactionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTransactionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTransactionsRequest {
        GetTransactionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetTransactionsRequest>(
                    "GetTransactionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTransactionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetTransactionsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTransactionsRequest,
        };
        unsafe {
            instance.get(GetTransactionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetTransactionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTransactionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionDetails {
    // message fields
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TransactionDetails {
    pub fn new() -> TransactionDetails {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Transaction transactions = 1;

    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
}

impl ::protobuf::Message for TransactionDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionDetails {
        TransactionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "transactions",
                    |m: &TransactionDetails| { &m.transactions },
                    |m: &mut TransactionDetails| { &mut m.transactions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionDetails>(
                    "TransactionDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionDetails {
        static mut instance: ::protobuf::lazy::Lazy<TransactionDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionDetails,
        };
        unsafe {
            instance.get(TransactionDetails::new)
        }
    }
}

impl ::protobuf::Clear for TransactionDetails {
    fn clear(&mut self) {
        self.clear_transactions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeLimit {
    // message oneof groups
    pub limit: ::std::option::Option<FeeLimit_oneof_limit>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum FeeLimit_oneof_limit {
    fixed(i64),
    percent(i64),
}

impl FeeLimit {
    pub fn new() -> FeeLimit {
        ::std::default::Default::default()
    }

    // int64 fixed = 1;

    pub fn clear_fixed(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_fixed(&self) -> bool {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixed(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(v))
    }

    pub fn get_fixed(&self) -> i64 {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(v)) => v,
            _ => 0,
        }
    }

    // int64 percent = 2;

    pub fn clear_percent(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_percent(&self) -> bool {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::percent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_percent(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::percent(v))
    }

    pub fn get_percent(&self) -> i64 {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::percent(v)) => v,
            _ => 0,
        }
    }
}

impl ::protobuf::Message for FeeLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(is.read_int64()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::percent(is.read_int64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.limit {
            match v {
                &FeeLimit_oneof_limit::fixed(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &FeeLimit_oneof_limit::percent(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.limit {
            match v {
                &FeeLimit_oneof_limit::fixed(v) => {
                    os.write_int64(1, v)?;
                },
                &FeeLimit_oneof_limit::percent(v) => {
                    os.write_int64(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeLimit {
        FeeLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "fixed",
                    FeeLimit::has_fixed,
                    FeeLimit::get_fixed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "percent",
                    FeeLimit::has_percent,
                    FeeLimit::get_percent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeeLimit>(
                    "FeeLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeLimit {
        static mut instance: ::protobuf::lazy::Lazy<FeeLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeLimit,
        };
        unsafe {
            instance.get(FeeLimit::new)
        }
    }
}

impl ::protobuf::Clear for FeeLimit {
    fn clear(&mut self) {
        self.clear_fixed();
        self.clear_percent();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendRequest {
    // message fields
    pub dest: ::std::vec::Vec<u8>,
    pub dest_string: ::std::string::String,
    pub amt: i64,
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_hash_string: ::std::string::String,
    pub payment_request: ::std::string::String,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<FeeLimit>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SendRequest {
    pub fn new() -> SendRequest {
        ::std::default::Default::default()
    }

    // bytes dest = 1;

    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.dest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dest
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dest, ::std::vec::Vec::new())
    }

    pub fn get_dest(&self) -> &[u8] {
        &self.dest
    }

    // string dest_string = 2;

    pub fn clear_dest_string(&mut self) {
        self.dest_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_string(&mut self, v: ::std::string::String) {
        self.dest_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_string(&mut self) -> &mut ::std::string::String {
        &mut self.dest_string
    }

    // Take field
    pub fn take_dest_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dest_string, ::std::string::String::new())
    }

    pub fn get_dest_string(&self) -> &str {
        &self.dest_string
    }

    // int64 amt = 3;

    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    pub fn get_amt(&self) -> i64 {
        self.amt
    }

    // bytes payment_hash = 4;

    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }

    // string payment_hash_string = 5;

    pub fn clear_payment_hash_string(&mut self) {
        self.payment_hash_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash_string(&mut self, v: ::std::string::String) {
        self.payment_hash_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash_string(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash_string
    }

    // Take field
    pub fn take_payment_hash_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash_string, ::std::string::String::new())
    }

    pub fn get_payment_hash_string(&self) -> &str {
        &self.payment_hash_string
    }

    // string payment_request = 6;

    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }

    // int32 final_cltv_delta = 7;

    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }

    // .lnrpc.FeeLimit fee_limit = 8;

    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| FeeLimit::new())
    }

    pub fn get_fee_limit(&self) -> &FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| FeeLimit::default_instance())
    }
}

impl ::protobuf::Message for SendRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dest_string)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash_string)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.dest);
        }
        if !self.dest_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dest_string);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payment_hash);
        }
        if !self.payment_hash_string.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payment_hash_string);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_request);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(7, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.dest.is_empty() {
            os.write_bytes(1, &self.dest)?;
        }
        if !self.dest_string.is_empty() {
            os.write_string(2, &self.dest_string)?;
        }
        if self.amt != 0 {
            os.write_int64(3, self.amt)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(4, &self.payment_hash)?;
        }
        if !self.payment_hash_string.is_empty() {
            os.write_string(5, &self.payment_hash_string)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(6, &self.payment_request)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(7, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendRequest {
        SendRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dest",
                    |m: &SendRequest| { &m.dest },
                    |m: &mut SendRequest| { &mut m.dest },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dest_string",
                    |m: &SendRequest| { &m.dest_string },
                    |m: &mut SendRequest| { &mut m.dest_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt",
                    |m: &SendRequest| { &m.amt },
                    |m: &mut SendRequest| { &mut m.amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_hash",
                    |m: &SendRequest| { &m.payment_hash },
                    |m: &mut SendRequest| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash_string",
                    |m: &SendRequest| { &m.payment_hash_string },
                    |m: &mut SendRequest| { &mut m.payment_hash_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &SendRequest| { &m.payment_request },
                    |m: &mut SendRequest| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_cltv_delta",
                    |m: &SendRequest| { &m.final_cltv_delta },
                    |m: &mut SendRequest| { &mut m.final_cltv_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeLimit>>(
                    "fee_limit",
                    |m: &SendRequest| { &m.fee_limit },
                    |m: &mut SendRequest| { &mut m.fee_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendRequest>(
                    "SendRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendRequest,
        };
        unsafe {
            instance.get(SendRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendRequest {
    fn clear(&mut self) {
        self.clear_dest();
        self.clear_dest_string();
        self.clear_amt();
        self.clear_payment_hash();
        self.clear_payment_hash_string();
        self.clear_payment_request();
        self.clear_final_cltv_delta();
        self.clear_fee_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendResponse {
    // message fields
    pub payment_error: ::std::string::String,
    pub payment_preimage: ::std::vec::Vec<u8>,
    pub payment_route: ::protobuf::SingularPtrField<Route>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SendResponse {
    pub fn new() -> SendResponse {
        ::std::default::Default::default()
    }

    // string payment_error = 1;

    pub fn clear_payment_error(&mut self) {
        self.payment_error.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_error(&mut self, v: ::std::string::String) {
        self.payment_error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_error(&mut self) -> &mut ::std::string::String {
        &mut self.payment_error
    }

    // Take field
    pub fn take_payment_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_error, ::std::string::String::new())
    }

    pub fn get_payment_error(&self) -> &str {
        &self.payment_error
    }

    // bytes payment_preimage = 2;

    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_preimage, ::std::vec::Vec::new())
    }

    pub fn get_payment_preimage(&self) -> &[u8] {
        &self.payment_preimage
    }

    // .lnrpc.Route payment_route = 3;

    pub fn clear_payment_route(&mut self) {
        self.payment_route.clear();
    }

    pub fn has_payment_route(&self) -> bool {
        self.payment_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_route(&mut self, v: Route) {
        self.payment_route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_route(&mut self) -> &mut Route {
        if self.payment_route.is_none() {
            self.payment_route.set_default();
        }
        self.payment_route.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_route(&mut self) -> Route {
        self.payment_route.take().unwrap_or_else(|| Route::new())
    }

    pub fn get_payment_route(&self) -> &Route {
        self.payment_route.as_ref().unwrap_or_else(|| Route::default_instance())
    }
}

impl ::protobuf::Message for SendResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_preimage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payment_route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_error);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payment_preimage);
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_error.is_empty() {
            os.write_string(1, &self.payment_error)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_bytes(2, &self.payment_preimage)?;
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendResponse {
        SendResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_error",
                    |m: &SendResponse| { &m.payment_error },
                    |m: &mut SendResponse| { &mut m.payment_error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_preimage",
                    |m: &SendResponse| { &m.payment_preimage },
                    |m: &mut SendResponse| { &mut m.payment_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                    "payment_route",
                    |m: &SendResponse| { &m.payment_route },
                    |m: &mut SendResponse| { &mut m.payment_route },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendResponse>(
                    "SendResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendResponse,
        };
        unsafe {
            instance.get(SendResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendResponse {
    fn clear(&mut self) {
        self.clear_payment_error();
        self.clear_payment_preimage();
        self.clear_payment_route();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendToRouteRequest {
    // message fields
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_hash_string: ::std::string::String,
    pub routes: ::protobuf::RepeatedField<Route>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SendToRouteRequest {
    pub fn new() -> SendToRouteRequest {
        ::std::default::Default::default()
    }

    // bytes payment_hash = 1;

    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }

    // string payment_hash_string = 2;

    pub fn clear_payment_hash_string(&mut self) {
        self.payment_hash_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash_string(&mut self, v: ::std::string::String) {
        self.payment_hash_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash_string(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash_string
    }

    // Take field
    pub fn take_payment_hash_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash_string, ::std::string::String::new())
    }

    pub fn get_payment_hash_string(&self) -> &str {
        &self.payment_hash_string
    }

    // repeated .lnrpc.Route routes = 3;

    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    pub fn get_routes(&self) -> &[Route] {
        &self.routes
    }
}

impl ::protobuf::Message for SendToRouteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash_string)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payment_hash);
        }
        if !self.payment_hash_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_hash_string);
        }
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_bytes(1, &self.payment_hash)?;
        }
        if !self.payment_hash_string.is_empty() {
            os.write_string(2, &self.payment_hash_string)?;
        }
        for v in &self.routes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToRouteRequest {
        SendToRouteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_hash",
                    |m: &SendToRouteRequest| { &m.payment_hash },
                    |m: &mut SendToRouteRequest| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash_string",
                    |m: &SendToRouteRequest| { &m.payment_hash_string },
                    |m: &mut SendToRouteRequest| { &mut m.payment_hash_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                    "routes",
                    |m: &SendToRouteRequest| { &m.routes },
                    |m: &mut SendToRouteRequest| { &mut m.routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendToRouteRequest>(
                    "SendToRouteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendToRouteRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendToRouteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendToRouteRequest,
        };
        unsafe {
            instance.get(SendToRouteRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendToRouteRequest {
    fn clear(&mut self) {
        self.clear_payment_hash();
        self.clear_payment_hash_string();
        self.clear_routes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToRouteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToRouteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelPoint {
    // message fields
    pub output_index: u32,
    // message oneof groups
    pub funding_txid: ::std::option::Option<ChannelPoint_oneof_funding_txid>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum ChannelPoint_oneof_funding_txid {
    funding_txid_bytes(::std::vec::Vec<u8>),
    funding_txid_str(::std::string::String),
}

impl ChannelPoint {
    pub fn new() -> ChannelPoint {
        ::std::default::Default::default()
    }

    // bytes funding_txid_bytes = 1;

    pub fn clear_funding_txid_bytes(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_bytes(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(::std::vec::Vec::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_funding_txid_bytes() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_funding_txid_bytes(&self) -> &[u8] {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v)) => v,
            _ => &[],
        }
    }

    // string funding_txid_str = 2;

    pub fn clear_funding_txid_str(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_str(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_str(&mut self, v: ::std::string::String) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_str(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(::std::string::String::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_str(&mut self) -> ::std::string::String {
        if self.has_funding_txid_str() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_funding_txid_str(&self) -> &str {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref v)) => v,
            _ => "",
        }
    }

    // uint32 output_index = 3;

    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }

    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
}

impl ::protobuf::Message for ChannelPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.output_index != 0 {
            os.write_uint32(3, self.output_index)?;
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelPoint {
        ChannelPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "funding_txid_bytes",
                    ChannelPoint::has_funding_txid_bytes,
                    ChannelPoint::get_funding_txid_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "funding_txid_str",
                    ChannelPoint::has_funding_txid_str,
                    ChannelPoint::get_funding_txid_str,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &ChannelPoint| { &m.output_index },
                    |m: &mut ChannelPoint| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelPoint>(
                    "ChannelPoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelPoint {
        static mut instance: ::protobuf::lazy::Lazy<ChannelPoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelPoint,
        };
        unsafe {
            instance.get(ChannelPoint::new)
        }
    }
}

impl ::protobuf::Clear for ChannelPoint {
    fn clear(&mut self) {
        self.clear_funding_txid_bytes();
        self.clear_funding_txid_str();
        self.clear_output_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightningAddress {
    // message fields
    pub pubkey: ::std::string::String,
    pub host: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LightningAddress {
    pub fn new() -> LightningAddress {
        ::std::default::Default::default()
    }

    // string pubkey = 1;

    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }

    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }

    // string host = 2;

    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    pub fn get_host(&self) -> &str {
        &self.host
    }
}

impl ::protobuf::Message for LightningAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pubkey);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pubkey.is_empty() {
            os.write_string(1, &self.pubkey)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningAddress {
        LightningAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pubkey",
                    |m: &LightningAddress| { &m.pubkey },
                    |m: &mut LightningAddress| { &mut m.pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    |m: &LightningAddress| { &m.host },
                    |m: &mut LightningAddress| { &mut m.host },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LightningAddress>(
                    "LightningAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LightningAddress {
        static mut instance: ::protobuf::lazy::Lazy<LightningAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LightningAddress,
        };
        unsafe {
            instance.get(LightningAddress::new)
        }
    }
}

impl ::protobuf::Clear for LightningAddress {
    fn clear(&mut self) {
        self.clear_pubkey();
        self.clear_host();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendManyRequest {
    // message fields
    pub AddrToAmount: ::std::collections::HashMap<::std::string::String, i64>,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SendManyRequest {
    pub fn new() -> SendManyRequest {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.SendManyRequest.AddrToAmountEntry AddrToAmount = 1;

    pub fn clear_AddrToAmount(&mut self) {
        self.AddrToAmount.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddrToAmount(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.AddrToAmount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddrToAmount(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.AddrToAmount
    }

    // Take field
    pub fn take_AddrToAmount(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.AddrToAmount, ::std::collections::HashMap::new())
    }

    pub fn get_AddrToAmount(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.AddrToAmount
    }

    // int32 target_conf = 3;

    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }

    // int64 sat_per_byte = 5;

    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
}

impl ::protobuf::Message for SendManyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.AddrToAmount)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount);
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(5, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount, os)?;
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(5, self.sat_per_byte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyRequest {
        SendManyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "AddrToAmount",
                    |m: &SendManyRequest| { &m.AddrToAmount },
                    |m: &mut SendManyRequest| { &mut m.AddrToAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &SendManyRequest| { &m.target_conf },
                    |m: &mut SendManyRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &SendManyRequest| { &m.sat_per_byte },
                    |m: &mut SendManyRequest| { &mut m.sat_per_byte },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendManyRequest>(
                    "SendManyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendManyRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendManyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendManyRequest,
        };
        unsafe {
            instance.get(SendManyRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendManyRequest {
    fn clear(&mut self) {
        self.clear_AddrToAmount();
        self.clear_target_conf();
        self.clear_sat_per_byte();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendManyResponse {
    // message fields
    pub txid: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SendManyResponse {
    pub fn new() -> SendManyResponse {
        ::std::default::Default::default()
    }

    // string txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }

    pub fn get_txid(&self) -> &str {
        &self.txid
    }
}

impl ::protobuf::Message for SendManyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_string(1, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyResponse {
        SendManyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &SendManyResponse| { &m.txid },
                    |m: &mut SendManyResponse| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendManyResponse>(
                    "SendManyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendManyResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendManyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendManyResponse,
        };
        unsafe {
            instance.get(SendManyResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendManyResponse {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendCoinsRequest {
    // message fields
    pub addr: ::std::string::String,
    pub amount: i64,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SendCoinsRequest {
    pub fn new() -> SendCoinsRequest {
        ::std::default::Default::default()
    }

    // string addr = 1;

    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }

    pub fn get_addr(&self) -> &str {
        &self.addr
    }

    // int64 amount = 2;

    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    pub fn get_amount(&self) -> i64 {
        self.amount
    }

    // int32 target_conf = 3;

    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }

    // int64 sat_per_byte = 5;

    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
}

impl ::protobuf::Message for SendCoinsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.addr);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(5, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.addr.is_empty() {
            os.write_string(1, &self.addr)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(5, self.sat_per_byte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCoinsRequest {
        SendCoinsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addr",
                    |m: &SendCoinsRequest| { &m.addr },
                    |m: &mut SendCoinsRequest| { &mut m.addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &SendCoinsRequest| { &m.amount },
                    |m: &mut SendCoinsRequest| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &SendCoinsRequest| { &m.target_conf },
                    |m: &mut SendCoinsRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &SendCoinsRequest| { &m.sat_per_byte },
                    |m: &mut SendCoinsRequest| { &mut m.sat_per_byte },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendCoinsRequest>(
                    "SendCoinsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendCoinsRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendCoinsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendCoinsRequest,
        };
        unsafe {
            instance.get(SendCoinsRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendCoinsRequest {
    fn clear(&mut self) {
        self.clear_addr();
        self.clear_amount();
        self.clear_target_conf();
        self.clear_sat_per_byte();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCoinsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCoinsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendCoinsResponse {
    // message fields
    pub txid: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SendCoinsResponse {
    pub fn new() -> SendCoinsResponse {
        ::std::default::Default::default()
    }

    // string txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }

    pub fn get_txid(&self) -> &str {
        &self.txid
    }
}

impl ::protobuf::Message for SendCoinsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_string(1, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCoinsResponse {
        SendCoinsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &SendCoinsResponse| { &m.txid },
                    |m: &mut SendCoinsResponse| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendCoinsResponse>(
                    "SendCoinsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendCoinsResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendCoinsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendCoinsResponse,
        };
        unsafe {
            instance.get(SendCoinsResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendCoinsResponse {
    fn clear(&mut self) {
        self.clear_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCoinsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCoinsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewAddressRequest {
    // message fields
    pub field_type: NewAddressRequest_AddressType,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NewAddressRequest {
    pub fn new() -> NewAddressRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.NewAddressRequest.AddressType type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = NewAddressRequest_AddressType::WITNESS_PUBKEY_HASH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: NewAddressRequest_AddressType) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> NewAddressRequest_AddressType {
        self.field_type
    }
}

impl ::protobuf::Message for NewAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != NewAddressRequest_AddressType::WITNESS_PUBKEY_HASH {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != NewAddressRequest_AddressType::WITNESS_PUBKEY_HASH {
            os.write_enum(1, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewAddressRequest {
        NewAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NewAddressRequest_AddressType>>(
                    "type",
                    |m: &NewAddressRequest| { &m.field_type },
                    |m: &mut NewAddressRequest| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NewAddressRequest>(
                    "NewAddressRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NewAddressRequest {
        static mut instance: ::protobuf::lazy::Lazy<NewAddressRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NewAddressRequest,
        };
        unsafe {
            instance.get(NewAddressRequest::new)
        }
    }
}

impl ::protobuf::Clear for NewAddressRequest {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NewAddressRequest_AddressType {
    WITNESS_PUBKEY_HASH = 0,
    NESTED_PUBKEY_HASH = 1,
}

impl ::protobuf::ProtobufEnum for NewAddressRequest_AddressType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NewAddressRequest_AddressType> {
        match value {
            0 => ::std::option::Option::Some(NewAddressRequest_AddressType::WITNESS_PUBKEY_HASH),
            1 => ::std::option::Option::Some(NewAddressRequest_AddressType::NESTED_PUBKEY_HASH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NewAddressRequest_AddressType] = &[
            NewAddressRequest_AddressType::WITNESS_PUBKEY_HASH,
            NewAddressRequest_AddressType::NESTED_PUBKEY_HASH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NewAddressRequest_AddressType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NewAddressRequest_AddressType {
}

impl ::std::default::Default for NewAddressRequest_AddressType {
    fn default() -> Self {
        NewAddressRequest_AddressType::WITNESS_PUBKEY_HASH
    }
}

impl ::protobuf::reflect::ProtobufValue for NewAddressRequest_AddressType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewAddressResponse {
    // message fields
    pub address: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NewAddressResponse {
    pub fn new() -> NewAddressResponse {
        ::std::default::Default::default()
    }

    // string address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        &self.address
    }
}

impl ::protobuf::Message for NewAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewAddressResponse {
        NewAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &NewAddressResponse| { &m.address },
                    |m: &mut NewAddressResponse| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NewAddressResponse>(
                    "NewAddressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NewAddressResponse {
        static mut instance: ::protobuf::lazy::Lazy<NewAddressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NewAddressResponse,
        };
        unsafe {
            instance.get(NewAddressResponse::new)
        }
    }
}

impl ::protobuf::Clear for NewAddressResponse {
    fn clear(&mut self) {
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageRequest {
    // message fields
    pub msg: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SignMessageRequest {
    pub fn new() -> SignMessageRequest {
        ::std::default::Default::default()
    }

    // bytes msg = 1;

    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.msg
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.msg, ::std::vec::Vec::new())
    }

    pub fn get_msg(&self) -> &[u8] {
        &self.msg
    }
}

impl ::protobuf::Message for SignMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.msg.is_empty() {
            os.write_bytes(1, &self.msg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageRequest {
        SignMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "msg",
                    |m: &SignMessageRequest| { &m.msg },
                    |m: &mut SignMessageRequest| { &mut m.msg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageRequest>(
                    "SignMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageRequest,
        };
        unsafe {
            instance.get(SignMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageRequest {
    fn clear(&mut self) {
        self.clear_msg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageResponse {
    // message fields
    pub signature: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SignMessageResponse {
    pub fn new() -> SignMessageResponse {
        ::std::default::Default::default()
    }

    // string signature = 1;

    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }

    pub fn get_signature(&self) -> &str {
        &self.signature
    }
}

impl ::protobuf::Message for SignMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_string(1, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageResponse {
        SignMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &SignMessageResponse| { &m.signature },
                    |m: &mut SignMessageResponse| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageResponse>(
                    "SignMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageResponse,
        };
        unsafe {
            instance.get(SignMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageResponse {
    fn clear(&mut self) {
        self.clear_signature();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyMessageRequest {
    // message fields
    pub msg: ::std::vec::Vec<u8>,
    pub signature: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VerifyMessageRequest {
    pub fn new() -> VerifyMessageRequest {
        ::std::default::Default::default()
    }

    // bytes msg = 1;

    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.msg
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.msg, ::std::vec::Vec::new())
    }

    pub fn get_msg(&self) -> &[u8] {
        &self.msg
    }

    // string signature = 2;

    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }

    pub fn get_signature(&self) -> &str {
        &self.signature
    }
}

impl ::protobuf::Message for VerifyMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.msg)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.msg);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.msg.is_empty() {
            os.write_bytes(1, &self.msg)?;
        }
        if !self.signature.is_empty() {
            os.write_string(2, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageRequest {
        VerifyMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "msg",
                    |m: &VerifyMessageRequest| { &m.msg },
                    |m: &mut VerifyMessageRequest| { &mut m.msg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &VerifyMessageRequest| { &m.signature },
                    |m: &mut VerifyMessageRequest| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerifyMessageRequest>(
                    "VerifyMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<VerifyMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerifyMessageRequest,
        };
        unsafe {
            instance.get(VerifyMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for VerifyMessageRequest {
    fn clear(&mut self) {
        self.clear_msg();
        self.clear_signature();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyMessageResponse {
    // message fields
    pub valid: bool,
    pub pubkey: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VerifyMessageResponse {
    pub fn new() -> VerifyMessageResponse {
        ::std::default::Default::default()
    }

    // bool valid = 1;

    pub fn clear_valid(&mut self) {
        self.valid = false;
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = v;
    }

    pub fn get_valid(&self) -> bool {
        self.valid
    }

    // string pubkey = 2;

    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }

    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }
}

impl ::protobuf::Message for VerifyMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.valid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valid != false {
            my_size += 2;
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pubkey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.valid != false {
            os.write_bool(1, self.valid)?;
        }
        if !self.pubkey.is_empty() {
            os.write_string(2, &self.pubkey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageResponse {
        VerifyMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "valid",
                    |m: &VerifyMessageResponse| { &m.valid },
                    |m: &mut VerifyMessageResponse| { &mut m.valid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pubkey",
                    |m: &VerifyMessageResponse| { &m.pubkey },
                    |m: &mut VerifyMessageResponse| { &mut m.pubkey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerifyMessageResponse>(
                    "VerifyMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<VerifyMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerifyMessageResponse,
        };
        unsafe {
            instance.get(VerifyMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for VerifyMessageResponse {
    fn clear(&mut self) {
        self.clear_valid();
        self.clear_pubkey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectPeerRequest {
    // message fields
    pub addr: ::protobuf::SingularPtrField<LightningAddress>,
    pub perm: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConnectPeerRequest {
    pub fn new() -> ConnectPeerRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.LightningAddress addr = 1;

    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: LightningAddress) {
        self.addr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut LightningAddress {
        if self.addr.is_none() {
            self.addr.set_default();
        }
        self.addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_addr(&mut self) -> LightningAddress {
        self.addr.take().unwrap_or_else(|| LightningAddress::new())
    }

    pub fn get_addr(&self) -> &LightningAddress {
        self.addr.as_ref().unwrap_or_else(|| LightningAddress::default_instance())
    }

    // bool perm = 2;

    pub fn clear_perm(&mut self) {
        self.perm = false;
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: bool) {
        self.perm = v;
    }

    pub fn get_perm(&self) -> bool {
        self.perm
    }
}

impl ::protobuf::Message for ConnectPeerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.addr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perm = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.perm != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.perm != false {
            os.write_bool(2, self.perm)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectPeerRequest {
        ConnectPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningAddress>>(
                    "addr",
                    |m: &ConnectPeerRequest| { &m.addr },
                    |m: &mut ConnectPeerRequest| { &mut m.addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "perm",
                    |m: &ConnectPeerRequest| { &m.perm },
                    |m: &mut ConnectPeerRequest| { &mut m.perm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectPeerRequest>(
                    "ConnectPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConnectPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectPeerRequest,
        };
        unsafe {
            instance.get(ConnectPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConnectPeerRequest {
    fn clear(&mut self) {
        self.clear_addr();
        self.clear_perm();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectPeerResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConnectPeerResponse {
    pub fn new() -> ConnectPeerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConnectPeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectPeerResponse {
        ConnectPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConnectPeerResponse>(
                    "ConnectPeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectPeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<ConnectPeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectPeerResponse,
        };
        unsafe {
            instance.get(ConnectPeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for ConnectPeerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectPeerRequest {
    // message fields
    pub pub_key: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DisconnectPeerRequest {
    pub fn new() -> DisconnectPeerRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;

    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
}

impl ::protobuf::Message for DisconnectPeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectPeerRequest {
        DisconnectPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &DisconnectPeerRequest| { &m.pub_key },
                    |m: &mut DisconnectPeerRequest| { &mut m.pub_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisconnectPeerRequest>(
                    "DisconnectPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisconnectPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<DisconnectPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisconnectPeerRequest,
        };
        unsafe {
            instance.get(DisconnectPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for DisconnectPeerRequest {
    fn clear(&mut self) {
        self.clear_pub_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectPeerResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DisconnectPeerResponse {
    pub fn new() -> DisconnectPeerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisconnectPeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectPeerResponse {
        DisconnectPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DisconnectPeerResponse>(
                    "DisconnectPeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisconnectPeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<DisconnectPeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisconnectPeerResponse,
        };
        unsafe {
            instance.get(DisconnectPeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for DisconnectPeerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTLC {
    // message fields
    pub incoming: bool,
    pub amount: i64,
    pub hash_lock: ::std::vec::Vec<u8>,
    pub expiration_height: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl HTLC {
    pub fn new() -> HTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;

    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    pub fn get_incoming(&self) -> bool {
        self.incoming
    }

    // int64 amount = 2;

    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    pub fn get_amount(&self) -> i64 {
        self.amount
    }

    // bytes hash_lock = 3;

    pub fn clear_hash_lock(&mut self) {
        self.hash_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash_lock
    }

    // Take field
    pub fn take_hash_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash_lock, ::std::vec::Vec::new())
    }

    pub fn get_hash_lock(&self) -> &[u8] {
        &self.hash_lock
    }

    // uint32 expiration_height = 4;

    pub fn clear_expiration_height(&mut self) {
        self.expiration_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_height(&mut self, v: u32) {
        self.expiration_height = v;
    }

    pub fn get_expiration_height(&self) -> u32 {
        self.expiration_height
    }
}

impl ::protobuf::Message for HTLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash_lock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hash_lock);
        }
        if self.expiration_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.expiration_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if !self.hash_lock.is_empty() {
            os.write_bytes(3, &self.hash_lock)?;
        }
        if self.expiration_height != 0 {
            os.write_uint32(4, self.expiration_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTLC {
        HTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "incoming",
                    |m: &HTLC| { &m.incoming },
                    |m: &mut HTLC| { &mut m.incoming },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &HTLC| { &m.amount },
                    |m: &mut HTLC| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash_lock",
                    |m: &HTLC| { &m.hash_lock },
                    |m: &mut HTLC| { &mut m.hash_lock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expiration_height",
                    |m: &HTLC| { &m.expiration_height },
                    |m: &mut HTLC| { &mut m.expiration_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTLC>(
                    "HTLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTLC {
        static mut instance: ::protobuf::lazy::Lazy<HTLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTLC,
        };
        unsafe {
            instance.get(HTLC::new)
        }
    }
}

impl ::protobuf::Clear for HTLC {
    fn clear(&mut self) {
        self.clear_incoming();
        self.clear_amount();
        self.clear_hash_lock();
        self.clear_expiration_height();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel {
    // message fields
    pub active: bool,
    pub remote_pubkey: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub chan_id: u64,
    pub capacity: i64,
    pub local_balance: i64,
    pub remote_balance: i64,
    pub commit_fee: i64,
    pub commit_weight: i64,
    pub fee_per_kw: i64,
    pub unsettled_balance: i64,
    pub total_satoshis_sent: i64,
    pub total_satoshis_received: i64,
    pub num_updates: u64,
    pub pending_htlcs: ::protobuf::RepeatedField<HTLC>,
    pub csv_delay: u32,
    pub private: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // bool active = 1;

    pub fn clear_active(&mut self) {
        self.active = false;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = v;
    }

    pub fn get_active(&self) -> bool {
        self.active
    }

    // string remote_pubkey = 2;

    pub fn clear_remote_pubkey(&mut self) {
        self.remote_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pubkey(&mut self, v: ::std::string::String) {
        self.remote_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pubkey
    }

    // Take field
    pub fn take_remote_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pubkey, ::std::string::String::new())
    }

    pub fn get_remote_pubkey(&self) -> &str {
        &self.remote_pubkey
    }

    // string channel_point = 3;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }

    // uint64 chan_id = 4;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }

    // int64 capacity = 5;

    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }

    // int64 local_balance = 6;

    pub fn clear_local_balance(&mut self) {
        self.local_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: i64) {
        self.local_balance = v;
    }

    pub fn get_local_balance(&self) -> i64 {
        self.local_balance
    }

    // int64 remote_balance = 7;

    pub fn clear_remote_balance(&mut self) {
        self.remote_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: i64) {
        self.remote_balance = v;
    }

    pub fn get_remote_balance(&self) -> i64 {
        self.remote_balance
    }

    // int64 commit_fee = 8;

    pub fn clear_commit_fee(&mut self) {
        self.commit_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: i64) {
        self.commit_fee = v;
    }

    pub fn get_commit_fee(&self) -> i64 {
        self.commit_fee
    }

    // int64 commit_weight = 9;

    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }

    // int64 fee_per_kw = 10;

    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: i64) {
        self.fee_per_kw = v;
    }

    pub fn get_fee_per_kw(&self) -> i64 {
        self.fee_per_kw
    }

    // int64 unsettled_balance = 11;

    pub fn clear_unsettled_balance(&mut self) {
        self.unsettled_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_unsettled_balance(&mut self, v: i64) {
        self.unsettled_balance = v;
    }

    pub fn get_unsettled_balance(&self) -> i64 {
        self.unsettled_balance
    }

    // int64 total_satoshis_sent = 12;

    pub fn clear_total_satoshis_sent(&mut self) {
        self.total_satoshis_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_satoshis_sent(&mut self, v: i64) {
        self.total_satoshis_sent = v;
    }

    pub fn get_total_satoshis_sent(&self) -> i64 {
        self.total_satoshis_sent
    }

    // int64 total_satoshis_received = 13;

    pub fn clear_total_satoshis_received(&mut self) {
        self.total_satoshis_received = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_satoshis_received(&mut self, v: i64) {
        self.total_satoshis_received = v;
    }

    pub fn get_total_satoshis_received(&self) -> i64 {
        self.total_satoshis_received
    }

    // uint64 num_updates = 14;

    pub fn clear_num_updates(&mut self) {
        self.num_updates = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_updates(&mut self, v: u64) {
        self.num_updates = v;
    }

    pub fn get_num_updates(&self) -> u64 {
        self.num_updates
    }

    // repeated .lnrpc.HTLC pending_htlcs = 15;

    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<HTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<HTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<HTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_htlcs(&self) -> &[HTLC] {
        &self.pending_htlcs
    }

    // uint32 csv_delay = 16;

    pub fn clear_csv_delay(&mut self) {
        self.csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_csv_delay(&mut self, v: u32) {
        self.csv_delay = v;
    }

    pub fn get_csv_delay(&self) -> u32 {
        self.csv_delay
    }

    // bool private = 17;

    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    pub fn get_private(&self) -> bool {
        self.private
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_balance = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_balance = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_fee = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_kw = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unsettled_balance = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_satoshis_sent = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_satoshis_received = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_updates = tmp;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.csv_delay = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active != false {
            my_size += 2;
        }
        if !self.remote_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.remote_pubkey);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.channel_point);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_balance != 0 {
            my_size += ::protobuf::rt::value_size(6, self.local_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_balance != 0 {
            my_size += ::protobuf::rt::value_size(7, self.remote_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_fee != 0 {
            my_size += ::protobuf::rt::value_size(8, self.commit_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(9, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(10, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unsettled_balance != 0 {
            my_size += ::protobuf::rt::value_size(11, self.unsettled_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_satoshis_sent != 0 {
            my_size += ::protobuf::rt::value_size(12, self.total_satoshis_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_satoshis_received != 0 {
            my_size += ::protobuf::rt::value_size(13, self.total_satoshis_received, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_updates != 0 {
            my_size += ::protobuf::rt::value_size(14, self.num_updates, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(16, self.csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.private != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.active != false {
            os.write_bool(1, self.active)?;
        }
        if !self.remote_pubkey.is_empty() {
            os.write_string(2, &self.remote_pubkey)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(3, &self.channel_point)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(4, self.chan_id)?;
        }
        if self.capacity != 0 {
            os.write_int64(5, self.capacity)?;
        }
        if self.local_balance != 0 {
            os.write_int64(6, self.local_balance)?;
        }
        if self.remote_balance != 0 {
            os.write_int64(7, self.remote_balance)?;
        }
        if self.commit_fee != 0 {
            os.write_int64(8, self.commit_fee)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(9, self.commit_weight)?;
        }
        if self.fee_per_kw != 0 {
            os.write_int64(10, self.fee_per_kw)?;
        }
        if self.unsettled_balance != 0 {
            os.write_int64(11, self.unsettled_balance)?;
        }
        if self.total_satoshis_sent != 0 {
            os.write_int64(12, self.total_satoshis_sent)?;
        }
        if self.total_satoshis_received != 0 {
            os.write_int64(13, self.total_satoshis_received)?;
        }
        if self.num_updates != 0 {
            os.write_uint64(14, self.num_updates)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.csv_delay != 0 {
            os.write_uint32(16, self.csv_delay)?;
        }
        if self.private != false {
            os.write_bool(17, self.private)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active",
                    |m: &Channel| { &m.active },
                    |m: &mut Channel| { &mut m.active },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_pubkey",
                    |m: &Channel| { &m.remote_pubkey },
                    |m: &mut Channel| { &mut m.remote_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &Channel| { &m.channel_point },
                    |m: &mut Channel| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &Channel| { &m.chan_id },
                    |m: &mut Channel| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &Channel| { &m.capacity },
                    |m: &mut Channel| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_balance",
                    |m: &Channel| { &m.local_balance },
                    |m: &mut Channel| { &mut m.local_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remote_balance",
                    |m: &Channel| { &m.remote_balance },
                    |m: &mut Channel| { &mut m.remote_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_fee",
                    |m: &Channel| { &m.commit_fee },
                    |m: &mut Channel| { &mut m.commit_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_weight",
                    |m: &Channel| { &m.commit_weight },
                    |m: &mut Channel| { &mut m.commit_weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_per_kw",
                    |m: &Channel| { &m.fee_per_kw },
                    |m: &mut Channel| { &mut m.fee_per_kw },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unsettled_balance",
                    |m: &Channel| { &m.unsettled_balance },
                    |m: &mut Channel| { &mut m.unsettled_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_satoshis_sent",
                    |m: &Channel| { &m.total_satoshis_sent },
                    |m: &mut Channel| { &mut m.total_satoshis_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_satoshis_received",
                    |m: &Channel| { &m.total_satoshis_received },
                    |m: &mut Channel| { &mut m.total_satoshis_received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_updates",
                    |m: &Channel| { &m.num_updates },
                    |m: &mut Channel| { &mut m.num_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTLC>>(
                    "pending_htlcs",
                    |m: &Channel| { &m.pending_htlcs },
                    |m: &mut Channel| { &mut m.pending_htlcs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "csv_delay",
                    |m: &Channel| { &m.csv_delay },
                    |m: &mut Channel| { &mut m.csv_delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &Channel| { &m.private },
                    |m: &mut Channel| { &mut m.private },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Channel>(
                    "Channel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Channel {
        static mut instance: ::protobuf::lazy::Lazy<Channel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Channel,
        };
        unsafe {
            instance.get(Channel::new)
        }
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.clear_active();
        self.clear_remote_pubkey();
        self.clear_channel_point();
        self.clear_chan_id();
        self.clear_capacity();
        self.clear_local_balance();
        self.clear_remote_balance();
        self.clear_commit_fee();
        self.clear_commit_weight();
        self.clear_fee_per_kw();
        self.clear_unsettled_balance();
        self.clear_total_satoshis_sent();
        self.clear_total_satoshis_received();
        self.clear_num_updates();
        self.clear_pending_htlcs();
        self.clear_csv_delay();
        self.clear_private();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelsRequest {
    // message fields
    pub active_only: bool,
    pub inactive_only: bool,
    pub public_only: bool,
    pub private_only: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListChannelsRequest {
    pub fn new() -> ListChannelsRequest {
        ::std::default::Default::default()
    }

    // bool active_only = 1;

    pub fn clear_active_only(&mut self) {
        self.active_only = false;
    }

    // Param is passed by value, moved
    pub fn set_active_only(&mut self, v: bool) {
        self.active_only = v;
    }

    pub fn get_active_only(&self) -> bool {
        self.active_only
    }

    // bool inactive_only = 2;

    pub fn clear_inactive_only(&mut self) {
        self.inactive_only = false;
    }

    // Param is passed by value, moved
    pub fn set_inactive_only(&mut self, v: bool) {
        self.inactive_only = v;
    }

    pub fn get_inactive_only(&self) -> bool {
        self.inactive_only
    }

    // bool public_only = 3;

    pub fn clear_public_only(&mut self) {
        self.public_only = false;
    }

    // Param is passed by value, moved
    pub fn set_public_only(&mut self, v: bool) {
        self.public_only = v;
    }

    pub fn get_public_only(&self) -> bool {
        self.public_only
    }

    // bool private_only = 4;

    pub fn clear_private_only(&mut self) {
        self.private_only = false;
    }

    // Param is passed by value, moved
    pub fn set_private_only(&mut self, v: bool) {
        self.private_only = v;
    }

    pub fn get_private_only(&self) -> bool {
        self.private_only
    }
}

impl ::protobuf::Message for ListChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active_only = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inactive_only = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.public_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active_only != false {
            my_size += 2;
        }
        if self.inactive_only != false {
            my_size += 2;
        }
        if self.public_only != false {
            my_size += 2;
        }
        if self.private_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.active_only != false {
            os.write_bool(1, self.active_only)?;
        }
        if self.inactive_only != false {
            os.write_bool(2, self.inactive_only)?;
        }
        if self.public_only != false {
            os.write_bool(3, self.public_only)?;
        }
        if self.private_only != false {
            os.write_bool(4, self.private_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsRequest {
        ListChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active_only",
                    |m: &ListChannelsRequest| { &m.active_only },
                    |m: &mut ListChannelsRequest| { &mut m.active_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inactive_only",
                    |m: &ListChannelsRequest| { &m.inactive_only },
                    |m: &mut ListChannelsRequest| { &mut m.inactive_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "public_only",
                    |m: &ListChannelsRequest| { &m.public_only },
                    |m: &mut ListChannelsRequest| { &mut m.public_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private_only",
                    |m: &ListChannelsRequest| { &m.private_only },
                    |m: &mut ListChannelsRequest| { &mut m.private_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListChannelsRequest>(
                    "ListChannelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListChannelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListChannelsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListChannelsRequest,
        };
        unsafe {
            instance.get(ListChannelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListChannelsRequest {
    fn clear(&mut self) {
        self.clear_active_only();
        self.clear_inactive_only();
        self.clear_public_only();
        self.clear_private_only();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelsResponse {
    // message fields
    pub channels: ::protobuf::RepeatedField<Channel>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListChannelsResponse {
    pub fn new() -> ListChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Channel channels = 11;

    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_channels(&self) -> &[Channel] {
        &self.channels
    }
}

impl ::protobuf::Message for ListChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsResponse {
        ListChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                    "channels",
                    |m: &ListChannelsResponse| { &m.channels },
                    |m: &mut ListChannelsResponse| { &mut m.channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListChannelsResponse>(
                    "ListChannelsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListChannelsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListChannelsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListChannelsResponse,
        };
        unsafe {
            instance.get(ListChannelsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListChannelsResponse {
    fn clear(&mut self) {
        self.clear_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelCloseSummary {
    // message fields
    pub channel_point: ::std::string::String,
    pub chan_id: u64,
    pub chain_hash: ::std::string::String,
    pub closing_tx_hash: ::std::string::String,
    pub remote_pubkey: ::std::string::String,
    pub capacity: i64,
    pub close_height: u32,
    pub settled_balance: i64,
    pub time_locked_balance: i64,
    pub close_type: ChannelCloseSummary_ClosureType,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelCloseSummary {
    pub fn new() -> ChannelCloseSummary {
        ::std::default::Default::default()
    }

    // string channel_point = 1;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }

    // uint64 chan_id = 2;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }

    // string chain_hash = 3;

    pub fn clear_chain_hash(&mut self) {
        self.chain_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hash(&mut self, v: ::std::string::String) {
        self.chain_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hash(&mut self) -> &mut ::std::string::String {
        &mut self.chain_hash
    }

    // Take field
    pub fn take_chain_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_hash, ::std::string::String::new())
    }

    pub fn get_chain_hash(&self) -> &str {
        &self.chain_hash
    }

    // string closing_tx_hash = 4;

    pub fn clear_closing_tx_hash(&mut self) {
        self.closing_tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_tx_hash(&mut self, v: ::std::string::String) {
        self.closing_tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.closing_tx_hash
    }

    // Take field
    pub fn take_closing_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_tx_hash, ::std::string::String::new())
    }

    pub fn get_closing_tx_hash(&self) -> &str {
        &self.closing_tx_hash
    }

    // string remote_pubkey = 5;

    pub fn clear_remote_pubkey(&mut self) {
        self.remote_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pubkey(&mut self, v: ::std::string::String) {
        self.remote_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pubkey
    }

    // Take field
    pub fn take_remote_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pubkey, ::std::string::String::new())
    }

    pub fn get_remote_pubkey(&self) -> &str {
        &self.remote_pubkey
    }

    // int64 capacity = 6;

    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }

    // uint32 close_height = 7;

    pub fn clear_close_height(&mut self) {
        self.close_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_close_height(&mut self, v: u32) {
        self.close_height = v;
    }

    pub fn get_close_height(&self) -> u32 {
        self.close_height
    }

    // int64 settled_balance = 8;

    pub fn clear_settled_balance(&mut self) {
        self.settled_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_settled_balance(&mut self, v: i64) {
        self.settled_balance = v;
    }

    pub fn get_settled_balance(&self) -> i64 {
        self.settled_balance
    }

    // int64 time_locked_balance = 9;

    pub fn clear_time_locked_balance(&mut self) {
        self.time_locked_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_locked_balance(&mut self, v: i64) {
        self.time_locked_balance = v;
    }

    pub fn get_time_locked_balance(&self) -> i64 {
        self.time_locked_balance
    }

    // .lnrpc.ChannelCloseSummary.ClosureType close_type = 10;

    pub fn clear_close_type(&mut self) {
        self.close_type = ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_close_type(&mut self, v: ChannelCloseSummary_ClosureType) {
        self.close_type = v;
    }

    pub fn get_close_type(&self) -> ChannelCloseSummary_ClosureType {
        self.close_type
    }
}

impl ::protobuf::Message for ChannelCloseSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_tx_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pubkey)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.close_height = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settled_balance = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_locked_balance = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.close_type, 10, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_point);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chain_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.chain_hash);
        }
        if !self.closing_tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.closing_tx_hash);
        }
        if !self.remote_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.remote_pubkey);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.close_height != 0 {
            my_size += ::protobuf::rt::value_size(7, self.close_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settled_balance != 0 {
            my_size += ::protobuf::rt::value_size(8, self.settled_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_locked_balance != 0 {
            my_size += ::protobuf::rt::value_size(9, self.time_locked_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.close_type != ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE {
            my_size += ::protobuf::rt::enum_size(10, self.close_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_point.is_empty() {
            os.write_string(1, &self.channel_point)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(2, self.chan_id)?;
        }
        if !self.chain_hash.is_empty() {
            os.write_string(3, &self.chain_hash)?;
        }
        if !self.closing_tx_hash.is_empty() {
            os.write_string(4, &self.closing_tx_hash)?;
        }
        if !self.remote_pubkey.is_empty() {
            os.write_string(5, &self.remote_pubkey)?;
        }
        if self.capacity != 0 {
            os.write_int64(6, self.capacity)?;
        }
        if self.close_height != 0 {
            os.write_uint32(7, self.close_height)?;
        }
        if self.settled_balance != 0 {
            os.write_int64(8, self.settled_balance)?;
        }
        if self.time_locked_balance != 0 {
            os.write_int64(9, self.time_locked_balance)?;
        }
        if self.close_type != ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE {
            os.write_enum(10, self.close_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCloseSummary {
        ChannelCloseSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &ChannelCloseSummary| { &m.channel_point },
                    |m: &mut ChannelCloseSummary| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ChannelCloseSummary| { &m.chan_id },
                    |m: &mut ChannelCloseSummary| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chain_hash",
                    |m: &ChannelCloseSummary| { &m.chain_hash },
                    |m: &mut ChannelCloseSummary| { &mut m.chain_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_tx_hash",
                    |m: &ChannelCloseSummary| { &m.closing_tx_hash },
                    |m: &mut ChannelCloseSummary| { &mut m.closing_tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_pubkey",
                    |m: &ChannelCloseSummary| { &m.remote_pubkey },
                    |m: &mut ChannelCloseSummary| { &mut m.remote_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ChannelCloseSummary| { &m.capacity },
                    |m: &mut ChannelCloseSummary| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "close_height",
                    |m: &ChannelCloseSummary| { &m.close_height },
                    |m: &mut ChannelCloseSummary| { &mut m.close_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "settled_balance",
                    |m: &ChannelCloseSummary| { &m.settled_balance },
                    |m: &mut ChannelCloseSummary| { &mut m.settled_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "time_locked_balance",
                    |m: &ChannelCloseSummary| { &m.time_locked_balance },
                    |m: &mut ChannelCloseSummary| { &mut m.time_locked_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelCloseSummary_ClosureType>>(
                    "close_type",
                    |m: &ChannelCloseSummary| { &m.close_type },
                    |m: &mut ChannelCloseSummary| { &mut m.close_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelCloseSummary>(
                    "ChannelCloseSummary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelCloseSummary {
        static mut instance: ::protobuf::lazy::Lazy<ChannelCloseSummary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelCloseSummary,
        };
        unsafe {
            instance.get(ChannelCloseSummary::new)
        }
    }
}

impl ::protobuf::Clear for ChannelCloseSummary {
    fn clear(&mut self) {
        self.clear_channel_point();
        self.clear_chan_id();
        self.clear_chain_hash();
        self.clear_closing_tx_hash();
        self.clear_remote_pubkey();
        self.clear_capacity();
        self.clear_close_height();
        self.clear_settled_balance();
        self.clear_time_locked_balance();
        self.clear_close_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCloseSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChannelCloseSummary_ClosureType {
    COOPERATIVE_CLOSE = 0,
    LOCAL_FORCE_CLOSE = 1,
    REMOTE_FORCE_CLOSE = 2,
    BREACH_CLOSE = 3,
    FUNDING_CANCELED = 4,
    ABANDONED = 5,
}

impl ::protobuf::ProtobufEnum for ChannelCloseSummary_ClosureType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelCloseSummary_ClosureType> {
        match value {
            0 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE),
            1 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::LOCAL_FORCE_CLOSE),
            2 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::REMOTE_FORCE_CLOSE),
            3 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::BREACH_CLOSE),
            4 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::FUNDING_CANCELED),
            5 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::ABANDONED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelCloseSummary_ClosureType] = &[
            ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE,
            ChannelCloseSummary_ClosureType::LOCAL_FORCE_CLOSE,
            ChannelCloseSummary_ClosureType::REMOTE_FORCE_CLOSE,
            ChannelCloseSummary_ClosureType::BREACH_CLOSE,
            ChannelCloseSummary_ClosureType::FUNDING_CANCELED,
            ChannelCloseSummary_ClosureType::ABANDONED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChannelCloseSummary_ClosureType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChannelCloseSummary_ClosureType {
}

impl ::std::default::Default for ChannelCloseSummary_ClosureType {
    fn default() -> Self {
        ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseSummary_ClosureType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClosedChannelsRequest {
    // message fields
    pub cooperative: bool,
    pub local_force: bool,
    pub remote_force: bool,
    pub breach: bool,
    pub funding_canceled: bool,
    pub abandoned: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ClosedChannelsRequest {
    pub fn new() -> ClosedChannelsRequest {
        ::std::default::Default::default()
    }

    // bool cooperative = 1;

    pub fn clear_cooperative(&mut self) {
        self.cooperative = false;
    }

    // Param is passed by value, moved
    pub fn set_cooperative(&mut self, v: bool) {
        self.cooperative = v;
    }

    pub fn get_cooperative(&self) -> bool {
        self.cooperative
    }

    // bool local_force = 2;

    pub fn clear_local_force(&mut self) {
        self.local_force = false;
    }

    // Param is passed by value, moved
    pub fn set_local_force(&mut self, v: bool) {
        self.local_force = v;
    }

    pub fn get_local_force(&self) -> bool {
        self.local_force
    }

    // bool remote_force = 3;

    pub fn clear_remote_force(&mut self) {
        self.remote_force = false;
    }

    // Param is passed by value, moved
    pub fn set_remote_force(&mut self, v: bool) {
        self.remote_force = v;
    }

    pub fn get_remote_force(&self) -> bool {
        self.remote_force
    }

    // bool breach = 4;

    pub fn clear_breach(&mut self) {
        self.breach = false;
    }

    // Param is passed by value, moved
    pub fn set_breach(&mut self, v: bool) {
        self.breach = v;
    }

    pub fn get_breach(&self) -> bool {
        self.breach
    }

    // bool funding_canceled = 5;

    pub fn clear_funding_canceled(&mut self) {
        self.funding_canceled = false;
    }

    // Param is passed by value, moved
    pub fn set_funding_canceled(&mut self, v: bool) {
        self.funding_canceled = v;
    }

    pub fn get_funding_canceled(&self) -> bool {
        self.funding_canceled
    }

    // bool abandoned = 6;

    pub fn clear_abandoned(&mut self) {
        self.abandoned = false;
    }

    // Param is passed by value, moved
    pub fn set_abandoned(&mut self, v: bool) {
        self.abandoned = v;
    }

    pub fn get_abandoned(&self) -> bool {
        self.abandoned
    }
}

impl ::protobuf::Message for ClosedChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cooperative = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local_force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remote_force = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.breach = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.funding_canceled = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.abandoned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cooperative != false {
            my_size += 2;
        }
        if self.local_force != false {
            my_size += 2;
        }
        if self.remote_force != false {
            my_size += 2;
        }
        if self.breach != false {
            my_size += 2;
        }
        if self.funding_canceled != false {
            my_size += 2;
        }
        if self.abandoned != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.cooperative != false {
            os.write_bool(1, self.cooperative)?;
        }
        if self.local_force != false {
            os.write_bool(2, self.local_force)?;
        }
        if self.remote_force != false {
            os.write_bool(3, self.remote_force)?;
        }
        if self.breach != false {
            os.write_bool(4, self.breach)?;
        }
        if self.funding_canceled != false {
            os.write_bool(5, self.funding_canceled)?;
        }
        if self.abandoned != false {
            os.write_bool(6, self.abandoned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelsRequest {
        ClosedChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cooperative",
                    |m: &ClosedChannelsRequest| { &m.cooperative },
                    |m: &mut ClosedChannelsRequest| { &mut m.cooperative },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local_force",
                    |m: &ClosedChannelsRequest| { &m.local_force },
                    |m: &mut ClosedChannelsRequest| { &mut m.local_force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remote_force",
                    |m: &ClosedChannelsRequest| { &m.remote_force },
                    |m: &mut ClosedChannelsRequest| { &mut m.remote_force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "breach",
                    |m: &ClosedChannelsRequest| { &m.breach },
                    |m: &mut ClosedChannelsRequest| { &mut m.breach },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "funding_canceled",
                    |m: &ClosedChannelsRequest| { &m.funding_canceled },
                    |m: &mut ClosedChannelsRequest| { &mut m.funding_canceled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "abandoned",
                    |m: &ClosedChannelsRequest| { &m.abandoned },
                    |m: &mut ClosedChannelsRequest| { &mut m.abandoned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClosedChannelsRequest>(
                    "ClosedChannelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClosedChannelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ClosedChannelsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClosedChannelsRequest,
        };
        unsafe {
            instance.get(ClosedChannelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ClosedChannelsRequest {
    fn clear(&mut self) {
        self.clear_cooperative();
        self.clear_local_force();
        self.clear_remote_force();
        self.clear_breach();
        self.clear_funding_canceled();
        self.clear_abandoned();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClosedChannelsResponse {
    // message fields
    pub channels: ::protobuf::RepeatedField<ChannelCloseSummary>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ClosedChannelsResponse {
    pub fn new() -> ClosedChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelCloseSummary channels = 1;

    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<ChannelCloseSummary>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<ChannelCloseSummary> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<ChannelCloseSummary> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_channels(&self) -> &[ChannelCloseSummary] {
        &self.channels
    }
}

impl ::protobuf::Message for ClosedChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelsResponse {
        ClosedChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelCloseSummary>>(
                    "channels",
                    |m: &ClosedChannelsResponse| { &m.channels },
                    |m: &mut ClosedChannelsResponse| { &mut m.channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClosedChannelsResponse>(
                    "ClosedChannelsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClosedChannelsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ClosedChannelsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClosedChannelsResponse,
        };
        unsafe {
            instance.get(ClosedChannelsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ClosedChannelsResponse {
    fn clear(&mut self) {
        self.clear_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peer {
    // message fields
    pub pub_key: ::std::string::String,
    pub address: ::std::string::String,
    pub bytes_sent: u64,
    pub bytes_recv: u64,
    pub sat_sent: i64,
    pub sat_recv: i64,
    pub inbound: bool,
    pub ping_time: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // string pub_key = 1;

    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }

    // string address = 3;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        &self.address
    }

    // uint64 bytes_sent = 4;

    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: u64) {
        self.bytes_sent = v;
    }

    pub fn get_bytes_sent(&self) -> u64 {
        self.bytes_sent
    }

    // uint64 bytes_recv = 5;

    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: u64) {
        self.bytes_recv = v;
    }

    pub fn get_bytes_recv(&self) -> u64 {
        self.bytes_recv
    }

    // int64 sat_sent = 6;

    pub fn clear_sat_sent(&mut self) {
        self.sat_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_sent(&mut self, v: i64) {
        self.sat_sent = v;
    }

    pub fn get_sat_sent(&self) -> i64 {
        self.sat_sent
    }

    // int64 sat_recv = 7;

    pub fn clear_sat_recv(&mut self) {
        self.sat_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_recv(&mut self, v: i64) {
        self.sat_recv = v;
    }

    pub fn get_sat_recv(&self) -> i64 {
        self.sat_recv
    }

    // bool inbound = 8;

    pub fn clear_inbound(&mut self) {
        self.inbound = false;
    }

    // Param is passed by value, moved
    pub fn set_inbound(&mut self, v: bool) {
        self.inbound = v;
    }

    pub fn get_inbound(&self) -> bool {
        self.inbound
    }

    // int64 ping_time = 9;

    pub fn clear_ping_time(&mut self) {
        self.ping_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: i64) {
        self.ping_time = v;
    }

    pub fn get_ping_time(&self) -> i64 {
        self.ping_time
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_sent = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_recv = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_sent = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_recv = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inbound = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ping_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.bytes_sent != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bytes_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes_recv != 0 {
            my_size += ::protobuf::rt::value_size(5, self.bytes_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_sent != 0 {
            my_size += ::protobuf::rt::value_size(6, self.sat_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_recv != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sat_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inbound != false {
            my_size += 2;
        }
        if self.ping_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.ping_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.bytes_sent != 0 {
            os.write_uint64(4, self.bytes_sent)?;
        }
        if self.bytes_recv != 0 {
            os.write_uint64(5, self.bytes_recv)?;
        }
        if self.sat_sent != 0 {
            os.write_int64(6, self.sat_sent)?;
        }
        if self.sat_recv != 0 {
            os.write_int64(7, self.sat_recv)?;
        }
        if self.inbound != false {
            os.write_bool(8, self.inbound)?;
        }
        if self.ping_time != 0 {
            os.write_int64(9, self.ping_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &Peer| { &m.pub_key },
                    |m: &mut Peer| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &Peer| { &m.address },
                    |m: &mut Peer| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_sent",
                    |m: &Peer| { &m.bytes_sent },
                    |m: &mut Peer| { &mut m.bytes_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_recv",
                    |m: &Peer| { &m.bytes_recv },
                    |m: &mut Peer| { &mut m.bytes_recv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_sent",
                    |m: &Peer| { &m.sat_sent },
                    |m: &mut Peer| { &mut m.sat_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_recv",
                    |m: &Peer| { &m.sat_recv },
                    |m: &mut Peer| { &mut m.sat_recv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inbound",
                    |m: &Peer| { &m.inbound },
                    |m: &mut Peer| { &mut m.inbound },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ping_time",
                    |m: &Peer| { &m.ping_time },
                    |m: &mut Peer| { &mut m.ping_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Peer>(
                    "Peer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Peer {
        static mut instance: ::protobuf::lazy::Lazy<Peer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Peer,
        };
        unsafe {
            instance.get(Peer::new)
        }
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.clear_pub_key();
        self.clear_address();
        self.clear_bytes_sent();
        self.clear_bytes_recv();
        self.clear_sat_sent();
        self.clear_sat_recv();
        self.clear_inbound();
        self.clear_ping_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPeersRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListPeersRequest {
    pub fn new() -> ListPeersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListPeersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeersRequest {
        ListPeersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ListPeersRequest>(
                    "ListPeersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPeersRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPeersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPeersRequest,
        };
        unsafe {
            instance.get(ListPeersRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPeersRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPeersResponse {
    // message fields
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListPeersResponse {
    pub fn new() -> ListPeersResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Peer peers = 1;

    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }

    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
}

impl ::protobuf::Message for ListPeersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeersResponse {
        ListPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                    "peers",
                    |m: &ListPeersResponse| { &m.peers },
                    |m: &mut ListPeersResponse| { &mut m.peers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPeersResponse>(
                    "ListPeersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPeersResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPeersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPeersResponse,
        };
        unsafe {
            instance.get(ListPeersResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPeersResponse {
    fn clear(&mut self) {
        self.clear_peers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetInfoRequest {
    pub fn new() -> GetInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoRequest {
        GetInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoRequest>(
                    "GetInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoRequest,
        };
        unsafe {
            instance.get(GetInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoResponse {
    // message fields
    pub identity_pubkey: ::std::string::String,
    pub alias: ::std::string::String,
    pub num_pending_channels: u32,
    pub num_active_channels: u32,
    pub num_peers: u32,
    pub block_height: u32,
    pub block_hash: ::std::string::String,
    pub synced_to_chain: bool,
    pub testnet: bool,
    pub chains: ::protobuf::RepeatedField<::std::string::String>,
    pub uris: ::protobuf::RepeatedField<::std::string::String>,
    pub best_header_timestamp: i64,
    pub version: ::std::string::String,
    pub num_inactive_channels: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetInfoResponse {
    pub fn new() -> GetInfoResponse {
        ::std::default::Default::default()
    }

    // string identity_pubkey = 1;

    pub fn clear_identity_pubkey(&mut self) {
        self.identity_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_pubkey(&mut self, v: ::std::string::String) {
        self.identity_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.identity_pubkey
    }

    // Take field
    pub fn take_identity_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_pubkey, ::std::string::String::new())
    }

    pub fn get_identity_pubkey(&self) -> &str {
        &self.identity_pubkey
    }

    // string alias = 2;

    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    pub fn get_alias(&self) -> &str {
        &self.alias
    }

    // uint32 num_pending_channels = 3;

    pub fn clear_num_pending_channels(&mut self) {
        self.num_pending_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pending_channels(&mut self, v: u32) {
        self.num_pending_channels = v;
    }

    pub fn get_num_pending_channels(&self) -> u32 {
        self.num_pending_channels
    }

    // uint32 num_active_channels = 4;

    pub fn clear_num_active_channels(&mut self) {
        self.num_active_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_active_channels(&mut self, v: u32) {
        self.num_active_channels = v;
    }

    pub fn get_num_active_channels(&self) -> u32 {
        self.num_active_channels
    }

    // uint32 num_peers = 5;

    pub fn clear_num_peers(&mut self) {
        self.num_peers = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_peers(&mut self, v: u32) {
        self.num_peers = v;
    }

    pub fn get_num_peers(&self) -> u32 {
        self.num_peers
    }

    // uint32 block_height = 6;

    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u32) {
        self.block_height = v;
    }

    pub fn get_block_height(&self) -> u32 {
        self.block_height
    }

    // string block_hash = 8;

    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }

    // bool synced_to_chain = 9;

    pub fn clear_synced_to_chain(&mut self) {
        self.synced_to_chain = false;
    }

    // Param is passed by value, moved
    pub fn set_synced_to_chain(&mut self, v: bool) {
        self.synced_to_chain = v;
    }

    pub fn get_synced_to_chain(&self) -> bool {
        self.synced_to_chain
    }

    // bool testnet = 10;

    pub fn clear_testnet(&mut self) {
        self.testnet = false;
    }

    // Param is passed by value, moved
    pub fn set_testnet(&mut self, v: bool) {
        self.testnet = v;
    }

    pub fn get_testnet(&self) -> bool {
        self.testnet
    }

    // repeated string chains = 11;

    pub fn clear_chains(&mut self) {
        self.chains.clear();
    }

    // Param is passed by value, moved
    pub fn set_chains(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.chains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chains(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.chains
    }

    // Take field
    pub fn take_chains(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.chains, ::protobuf::RepeatedField::new())
    }

    pub fn get_chains(&self) -> &[::std::string::String] {
        &self.chains
    }

    // repeated string uris = 12;

    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    pub fn get_uris(&self) -> &[::std::string::String] {
        &self.uris
    }

    // int64 best_header_timestamp = 13;

    pub fn clear_best_header_timestamp(&mut self) {
        self.best_header_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_best_header_timestamp(&mut self, v: i64) {
        self.best_header_timestamp = v;
    }

    pub fn get_best_header_timestamp(&self) -> i64 {
        self.best_header_timestamp
    }

    // string version = 14;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        &self.version
    }

    // uint32 num_inactive_channels = 15;

    pub fn clear_num_inactive_channels(&mut self) {
        self.num_inactive_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_inactive_channels(&mut self, v: u32) {
        self.num_inactive_channels = v;
    }

    pub fn get_num_inactive_channels(&self) -> u32 {
        self.num_inactive_channels
    }
}

impl ::protobuf::Message for GetInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_pending_channels = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_active_channels = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_peers = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_height = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.synced_to_chain = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.testnet = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.chains)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uris)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.best_header_timestamp = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_inactive_channels = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_pubkey);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.alias);
        }
        if self.num_pending_channels != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_pending_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_active_channels != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_active_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_peers != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_peers, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(6, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.block_hash);
        }
        if self.synced_to_chain != false {
            my_size += 2;
        }
        if self.testnet != false {
            my_size += 2;
        }
        for value in &self.chains {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in &self.uris {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        if self.best_header_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(13, self.best_header_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.version);
        }
        if self.num_inactive_channels != 0 {
            my_size += ::protobuf::rt::value_size(15, self.num_inactive_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_pubkey.is_empty() {
            os.write_string(1, &self.identity_pubkey)?;
        }
        if !self.alias.is_empty() {
            os.write_string(2, &self.alias)?;
        }
        if self.num_pending_channels != 0 {
            os.write_uint32(3, self.num_pending_channels)?;
        }
        if self.num_active_channels != 0 {
            os.write_uint32(4, self.num_active_channels)?;
        }
        if self.num_peers != 0 {
            os.write_uint32(5, self.num_peers)?;
        }
        if self.block_height != 0 {
            os.write_uint32(6, self.block_height)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(8, &self.block_hash)?;
        }
        if self.synced_to_chain != false {
            os.write_bool(9, self.synced_to_chain)?;
        }
        if self.testnet != false {
            os.write_bool(10, self.testnet)?;
        }
        for v in &self.chains {
            os.write_string(11, &v)?;
        };
        for v in &self.uris {
            os.write_string(12, &v)?;
        };
        if self.best_header_timestamp != 0 {
            os.write_int64(13, self.best_header_timestamp)?;
        }
        if !self.version.is_empty() {
            os.write_string(14, &self.version)?;
        }
        if self.num_inactive_channels != 0 {
            os.write_uint32(15, self.num_inactive_channels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoResponse {
        GetInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity_pubkey",
                    |m: &GetInfoResponse| { &m.identity_pubkey },
                    |m: &mut GetInfoResponse| { &mut m.identity_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &GetInfoResponse| { &m.alias },
                    |m: &mut GetInfoResponse| { &mut m.alias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_pending_channels",
                    |m: &GetInfoResponse| { &m.num_pending_channels },
                    |m: &mut GetInfoResponse| { &mut m.num_pending_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_active_channels",
                    |m: &GetInfoResponse| { &m.num_active_channels },
                    |m: &mut GetInfoResponse| { &mut m.num_active_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_peers",
                    |m: &GetInfoResponse| { &m.num_peers },
                    |m: &mut GetInfoResponse| { &mut m.num_peers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "block_height",
                    |m: &GetInfoResponse| { &m.block_height },
                    |m: &mut GetInfoResponse| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block_hash",
                    |m: &GetInfoResponse| { &m.block_hash },
                    |m: &mut GetInfoResponse| { &mut m.block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "synced_to_chain",
                    |m: &GetInfoResponse| { &m.synced_to_chain },
                    |m: &mut GetInfoResponse| { &mut m.synced_to_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "testnet",
                    |m: &GetInfoResponse| { &m.testnet },
                    |m: &mut GetInfoResponse| { &mut m.testnet },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chains",
                    |m: &GetInfoResponse| { &m.chains },
                    |m: &mut GetInfoResponse| { &mut m.chains },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uris",
                    |m: &GetInfoResponse| { &m.uris },
                    |m: &mut GetInfoResponse| { &mut m.uris },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "best_header_timestamp",
                    |m: &GetInfoResponse| { &m.best_header_timestamp },
                    |m: &mut GetInfoResponse| { &mut m.best_header_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &GetInfoResponse| { &m.version },
                    |m: &mut GetInfoResponse| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_inactive_channels",
                    |m: &GetInfoResponse| { &m.num_inactive_channels },
                    |m: &mut GetInfoResponse| { &mut m.num_inactive_channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoResponse>(
                    "GetInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoResponse,
        };
        unsafe {
            instance.get(GetInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoResponse {
    fn clear(&mut self) {
        self.clear_identity_pubkey();
        self.clear_alias();
        self.clear_num_pending_channels();
        self.clear_num_active_channels();
        self.clear_num_peers();
        self.clear_block_height();
        self.clear_block_hash();
        self.clear_synced_to_chain();
        self.clear_testnet();
        self.clear_chains();
        self.clear_uris();
        self.clear_best_header_timestamp();
        self.clear_version();
        self.clear_num_inactive_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfirmationUpdate {
    // message fields
    pub block_sha: ::std::vec::Vec<u8>,
    pub block_height: i32,
    pub num_confs_left: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConfirmationUpdate {
    pub fn new() -> ConfirmationUpdate {
        ::std::default::Default::default()
    }

    // bytes block_sha = 1;

    pub fn clear_block_sha(&mut self) {
        self.block_sha.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_sha = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_sha
    }

    // Take field
    pub fn take_block_sha(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_sha, ::std::vec::Vec::new())
    }

    pub fn get_block_sha(&self) -> &[u8] {
        &self.block_sha
    }

    // int32 block_height = 2;

    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }

    // uint32 num_confs_left = 3;

    pub fn clear_num_confs_left(&mut self) {
        self.num_confs_left = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_confs_left(&mut self, v: u32) {
        self.num_confs_left = v;
    }

    pub fn get_num_confs_left(&self) -> u32 {
        self.num_confs_left
    }
}

impl ::protobuf::Message for ConfirmationUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_sha)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_confs_left = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.block_sha.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block_sha);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_confs_left != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_confs_left, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.block_sha.is_empty() {
            os.write_bytes(1, &self.block_sha)?;
        }
        if self.block_height != 0 {
            os.write_int32(2, self.block_height)?;
        }
        if self.num_confs_left != 0 {
            os.write_uint32(3, self.num_confs_left)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfirmationUpdate {
        ConfirmationUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "block_sha",
                    |m: &ConfirmationUpdate| { &m.block_sha },
                    |m: &mut ConfirmationUpdate| { &mut m.block_sha },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "block_height",
                    |m: &ConfirmationUpdate| { &m.block_height },
                    |m: &mut ConfirmationUpdate| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_confs_left",
                    |m: &ConfirmationUpdate| { &m.num_confs_left },
                    |m: &mut ConfirmationUpdate| { &mut m.num_confs_left },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfirmationUpdate>(
                    "ConfirmationUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConfirmationUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ConfirmationUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfirmationUpdate,
        };
        unsafe {
            instance.get(ConfirmationUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ConfirmationUpdate {
    fn clear(&mut self) {
        self.clear_block_sha();
        self.clear_block_height();
        self.clear_num_confs_left();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfirmationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfirmationUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelOpenUpdate {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelOpenUpdate {
    pub fn new() -> ChannelOpenUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
}

impl ::protobuf::Message for ChannelOpenUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelOpenUpdate {
        ChannelOpenUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &ChannelOpenUpdate| { &m.channel_point },
                    |m: &mut ChannelOpenUpdate| { &mut m.channel_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelOpenUpdate>(
                    "ChannelOpenUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelOpenUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelOpenUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelOpenUpdate,
        };
        unsafe {
            instance.get(ChannelOpenUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelOpenUpdate {
    fn clear(&mut self) {
        self.clear_channel_point();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelOpenUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelOpenUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelCloseUpdate {
    // message fields
    pub closing_txid: ::std::vec::Vec<u8>,
    pub success: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelCloseUpdate {
    pub fn new() -> ChannelCloseUpdate {
        ::std::default::Default::default()
    }

    // bytes closing_txid = 1;

    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.closing_txid, ::std::vec::Vec::new())
    }

    pub fn get_closing_txid(&self) -> &[u8] {
        &self.closing_txid
    }

    // bool success = 2;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }
}

impl ::protobuf::Message for ChannelCloseUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.closing_txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.closing_txid);
        }
        if self.success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.closing_txid.is_empty() {
            os.write_bytes(1, &self.closing_txid)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCloseUpdate {
        ChannelCloseUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "closing_txid",
                    |m: &ChannelCloseUpdate| { &m.closing_txid },
                    |m: &mut ChannelCloseUpdate| { &mut m.closing_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &ChannelCloseUpdate| { &m.success },
                    |m: &mut ChannelCloseUpdate| { &mut m.success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelCloseUpdate>(
                    "ChannelCloseUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelCloseUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelCloseUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelCloseUpdate,
        };
        unsafe {
            instance.get(ChannelCloseUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelCloseUpdate {
    fn clear(&mut self) {
        self.clear_closing_txid();
        self.clear_success();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCloseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseChannelRequest {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub force: bool,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CloseChannelRequest {
    pub fn new() -> CloseChannelRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }

    // bool force = 2;

    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    pub fn get_force(&self) -> bool {
        self.force
    }

    // int32 target_conf = 3;

    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }

    // int64 sat_per_byte = 4;

    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
}

impl ::protobuf::Message for CloseChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.force != false {
            my_size += 2;
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(4, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.force != false {
            os.write_bool(2, self.force)?;
        }
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(4, self.sat_per_byte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseChannelRequest {
        CloseChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &CloseChannelRequest| { &m.channel_point },
                    |m: &mut CloseChannelRequest| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force",
                    |m: &CloseChannelRequest| { &m.force },
                    |m: &mut CloseChannelRequest| { &mut m.force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &CloseChannelRequest| { &m.target_conf },
                    |m: &mut CloseChannelRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &CloseChannelRequest| { &m.sat_per_byte },
                    |m: &mut CloseChannelRequest| { &mut m.sat_per_byte },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseChannelRequest>(
                    "CloseChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<CloseChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseChannelRequest,
        };
        unsafe {
            instance.get(CloseChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for CloseChannelRequest {
    fn clear(&mut self) {
        self.clear_channel_point();
        self.clear_force();
        self.clear_target_conf();
        self.clear_sat_per_byte();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseStatusUpdate {
    // message oneof groups
    pub update: ::std::option::Option<CloseStatusUpdate_oneof_update>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum CloseStatusUpdate_oneof_update {
    close_pending(PendingUpdate),
    confirmation(ConfirmationUpdate),
    chan_close(ChannelCloseUpdate),
}

impl CloseStatusUpdate {
    pub fn new() -> CloseStatusUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingUpdate close_pending = 1;

    pub fn clear_close_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_close_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_pending(&mut self) -> PendingUpdate {
        if self.has_close_pending() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    pub fn get_close_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) => v,
            _ => PendingUpdate::default_instance(),
        }
    }

    // .lnrpc.ConfirmationUpdate confirmation = 2;

    pub fn clear_confirmation(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_confirmation(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_confirmation(&mut self, v: ConfirmationUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_confirmation(&mut self) -> &mut ConfirmationUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(ConfirmationUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_confirmation(&mut self) -> ConfirmationUpdate {
        if self.has_confirmation() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfirmationUpdate::new()
        }
    }

    pub fn get_confirmation(&self) -> &ConfirmationUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(ref v)) => v,
            _ => ConfirmationUpdate::default_instance(),
        }
    }

    // .lnrpc.ChannelCloseUpdate chan_close = 3;

    pub fn clear_chan_close(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_close(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_close(&mut self, v: ChannelCloseUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_close(&mut self) -> &mut ChannelCloseUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ChannelCloseUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_close(&mut self) -> ChannelCloseUpdate {
        if self.has_chan_close() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelCloseUpdate::new()
        }
    }

    pub fn get_chan_close(&self) -> &ChannelCloseUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) => v,
            _ => ChannelCloseUpdate::default_instance(),
        }
    }
}

impl ::protobuf::Message for CloseStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CloseStatusUpdate_oneof_update::confirmation(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::confirmation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CloseStatusUpdate_oneof_update::confirmation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CloseStatusUpdate_oneof_update::confirmation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseStatusUpdate {
        CloseStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                    "close_pending",
                    CloseStatusUpdate::has_close_pending,
                    CloseStatusUpdate::get_close_pending,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConfirmationUpdate>(
                    "confirmation",
                    CloseStatusUpdate::has_confirmation,
                    CloseStatusUpdate::get_confirmation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelCloseUpdate>(
                    "chan_close",
                    CloseStatusUpdate::has_chan_close,
                    CloseStatusUpdate::get_chan_close,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseStatusUpdate>(
                    "CloseStatusUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseStatusUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CloseStatusUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseStatusUpdate,
        };
        unsafe {
            instance.get(CloseStatusUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CloseStatusUpdate {
    fn clear(&mut self) {
        self.clear_close_pending();
        self.clear_confirmation();
        self.clear_chan_close();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingUpdate {
    // message fields
    pub txid: ::std::vec::Vec<u8>,
    pub output_index: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingUpdate {
    pub fn new() -> PendingUpdate {
        ::std::default::Default::default()
    }

    // bytes txid = 1;

    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }

    // uint32 output_index = 2;

    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }

    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
}

impl ::protobuf::Message for PendingUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.output_index != 0 {
            os.write_uint32(2, self.output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingUpdate {
        PendingUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &PendingUpdate| { &m.txid },
                    |m: &mut PendingUpdate| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &PendingUpdate| { &m.output_index },
                    |m: &mut PendingUpdate| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingUpdate>(
                    "PendingUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingUpdate {
        static mut instance: ::protobuf::lazy::Lazy<PendingUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingUpdate,
        };
        unsafe {
            instance.get(PendingUpdate::new)
        }
    }
}

impl ::protobuf::Clear for PendingUpdate {
    fn clear(&mut self) {
        self.clear_txid();
        self.clear_output_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenChannelRequest {
    // message fields
    pub node_pubkey: ::std::vec::Vec<u8>,
    pub node_pubkey_string: ::std::string::String,
    pub local_funding_amount: i64,
    pub push_sat: i64,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    pub private: bool,
    pub min_htlc_msat: i64,
    pub remote_csv_delay: u32,
    pub min_confs: i32,
    pub spend_unconfirmed: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OpenChannelRequest {
    pub fn new() -> OpenChannelRequest {
        ::std::default::Default::default()
    }

    // bytes node_pubkey = 2;

    pub fn clear_node_pubkey(&mut self) {
        self.node_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_pubkey
    }

    // Take field
    pub fn take_node_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_pubkey, ::std::vec::Vec::new())
    }

    pub fn get_node_pubkey(&self) -> &[u8] {
        &self.node_pubkey
    }

    // string node_pubkey_string = 3;

    pub fn clear_node_pubkey_string(&mut self) {
        self.node_pubkey_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey_string(&mut self, v: ::std::string::String) {
        self.node_pubkey_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey_string(&mut self) -> &mut ::std::string::String {
        &mut self.node_pubkey_string
    }

    // Take field
    pub fn take_node_pubkey_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pubkey_string, ::std::string::String::new())
    }

    pub fn get_node_pubkey_string(&self) -> &str {
        &self.node_pubkey_string
    }

    // int64 local_funding_amount = 4;

    pub fn clear_local_funding_amount(&mut self) {
        self.local_funding_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_funding_amount(&mut self, v: i64) {
        self.local_funding_amount = v;
    }

    pub fn get_local_funding_amount(&self) -> i64 {
        self.local_funding_amount
    }

    // int64 push_sat = 5;

    pub fn clear_push_sat(&mut self) {
        self.push_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_push_sat(&mut self, v: i64) {
        self.push_sat = v;
    }

    pub fn get_push_sat(&self) -> i64 {
        self.push_sat
    }

    // int32 target_conf = 6;

    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }

    // int64 sat_per_byte = 7;

    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }

    // bool private = 8;

    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    pub fn get_private(&self) -> bool {
        self.private
    }

    // int64 min_htlc_msat = 9;

    pub fn clear_min_htlc_msat(&mut self) {
        self.min_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc_msat(&mut self, v: i64) {
        self.min_htlc_msat = v;
    }

    pub fn get_min_htlc_msat(&self) -> i64 {
        self.min_htlc_msat
    }

    // uint32 remote_csv_delay = 10;

    pub fn clear_remote_csv_delay(&mut self) {
        self.remote_csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_csv_delay(&mut self, v: u32) {
        self.remote_csv_delay = v;
    }

    pub fn get_remote_csv_delay(&self) -> u32 {
        self.remote_csv_delay
    }

    // int32 min_confs = 11;

    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }

    // bool spend_unconfirmed = 12;

    pub fn clear_spend_unconfirmed(&mut self) {
        self.spend_unconfirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_spend_unconfirmed(&mut self, v: bool) {
        self.spend_unconfirmed = v;
    }

    pub fn get_spend_unconfirmed(&self) -> bool {
        self.spend_unconfirmed
    }
}

impl ::protobuf::Message for OpenChannelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pubkey_string)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_funding_amount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.push_sat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_htlc_msat = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_csv_delay = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spend_unconfirmed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.node_pubkey);
        }
        if !self.node_pubkey_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.node_pubkey_string);
        }
        if self.local_funding_amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_funding_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.push_sat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.push_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(6, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.private != false {
            my_size += 2;
        }
        if self.min_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(9, self.min_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(10, self.remote_csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(11, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spend_unconfirmed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.node_pubkey.is_empty() {
            os.write_bytes(2, &self.node_pubkey)?;
        }
        if !self.node_pubkey_string.is_empty() {
            os.write_string(3, &self.node_pubkey_string)?;
        }
        if self.local_funding_amount != 0 {
            os.write_int64(4, self.local_funding_amount)?;
        }
        if self.push_sat != 0 {
            os.write_int64(5, self.push_sat)?;
        }
        if self.target_conf != 0 {
            os.write_int32(6, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(7, self.sat_per_byte)?;
        }
        if self.private != false {
            os.write_bool(8, self.private)?;
        }
        if self.min_htlc_msat != 0 {
            os.write_int64(9, self.min_htlc_msat)?;
        }
        if self.remote_csv_delay != 0 {
            os.write_uint32(10, self.remote_csv_delay)?;
        }
        if self.min_confs != 0 {
            os.write_int32(11, self.min_confs)?;
        }
        if self.spend_unconfirmed != false {
            os.write_bool(12, self.spend_unconfirmed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenChannelRequest {
        OpenChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "node_pubkey",
                    |m: &OpenChannelRequest| { &m.node_pubkey },
                    |m: &mut OpenChannelRequest| { &mut m.node_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node_pubkey_string",
                    |m: &OpenChannelRequest| { &m.node_pubkey_string },
                    |m: &mut OpenChannelRequest| { &mut m.node_pubkey_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_funding_amount",
                    |m: &OpenChannelRequest| { &m.local_funding_amount },
                    |m: &mut OpenChannelRequest| { &mut m.local_funding_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "push_sat",
                    |m: &OpenChannelRequest| { &m.push_sat },
                    |m: &mut OpenChannelRequest| { &mut m.push_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &OpenChannelRequest| { &m.target_conf },
                    |m: &mut OpenChannelRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &OpenChannelRequest| { &m.sat_per_byte },
                    |m: &mut OpenChannelRequest| { &mut m.sat_per_byte },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &OpenChannelRequest| { &m.private },
                    |m: &mut OpenChannelRequest| { &mut m.private },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_htlc_msat",
                    |m: &OpenChannelRequest| { &m.min_htlc_msat },
                    |m: &mut OpenChannelRequest| { &mut m.min_htlc_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remote_csv_delay",
                    |m: &OpenChannelRequest| { &m.remote_csv_delay },
                    |m: &mut OpenChannelRequest| { &mut m.remote_csv_delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "min_confs",
                    |m: &OpenChannelRequest| { &m.min_confs },
                    |m: &mut OpenChannelRequest| { &mut m.min_confs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "spend_unconfirmed",
                    |m: &OpenChannelRequest| { &m.spend_unconfirmed },
                    |m: &mut OpenChannelRequest| { &mut m.spend_unconfirmed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenChannelRequest>(
                    "OpenChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<OpenChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenChannelRequest,
        };
        unsafe {
            instance.get(OpenChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for OpenChannelRequest {
    fn clear(&mut self) {
        self.clear_node_pubkey();
        self.clear_node_pubkey_string();
        self.clear_local_funding_amount();
        self.clear_push_sat();
        self.clear_target_conf();
        self.clear_sat_per_byte();
        self.clear_private();
        self.clear_min_htlc_msat();
        self.clear_remote_csv_delay();
        self.clear_min_confs();
        self.clear_spend_unconfirmed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenStatusUpdate {
    // message oneof groups
    pub update: ::std::option::Option<OpenStatusUpdate_oneof_update>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum OpenStatusUpdate_oneof_update {
    chan_pending(PendingUpdate),
    confirmation(ConfirmationUpdate),
    chan_open(ChannelOpenUpdate),
}

impl OpenStatusUpdate {
    pub fn new() -> OpenStatusUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingUpdate chan_pending = 1;

    pub fn clear_chan_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_pending(&mut self) -> PendingUpdate {
        if self.has_chan_pending() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    pub fn get_chan_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) => v,
            _ => PendingUpdate::default_instance(),
        }
    }

    // .lnrpc.ConfirmationUpdate confirmation = 2;

    pub fn clear_confirmation(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_confirmation(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_confirmation(&mut self, v: ConfirmationUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_confirmation(&mut self) -> &mut ConfirmationUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(ConfirmationUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_confirmation(&mut self) -> ConfirmationUpdate {
        if self.has_confirmation() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfirmationUpdate::new()
        }
    }

    pub fn get_confirmation(&self) -> &ConfirmationUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(ref v)) => v,
            _ => ConfirmationUpdate::default_instance(),
        }
    }

    // .lnrpc.ChannelOpenUpdate chan_open = 3;

    pub fn clear_chan_open(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_open(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_open(&mut self, v: ChannelOpenUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_open(&mut self) -> &mut ChannelOpenUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ChannelOpenUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_open(&mut self) -> ChannelOpenUpdate {
        if self.has_chan_open() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelOpenUpdate::new()
        }
    }

    pub fn get_chan_open(&self) -> &ChannelOpenUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) => v,
            _ => ChannelOpenUpdate::default_instance(),
        }
    }
}

impl ::protobuf::Message for OpenStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpenStatusUpdate_oneof_update::confirmation(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::confirmation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpenStatusUpdate_oneof_update::confirmation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpenStatusUpdate_oneof_update::confirmation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenStatusUpdate {
        OpenStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                    "chan_pending",
                    OpenStatusUpdate::has_chan_pending,
                    OpenStatusUpdate::get_chan_pending,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConfirmationUpdate>(
                    "confirmation",
                    OpenStatusUpdate::has_confirmation,
                    OpenStatusUpdate::get_confirmation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelOpenUpdate>(
                    "chan_open",
                    OpenStatusUpdate::has_chan_open,
                    OpenStatusUpdate::get_chan_open,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenStatusUpdate>(
                    "OpenStatusUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenStatusUpdate {
        static mut instance: ::protobuf::lazy::Lazy<OpenStatusUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenStatusUpdate,
        };
        unsafe {
            instance.get(OpenStatusUpdate::new)
        }
    }
}

impl ::protobuf::Clear for OpenStatusUpdate {
    fn clear(&mut self) {
        self.clear_chan_pending();
        self.clear_confirmation();
        self.clear_chan_open();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingHTLC {
    // message fields
    pub incoming: bool,
    pub amount: i64,
    pub outpoint: ::std::string::String,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub stage: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingHTLC {
    pub fn new() -> PendingHTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;

    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    pub fn get_incoming(&self) -> bool {
        self.incoming
    }

    // int64 amount = 2;

    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    pub fn get_amount(&self) -> i64 {
        self.amount
    }

    // string outpoint = 3;

    pub fn clear_outpoint(&mut self) {
        self.outpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_outpoint(&mut self, v: ::std::string::String) {
        self.outpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outpoint(&mut self) -> &mut ::std::string::String {
        &mut self.outpoint
    }

    // Take field
    pub fn take_outpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outpoint, ::std::string::String::new())
    }

    pub fn get_outpoint(&self) -> &str {
        &self.outpoint
    }

    // uint32 maturity_height = 4;

    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }

    // int32 blocks_til_maturity = 5;

    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }

    // uint32 stage = 6;

    pub fn clear_stage(&mut self) {
        self.stage = 0;
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = v;
    }

    pub fn get_stage(&self) -> u32 {
        self.stage
    }
}

impl ::protobuf::Message for PendingHTLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outpoint)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.outpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.outpoint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stage != 0 {
            my_size += ::protobuf::rt::value_size(6, self.stage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if !self.outpoint.is_empty() {
            os.write_string(3, &self.outpoint)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.stage != 0 {
            os.write_uint32(6, self.stage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingHTLC {
        PendingHTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "incoming",
                    |m: &PendingHTLC| { &m.incoming },
                    |m: &mut PendingHTLC| { &mut m.incoming },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &PendingHTLC| { &m.amount },
                    |m: &mut PendingHTLC| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "outpoint",
                    |m: &PendingHTLC| { &m.outpoint },
                    |m: &mut PendingHTLC| { &mut m.outpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maturity_height",
                    |m: &PendingHTLC| { &m.maturity_height },
                    |m: &mut PendingHTLC| { &mut m.maturity_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "blocks_til_maturity",
                    |m: &PendingHTLC| { &m.blocks_til_maturity },
                    |m: &mut PendingHTLC| { &mut m.blocks_til_maturity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stage",
                    |m: &PendingHTLC| { &m.stage },
                    |m: &mut PendingHTLC| { &mut m.stage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingHTLC>(
                    "PendingHTLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingHTLC {
        static mut instance: ::protobuf::lazy::Lazy<PendingHTLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingHTLC,
        };
        unsafe {
            instance.get(PendingHTLC::new)
        }
    }
}

impl ::protobuf::Clear for PendingHTLC {
    fn clear(&mut self) {
        self.clear_incoming();
        self.clear_amount();
        self.clear_outpoint();
        self.clear_maturity_height();
        self.clear_blocks_til_maturity();
        self.clear_stage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingHTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingHTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsRequest {
    pub fn new() -> PendingChannelsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PendingChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsRequest {
        PendingChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsRequest>(
                    "PendingChannelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsRequest,
        };
        unsafe {
            instance.get(PendingChannelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse {
    // message fields
    pub total_limbo_balance: i64,
    pub pending_open_channels: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>,
    pub pending_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>,
    pub pending_force_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>,
    pub waiting_close_channels: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse {
    pub fn new() -> PendingChannelsResponse {
        ::std::default::Default::default()
    }

    // int64 total_limbo_balance = 1;

    pub fn clear_total_limbo_balance(&mut self) {
        self.total_limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_limbo_balance(&mut self, v: i64) {
        self.total_limbo_balance = v;
    }

    pub fn get_total_limbo_balance(&self) -> i64 {
        self.total_limbo_balance
    }

    // repeated .lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;

    pub fn clear_pending_open_channels(&mut self) {
        self.pending_open_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_open_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>) {
        self.pending_open_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_open_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        &mut self.pending_open_channels
    }

    // Take field
    pub fn take_pending_open_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        ::std::mem::replace(&mut self.pending_open_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_open_channels(&self) -> &[PendingChannelsResponse_PendingOpenChannel] {
        &self.pending_open_channels
    }

    // repeated .lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3;

    pub fn clear_pending_closing_channels(&mut self) {
        self.pending_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>) {
        self.pending_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        &mut self.pending_closing_channels
    }

    // Take field
    pub fn take_pending_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        ::std::mem::replace(&mut self.pending_closing_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_closing_channels(&self) -> &[PendingChannelsResponse_ClosedChannel] {
        &self.pending_closing_channels
    }

    // repeated .lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;

    pub fn clear_pending_force_closing_channels(&mut self) {
        self.pending_force_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_force_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>) {
        self.pending_force_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_force_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        &mut self.pending_force_closing_channels
    }

    // Take field
    pub fn take_pending_force_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        ::std::mem::replace(&mut self.pending_force_closing_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_force_closing_channels(&self) -> &[PendingChannelsResponse_ForceClosedChannel] {
        &self.pending_force_closing_channels
    }

    // repeated .lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;

    pub fn clear_waiting_close_channels(&mut self) {
        self.waiting_close_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_waiting_close_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>) {
        self.waiting_close_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_waiting_close_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        &mut self.waiting_close_channels
    }

    // Take field
    pub fn take_waiting_close_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        ::std::mem::replace(&mut self.waiting_close_channels, ::protobuf::RepeatedField::new())
    }

    pub fn get_waiting_close_channels(&self) -> &[PendingChannelsResponse_WaitingCloseChannel] {
        &self.waiting_close_channels
    }
}

impl ::protobuf::Message for PendingChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.pending_open_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_force_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.waiting_close_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_limbo_balance = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_open_channels)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_closing_channels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_force_closing_channels)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.waiting_close_channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_open_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_force_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.waiting_close_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.total_limbo_balance != 0 {
            os.write_int64(1, self.total_limbo_balance)?;
        }
        for v in &self.pending_open_channels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_closing_channels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_force_closing_channels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.waiting_close_channels {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse {
        PendingChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_limbo_balance",
                    |m: &PendingChannelsResponse| { &m.total_limbo_balance },
                    |m: &mut PendingChannelsResponse| { &mut m.total_limbo_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingOpenChannel>>(
                    "pending_open_channels",
                    |m: &PendingChannelsResponse| { &m.pending_open_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_open_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ClosedChannel>>(
                    "pending_closing_channels",
                    |m: &PendingChannelsResponse| { &m.pending_closing_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_closing_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ForceClosedChannel>>(
                    "pending_force_closing_channels",
                    |m: &PendingChannelsResponse| { &m.pending_force_closing_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_force_closing_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_WaitingCloseChannel>>(
                    "waiting_close_channels",
                    |m: &PendingChannelsResponse| { &m.waiting_close_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.waiting_close_channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse>(
                    "PendingChannelsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse,
        };
        unsafe {
            instance.get(PendingChannelsResponse::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse {
    fn clear(&mut self) {
        self.clear_total_limbo_balance();
        self.clear_pending_open_channels();
        self.clear_pending_closing_channels();
        self.clear_pending_force_closing_channels();
        self.clear_waiting_close_channels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_PendingChannel {
    // message fields
    pub remote_node_pub: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub capacity: i64,
    pub local_balance: i64,
    pub remote_balance: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_PendingChannel {
    pub fn new() -> PendingChannelsResponse_PendingChannel {
        ::std::default::Default::default()
    }

    // string remote_node_pub = 1;

    pub fn clear_remote_node_pub(&mut self) {
        self.remote_node_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_node_pub(&mut self, v: ::std::string::String) {
        self.remote_node_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_node_pub(&mut self) -> &mut ::std::string::String {
        &mut self.remote_node_pub
    }

    // Take field
    pub fn take_remote_node_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_node_pub, ::std::string::String::new())
    }

    pub fn get_remote_node_pub(&self) -> &str {
        &self.remote_node_pub
    }

    // string channel_point = 2;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }

    // int64 capacity = 3;

    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }

    // int64 local_balance = 4;

    pub fn clear_local_balance(&mut self) {
        self.local_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: i64) {
        self.local_balance = v;
    }

    pub fn get_local_balance(&self) -> i64 {
        self.local_balance
    }

    // int64 remote_balance = 5;

    pub fn clear_remote_balance(&mut self) {
        self.remote_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: i64) {
        self.remote_balance = v;
    }

    pub fn get_remote_balance(&self) -> i64 {
        self.remote_balance
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingChannel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_node_pub)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_balance = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.remote_node_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.remote_node_pub);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_point);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_balance != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_balance != 0 {
            my_size += ::protobuf::rt::value_size(5, self.remote_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.remote_node_pub.is_empty() {
            os.write_string(1, &self.remote_node_pub)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(2, &self.channel_point)?;
        }
        if self.capacity != 0 {
            os.write_int64(3, self.capacity)?;
        }
        if self.local_balance != 0 {
            os.write_int64(4, self.local_balance)?;
        }
        if self.remote_balance != 0 {
            os.write_int64(5, self.remote_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingChannel {
        PendingChannelsResponse_PendingChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_node_pub",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.remote_node_pub },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_node_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.channel_point },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.capacity },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_balance",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.local_balance },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.local_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remote_balance",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.remote_balance },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_PendingChannel>(
                    "PendingChannelsResponse_PendingChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_PendingChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_PendingChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_PendingChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingChannel {
    fn clear(&mut self) {
        self.clear_remote_node_pub();
        self.clear_channel_point();
        self.clear_capacity();
        self.clear_local_balance();
        self.clear_remote_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_PendingOpenChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub confirmation_height: u32,
    pub commit_fee: i64,
    pub commit_weight: i64,
    pub fee_per_kw: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_PendingOpenChannel {
    pub fn new() -> PendingChannelsResponse_PendingOpenChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // uint32 confirmation_height = 2;

    pub fn clear_confirmation_height(&mut self) {
        self.confirmation_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmation_height(&mut self, v: u32) {
        self.confirmation_height = v;
    }

    pub fn get_confirmation_height(&self) -> u32 {
        self.confirmation_height
    }

    // int64 commit_fee = 4;

    pub fn clear_commit_fee(&mut self) {
        self.commit_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: i64) {
        self.commit_fee = v;
    }

    pub fn get_commit_fee(&self) -> i64 {
        self.commit_fee
    }

    // int64 commit_weight = 5;

    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }

    // int64 fee_per_kw = 6;

    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: i64) {
        self.fee_per_kw = v;
    }

    pub fn get_fee_per_kw(&self) -> i64 {
        self.fee_per_kw
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingOpenChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.confirmation_height = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_kw = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.confirmation_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.confirmation_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.commit_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(5, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(6, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.confirmation_height != 0 {
            os.write_uint32(2, self.confirmation_height)?;
        }
        if self.commit_fee != 0 {
            os.write_int64(4, self.commit_fee)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(5, self.commit_weight)?;
        }
        if self.fee_per_kw != 0 {
            os.write_int64(6, self.fee_per_kw)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingOpenChannel {
        PendingChannelsResponse_PendingOpenChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "confirmation_height",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.confirmation_height },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.confirmation_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_fee",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_fee },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_weight",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_weight },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_per_kw",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.fee_per_kw },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.fee_per_kw },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_PendingOpenChannel>(
                    "PendingChannelsResponse_PendingOpenChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingOpenChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_PendingOpenChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_PendingOpenChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_PendingOpenChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingOpenChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_confirmation_height();
        self.clear_commit_fee();
        self.clear_commit_weight();
        self.clear_fee_per_kw();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingOpenChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingOpenChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_WaitingCloseChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub limbo_balance: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_WaitingCloseChannel {
    pub fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // int64 limbo_balance = 2;

    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }

    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }
}

impl ::protobuf::Message for PendingChannelsResponse_WaitingCloseChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(2, self.limbo_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        PendingChannelsResponse_WaitingCloseChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limbo_balance",
                    |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.limbo_balance },
                    |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.limbo_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_WaitingCloseChannel>(
                    "PendingChannelsResponse_WaitingCloseChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_WaitingCloseChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_WaitingCloseChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_WaitingCloseChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_WaitingCloseChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_WaitingCloseChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_limbo_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_WaitingCloseChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_WaitingCloseChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_ClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_ClosedChannel {
    pub fn new() -> PendingChannelsResponse_ClosedChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // string closing_txid = 2;

    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }

    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ClosedChannel {
        PendingChannelsResponse_ClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_ClosedChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_txid",
                    |m: &PendingChannelsResponse_ClosedChannel| { &m.closing_txid },
                    |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.closing_txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_ClosedChannel>(
                    "PendingChannelsResponse_ClosedChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_ClosedChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_ClosedChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_ClosedChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_ClosedChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ClosedChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_closing_txid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_ForceClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    pub limbo_balance: i64,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub recovered_balance: i64,
    pub pending_htlcs: ::protobuf::RepeatedField<PendingHTLC>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PendingChannelsResponse_ForceClosedChannel {
    pub fn new() -> PendingChannelsResponse_ForceClosedChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;

    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }

    // string closing_txid = 2;

    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }

    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }

    // int64 limbo_balance = 3;

    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }

    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }

    // uint32 maturity_height = 4;

    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }

    // int32 blocks_til_maturity = 5;

    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }

    // int64 recovered_balance = 6;

    pub fn clear_recovered_balance(&mut self) {
        self.recovered_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovered_balance(&mut self, v: i64) {
        self.recovered_balance = v;
    }

    pub fn get_recovered_balance(&self) -> i64 {
        self.recovered_balance
    }

    // repeated .lnrpc.PendingHTLC pending_htlcs = 8;

    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<PendingHTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<PendingHTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<PendingHTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_pending_htlcs(&self) -> &[PendingHTLC] {
        &self.pending_htlcs
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ForceClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.recovered_balance = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.recovered_balance != 0 {
            my_size += ::protobuf::rt::value_size(6, self.recovered_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(3, self.limbo_balance)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.recovered_balance != 0 {
            os.write_int64(6, self.recovered_balance)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ForceClosedChannel {
        PendingChannelsResponse_ForceClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_txid",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.closing_txid },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.closing_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limbo_balance",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.limbo_balance },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.limbo_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maturity_height",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.maturity_height },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.maturity_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "blocks_til_maturity",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.blocks_til_maturity },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.blocks_til_maturity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "recovered_balance",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.recovered_balance },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.recovered_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingHTLC>>(
                    "pending_htlcs",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.pending_htlcs },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.pending_htlcs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_ForceClosedChannel>(
                    "PendingChannelsResponse_ForceClosedChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_ForceClosedChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_ForceClosedChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_ForceClosedChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_ForceClosedChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ForceClosedChannel {
    fn clear(&mut self) {
        self.clear_channel();
        self.clear_closing_txid();
        self.clear_limbo_balance();
        self.clear_maturity_height();
        self.clear_blocks_til_maturity();
        self.clear_recovered_balance();
        self.clear_pending_htlcs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ForceClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ForceClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WalletBalanceRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WalletBalanceRequest {
    pub fn new() -> WalletBalanceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WalletBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletBalanceRequest {
        WalletBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WalletBalanceRequest>(
                    "WalletBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WalletBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<WalletBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WalletBalanceRequest,
        };
        unsafe {
            instance.get(WalletBalanceRequest::new)
        }
    }
}

impl ::protobuf::Clear for WalletBalanceRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WalletBalanceResponse {
    // message fields
    pub total_balance: i64,
    pub confirmed_balance: i64,
    pub unconfirmed_balance: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WalletBalanceResponse {
    pub fn new() -> WalletBalanceResponse {
        ::std::default::Default::default()
    }

    // int64 total_balance = 1;

    pub fn clear_total_balance(&mut self) {
        self.total_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_balance(&mut self, v: i64) {
        self.total_balance = v;
    }

    pub fn get_total_balance(&self) -> i64 {
        self.total_balance
    }

    // int64 confirmed_balance = 2;

    pub fn clear_confirmed_balance(&mut self) {
        self.confirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmed_balance(&mut self, v: i64) {
        self.confirmed_balance = v;
    }

    pub fn get_confirmed_balance(&self) -> i64 {
        self.confirmed_balance
    }

    // int64 unconfirmed_balance = 3;

    pub fn clear_unconfirmed_balance(&mut self) {
        self.unconfirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed_balance(&mut self, v: i64) {
        self.unconfirmed_balance = v;
    }

    pub fn get_unconfirmed_balance(&self) -> i64 {
        self.unconfirmed_balance
    }
}

impl ::protobuf::Message for WalletBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.confirmed_balance = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unconfirmed_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.confirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.confirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unconfirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.unconfirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.total_balance != 0 {
            os.write_int64(1, self.total_balance)?;
        }
        if self.confirmed_balance != 0 {
            os.write_int64(2, self.confirmed_balance)?;
        }
        if self.unconfirmed_balance != 0 {
            os.write_int64(3, self.unconfirmed_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletBalanceResponse {
        WalletBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_balance",
                    |m: &WalletBalanceResponse| { &m.total_balance },
                    |m: &mut WalletBalanceResponse| { &mut m.total_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "confirmed_balance",
                    |m: &WalletBalanceResponse| { &m.confirmed_balance },
                    |m: &mut WalletBalanceResponse| { &mut m.confirmed_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unconfirmed_balance",
                    |m: &WalletBalanceResponse| { &m.unconfirmed_balance },
                    |m: &mut WalletBalanceResponse| { &mut m.unconfirmed_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WalletBalanceResponse>(
                    "WalletBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WalletBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<WalletBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WalletBalanceResponse,
        };
        unsafe {
            instance.get(WalletBalanceResponse::new)
        }
    }
}

impl ::protobuf::Clear for WalletBalanceResponse {
    fn clear(&mut self) {
        self.clear_total_balance();
        self.clear_confirmed_balance();
        self.clear_unconfirmed_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelBalanceRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelBalanceRequest {
    pub fn new() -> ChannelBalanceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBalanceRequest {
        ChannelBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ChannelBalanceRequest>(
                    "ChannelBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChannelBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelBalanceRequest,
        };
        unsafe {
            instance.get(ChannelBalanceRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChannelBalanceRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelBalanceResponse {
    // message fields
    pub balance: i64,
    pub pending_open_balance: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelBalanceResponse {
    pub fn new() -> ChannelBalanceResponse {
        ::std::default::Default::default()
    }

    // int64 balance = 1;

    pub fn clear_balance(&mut self) {
        self.balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = v;
    }

    pub fn get_balance(&self) -> i64 {
        self.balance
    }

    // int64 pending_open_balance = 2;

    pub fn clear_pending_open_balance(&mut self) {
        self.pending_open_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_pending_open_balance(&mut self, v: i64) {
        self.pending_open_balance = v;
    }

    pub fn get_pending_open_balance(&self) -> i64 {
        self.pending_open_balance
    }
}

impl ::protobuf::Message for ChannelBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pending_open_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pending_open_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pending_open_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.balance != 0 {
            os.write_int64(1, self.balance)?;
        }
        if self.pending_open_balance != 0 {
            os.write_int64(2, self.pending_open_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBalanceResponse {
        ChannelBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "balance",
                    |m: &ChannelBalanceResponse| { &m.balance },
                    |m: &mut ChannelBalanceResponse| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "pending_open_balance",
                    |m: &ChannelBalanceResponse| { &m.pending_open_balance },
                    |m: &mut ChannelBalanceResponse| { &mut m.pending_open_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelBalanceResponse>(
                    "ChannelBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<ChannelBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelBalanceResponse,
        };
        unsafe {
            instance.get(ChannelBalanceResponse::new)
        }
    }
}

impl ::protobuf::Clear for ChannelBalanceResponse {
    fn clear(&mut self) {
        self.clear_balance();
        self.clear_pending_open_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRoutesRequest {
    // message fields
    pub pub_key: ::std::string::String,
    pub amt: i64,
    pub num_routes: i32,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<FeeLimit>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryRoutesRequest {
    pub fn new() -> QueryRoutesRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;

    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }

    // int64 amt = 2;

    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    pub fn get_amt(&self) -> i64 {
        self.amt
    }

    // int32 num_routes = 3;

    pub fn clear_num_routes(&mut self) {
        self.num_routes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_routes(&mut self, v: i32) {
        self.num_routes = v;
    }

    pub fn get_num_routes(&self) -> i32 {
        self.num_routes
    }

    // int32 final_cltv_delta = 4;

    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }

    // .lnrpc.FeeLimit fee_limit = 5;

    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| FeeLimit::new())
    }

    pub fn get_fee_limit(&self) -> &FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| FeeLimit::default_instance())
    }
}

impl ::protobuf::Message for QueryRoutesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_routes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_routes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_routes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(4, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if self.amt != 0 {
            os.write_int64(2, self.amt)?;
        }
        if self.num_routes != 0 {
            os.write_int32(3, self.num_routes)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(4, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRoutesRequest {
        QueryRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &QueryRoutesRequest| { &m.pub_key },
                    |m: &mut QueryRoutesRequest| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt",
                    |m: &QueryRoutesRequest| { &m.amt },
                    |m: &mut QueryRoutesRequest| { &mut m.amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_routes",
                    |m: &QueryRoutesRequest| { &m.num_routes },
                    |m: &mut QueryRoutesRequest| { &mut m.num_routes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_cltv_delta",
                    |m: &QueryRoutesRequest| { &m.final_cltv_delta },
                    |m: &mut QueryRoutesRequest| { &mut m.final_cltv_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeLimit>>(
                    "fee_limit",
                    |m: &QueryRoutesRequest| { &m.fee_limit },
                    |m: &mut QueryRoutesRequest| { &mut m.fee_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRoutesRequest>(
                    "QueryRoutesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRoutesRequest {
        static mut instance: ::protobuf::lazy::Lazy<QueryRoutesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRoutesRequest,
        };
        unsafe {
            instance.get(QueryRoutesRequest::new)
        }
    }
}

impl ::protobuf::Clear for QueryRoutesRequest {
    fn clear(&mut self) {
        self.clear_pub_key();
        self.clear_amt();
        self.clear_num_routes();
        self.clear_final_cltv_delta();
        self.clear_fee_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRoutesResponse {
    // message fields
    pub routes: ::protobuf::RepeatedField<Route>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryRoutesResponse {
    pub fn new() -> QueryRoutesResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Route routes = 1;

    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    pub fn get_routes(&self) -> &[Route] {
        &self.routes
    }
}

impl ::protobuf::Message for QueryRoutesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.routes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRoutesResponse {
        QueryRoutesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                    "routes",
                    |m: &QueryRoutesResponse| { &m.routes },
                    |m: &mut QueryRoutesResponse| { &mut m.routes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRoutesResponse>(
                    "QueryRoutesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRoutesResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryRoutesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRoutesResponse,
        };
        unsafe {
            instance.get(QueryRoutesResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryRoutesResponse {
    fn clear(&mut self) {
        self.clear_routes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRoutesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRoutesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hop {
    // message fields
    pub chan_id: u64,
    pub chan_capacity: i64,
    pub amt_to_forward: i64,
    pub fee: i64,
    pub expiry: u32,
    pub amt_to_forward_msat: i64,
    pub fee_msat: i64,
    pub pub_key: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Hop {
    pub fn new() -> Hop {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }

    // int64 chan_capacity = 2;

    pub fn clear_chan_capacity(&mut self) {
        self.chan_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_capacity(&mut self, v: i64) {
        self.chan_capacity = v;
    }

    pub fn get_chan_capacity(&self) -> i64 {
        self.chan_capacity
    }

    // int64 amt_to_forward = 3;

    pub fn clear_amt_to_forward(&mut self) {
        self.amt_to_forward = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_to_forward(&mut self, v: i64) {
        self.amt_to_forward = v;
    }

    pub fn get_amt_to_forward(&self) -> i64 {
        self.amt_to_forward
    }

    // int64 fee = 4;

    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    pub fn get_fee(&self) -> i64 {
        self.fee
    }

    // uint32 expiry = 5;

    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: u32) {
        self.expiry = v;
    }

    pub fn get_expiry(&self) -> u32 {
        self.expiry
    }

    // int64 amt_to_forward_msat = 6;

    pub fn clear_amt_to_forward_msat(&mut self) {
        self.amt_to_forward_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_to_forward_msat(&mut self, v: i64) {
        self.amt_to_forward_msat = v;
    }

    pub fn get_amt_to_forward_msat(&self) -> i64 {
        self.amt_to_forward_msat
    }

    // int64 fee_msat = 7;

    pub fn clear_fee_msat(&mut self) {
        self.fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_msat(&mut self, v: i64) {
        self.fee_msat = v;
    }

    pub fn get_fee_msat(&self) -> i64 {
        self.fee_msat
    }

    // string pub_key = 8;

    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
}

impl ::protobuf::Message for Hop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.chan_capacity = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_to_forward = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiry = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_to_forward_msat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_msat = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_capacity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_to_forward != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt_to_forward, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_to_forward_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.amt_to_forward_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.pub_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.chan_capacity != 0 {
            os.write_int64(2, self.chan_capacity)?;
        }
        if self.amt_to_forward != 0 {
            os.write_int64(3, self.amt_to_forward)?;
        }
        if self.fee != 0 {
            os.write_int64(4, self.fee)?;
        }
        if self.expiry != 0 {
            os.write_uint32(5, self.expiry)?;
        }
        if self.amt_to_forward_msat != 0 {
            os.write_int64(6, self.amt_to_forward_msat)?;
        }
        if self.fee_msat != 0 {
            os.write_int64(7, self.fee_msat)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(8, &self.pub_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hop {
        Hop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &Hop| { &m.chan_id },
                    |m: &mut Hop| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "chan_capacity",
                    |m: &Hop| { &m.chan_capacity },
                    |m: &mut Hop| { &mut m.chan_capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_to_forward",
                    |m: &Hop| { &m.amt_to_forward },
                    |m: &mut Hop| { &mut m.amt_to_forward },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &Hop| { &m.fee },
                    |m: &mut Hop| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expiry",
                    |m: &Hop| { &m.expiry },
                    |m: &mut Hop| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_to_forward_msat",
                    |m: &Hop| { &m.amt_to_forward_msat },
                    |m: &mut Hop| { &mut m.amt_to_forward_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_msat",
                    |m: &Hop| { &m.fee_msat },
                    |m: &mut Hop| { &mut m.fee_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &Hop| { &m.pub_key },
                    |m: &mut Hop| { &mut m.pub_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Hop>(
                    "Hop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hop {
        static mut instance: ::protobuf::lazy::Lazy<Hop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Hop,
        };
        unsafe {
            instance.get(Hop::new)
        }
    }
}

impl ::protobuf::Clear for Hop {
    fn clear(&mut self) {
        self.clear_chan_id();
        self.clear_chan_capacity();
        self.clear_amt_to_forward();
        self.clear_fee();
        self.clear_expiry();
        self.clear_amt_to_forward_msat();
        self.clear_fee_msat();
        self.clear_pub_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Route {
    // message fields
    pub total_time_lock: u32,
    pub total_fees: i64,
    pub total_amt: i64,
    pub hops: ::protobuf::RepeatedField<Hop>,
    pub total_fees_msat: i64,
    pub total_amt_msat: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Route {
    pub fn new() -> Route {
        ::std::default::Default::default()
    }

    // uint32 total_time_lock = 1;

    pub fn clear_total_time_lock(&mut self) {
        self.total_time_lock = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_time_lock(&mut self, v: u32) {
        self.total_time_lock = v;
    }

    pub fn get_total_time_lock(&self) -> u32 {
        self.total_time_lock
    }

    // int64 total_fees = 2;

    pub fn clear_total_fees(&mut self) {
        self.total_fees = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees(&mut self, v: i64) {
        self.total_fees = v;
    }

    pub fn get_total_fees(&self) -> i64 {
        self.total_fees
    }

    // int64 total_amt = 3;

    pub fn clear_total_amt(&mut self) {
        self.total_amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_amt(&mut self, v: i64) {
        self.total_amt = v;
    }

    pub fn get_total_amt(&self) -> i64 {
        self.total_amt
    }

    // repeated .lnrpc.Hop hops = 4;

    pub fn clear_hops(&mut self) {
        self.hops.clear();
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: ::protobuf::RepeatedField<Hop>) {
        self.hops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hops(&mut self) -> &mut ::protobuf::RepeatedField<Hop> {
        &mut self.hops
    }

    // Take field
    pub fn take_hops(&mut self) -> ::protobuf::RepeatedField<Hop> {
        ::std::mem::replace(&mut self.hops, ::protobuf::RepeatedField::new())
    }

    pub fn get_hops(&self) -> &[Hop] {
        &self.hops
    }

    // int64 total_fees_msat = 5;

    pub fn clear_total_fees_msat(&mut self) {
        self.total_fees_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees_msat(&mut self, v: i64) {
        self.total_fees_msat = v;
    }

    pub fn get_total_fees_msat(&self) -> i64 {
        self.total_fees_msat
    }

    // int64 total_amt_msat = 6;

    pub fn clear_total_amt_msat(&mut self) {
        self.total_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_amt_msat(&mut self, v: i64) {
        self.total_amt_msat = v;
    }

    pub fn get_total_amt_msat(&self) -> i64 {
        self.total_amt_msat
    }
}

impl ::protobuf::Message for Route {
    fn is_initialized(&self) -> bool {
        for v in &self.hops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_time_lock = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_amt = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hops)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees_msat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_amt_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_time_lock != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_time_lock, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_fees != 0 {
            my_size += ::protobuf::rt::value_size(2, self.total_fees, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_amt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_amt, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.hops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.total_fees_msat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.total_fees_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.total_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.total_time_lock != 0 {
            os.write_uint32(1, self.total_time_lock)?;
        }
        if self.total_fees != 0 {
            os.write_int64(2, self.total_fees)?;
        }
        if self.total_amt != 0 {
            os.write_int64(3, self.total_amt)?;
        }
        for v in &self.hops {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.total_fees_msat != 0 {
            os.write_int64(5, self.total_fees_msat)?;
        }
        if self.total_amt_msat != 0 {
            os.write_int64(6, self.total_amt_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Route {
        Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_time_lock",
                    |m: &Route| { &m.total_time_lock },
                    |m: &mut Route| { &mut m.total_time_lock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_fees",
                    |m: &Route| { &m.total_fees },
                    |m: &mut Route| { &mut m.total_fees },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_amt",
                    |m: &Route| { &m.total_amt },
                    |m: &mut Route| { &mut m.total_amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hop>>(
                    "hops",
                    |m: &Route| { &m.hops },
                    |m: &mut Route| { &mut m.hops },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_fees_msat",
                    |m: &Route| { &m.total_fees_msat },
                    |m: &mut Route| { &mut m.total_fees_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_amt_msat",
                    |m: &Route| { &m.total_amt_msat },
                    |m: &mut Route| { &mut m.total_amt_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Route>(
                    "Route",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Route {
        static mut instance: ::protobuf::lazy::Lazy<Route> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Route,
        };
        unsafe {
            instance.get(Route::new)
        }
    }
}

impl ::protobuf::Clear for Route {
    fn clear(&mut self) {
        self.clear_total_time_lock();
        self.clear_total_fees();
        self.clear_total_amt();
        self.clear_hops();
        self.clear_total_fees_msat();
        self.clear_total_amt_msat();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Route {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfoRequest {
    // message fields
    pub pub_key: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NodeInfoRequest {
    pub fn new() -> NodeInfoRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;

    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
}

impl ::protobuf::Message for NodeInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfoRequest {
        NodeInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &NodeInfoRequest| { &m.pub_key },
                    |m: &mut NodeInfoRequest| { &mut m.pub_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfoRequest>(
                    "NodeInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfoRequest,
        };
        unsafe {
            instance.get(NodeInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfoRequest {
    fn clear(&mut self) {
        self.clear_pub_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo {
    // message fields
    pub node: ::protobuf::SingularPtrField<LightningNode>,
    pub num_channels: u32,
    pub total_capacity: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NodeInfo {
    pub fn new() -> NodeInfo {
        ::std::default::Default::default()
    }

    // .lnrpc.LightningNode node = 1;

    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    pub fn has_node(&self) -> bool {
        self.node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: LightningNode) {
        self.node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut LightningNode {
        if self.node.is_none() {
            self.node.set_default();
        }
        self.node.as_mut().unwrap()
    }

    // Take field
    pub fn take_node(&mut self) -> LightningNode {
        self.node.take().unwrap_or_else(|| LightningNode::new())
    }

    pub fn get_node(&self) -> &LightningNode {
        self.node.as_ref().unwrap_or_else(|| LightningNode::default_instance())
    }

    // uint32 num_channels = 2;

    pub fn clear_num_channels(&mut self) {
        self.num_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_channels(&mut self, v: u32) {
        self.num_channels = v;
    }

    pub fn get_num_channels(&self) -> u32 {
        self.num_channels
    }

    // int64 total_capacity = 3;

    pub fn clear_total_capacity(&mut self) {
        self.total_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_capacity(&mut self, v: i64) {
        self.total_capacity = v;
    }

    pub fn get_total_capacity(&self) -> i64 {
        self.total_capacity
    }
}

impl ::protobuf::Message for NodeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_channels = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_capacity = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.num_channels != 0 {
            os.write_uint32(2, self.num_channels)?;
        }
        if self.total_capacity != 0 {
            os.write_int64(3, self.total_capacity)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo {
        NodeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningNode>>(
                    "node",
                    |m: &NodeInfo| { &m.node },
                    |m: &mut NodeInfo| { &mut m.node },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_channels",
                    |m: &NodeInfo| { &m.num_channels },
                    |m: &mut NodeInfo| { &mut m.num_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_capacity",
                    |m: &NodeInfo| { &m.total_capacity },
                    |m: &mut NodeInfo| { &mut m.total_capacity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo>(
                    "NodeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo,
        };
        unsafe {
            instance.get(NodeInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo {
    fn clear(&mut self) {
        self.clear_node();
        self.clear_num_channels();
        self.clear_total_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightningNode {
    // message fields
    pub last_update: u32,
    pub pub_key: ::std::string::String,
    pub alias: ::std::string::String,
    pub addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub color: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LightningNode {
    pub fn new() -> LightningNode {
        ::std::default::Default::default()
    }

    // uint32 last_update = 1;

    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }

    // string pub_key = 2;

    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }

    // string alias = 3;

    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    pub fn get_alias(&self) -> &str {
        &self.alias
    }

    // repeated .lnrpc.NodeAddress addresses = 4;

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_addresses(&self) -> &[NodeAddress] {
        &self.addresses
    }

    // string color = 5;

    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }

    pub fn get_color(&self) -> &str {
        &self.color
    }
}

impl ::protobuf::Message for LightningNode {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(1, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pub_key);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.alias);
        }
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.last_update != 0 {
            os.write_uint32(1, self.last_update)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(2, &self.pub_key)?;
        }
        if !self.alias.is_empty() {
            os.write_string(3, &self.alias)?;
        }
        for v in &self.addresses {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningNode {
        LightningNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_update",
                    |m: &LightningNode| { &m.last_update },
                    |m: &mut LightningNode| { &mut m.last_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &LightningNode| { &m.pub_key },
                    |m: &mut LightningNode| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &LightningNode| { &m.alias },
                    |m: &mut LightningNode| { &mut m.alias },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                    "addresses",
                    |m: &LightningNode| { &m.addresses },
                    |m: &mut LightningNode| { &mut m.addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "color",
                    |m: &LightningNode| { &m.color },
                    |m: &mut LightningNode| { &mut m.color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LightningNode>(
                    "LightningNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LightningNode {
        static mut instance: ::protobuf::lazy::Lazy<LightningNode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LightningNode,
        };
        unsafe {
            instance.get(LightningNode::new)
        }
    }
}

impl ::protobuf::Clear for LightningNode {
    fn clear(&mut self) {
        self.clear_last_update();
        self.clear_pub_key();
        self.clear_alias();
        self.clear_addresses();
        self.clear_color();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningNode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAddress {
    // message fields
    pub network: ::std::string::String,
    pub addr: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // string network = 1;

    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }

    pub fn get_network(&self) -> &str {
        &self.network
    }

    // string addr = 2;

    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }

    pub fn get_addr(&self) -> &str {
        &self.addr
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.network);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.network.is_empty() {
            os.write_string(1, &self.network)?;
        }
        if !self.addr.is_empty() {
            os.write_string(2, &self.addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "network",
                    |m: &NodeAddress| { &m.network },
                    |m: &mut NodeAddress| { &mut m.network },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addr",
                    |m: &NodeAddress| { &m.addr },
                    |m: &mut NodeAddress| { &mut m.addr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAddress>(
                    "NodeAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeAddress {
        static mut instance: ::protobuf::lazy::Lazy<NodeAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAddress,
        };
        unsafe {
            instance.get(NodeAddress::new)
        }
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.clear_network();
        self.clear_addr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingPolicy {
    // message fields
    pub time_lock_delta: u32,
    pub min_htlc: i64,
    pub fee_base_msat: i64,
    pub fee_rate_milli_msat: i64,
    pub disabled: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RoutingPolicy {
    pub fn new() -> RoutingPolicy {
        ::std::default::Default::default()
    }

    // uint32 time_lock_delta = 1;

    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }

    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }

    // int64 min_htlc = 2;

    pub fn clear_min_htlc(&mut self) {
        self.min_htlc = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc(&mut self, v: i64) {
        self.min_htlc = v;
    }

    pub fn get_min_htlc(&self) -> i64 {
        self.min_htlc
    }

    // int64 fee_base_msat = 3;

    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: i64) {
        self.fee_base_msat = v;
    }

    pub fn get_fee_base_msat(&self) -> i64 {
        self.fee_base_msat
    }

    // int64 fee_rate_milli_msat = 4;

    pub fn clear_fee_rate_milli_msat(&mut self) {
        self.fee_rate_milli_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate_milli_msat(&mut self, v: i64) {
        self.fee_rate_milli_msat = v;
    }

    pub fn get_fee_rate_milli_msat(&self) -> i64 {
        self.fee_rate_milli_msat
    }

    // bool disabled = 5;

    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }

    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
}

impl ::protobuf::Message for RoutingPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_htlc = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_base_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_rate_milli_msat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc != 0 {
            my_size += ::protobuf::rt::value_size(2, self.min_htlc, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_base_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_base_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate_milli_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee_rate_milli_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.time_lock_delta != 0 {
            os.write_uint32(1, self.time_lock_delta)?;
        }
        if self.min_htlc != 0 {
            os.write_int64(2, self.min_htlc)?;
        }
        if self.fee_base_msat != 0 {
            os.write_int64(3, self.fee_base_msat)?;
        }
        if self.fee_rate_milli_msat != 0 {
            os.write_int64(4, self.fee_rate_milli_msat)?;
        }
        if self.disabled != false {
            os.write_bool(5, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingPolicy {
        RoutingPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_lock_delta",
                    |m: &RoutingPolicy| { &m.time_lock_delta },
                    |m: &mut RoutingPolicy| { &mut m.time_lock_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_htlc",
                    |m: &RoutingPolicy| { &m.min_htlc },
                    |m: &mut RoutingPolicy| { &mut m.min_htlc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_base_msat",
                    |m: &RoutingPolicy| { &m.fee_base_msat },
                    |m: &mut RoutingPolicy| { &mut m.fee_base_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_rate_milli_msat",
                    |m: &RoutingPolicy| { &m.fee_rate_milli_msat },
                    |m: &mut RoutingPolicy| { &mut m.fee_rate_milli_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disabled",
                    |m: &RoutingPolicy| { &m.disabled },
                    |m: &mut RoutingPolicy| { &mut m.disabled },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoutingPolicy>(
                    "RoutingPolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoutingPolicy {
        static mut instance: ::protobuf::lazy::Lazy<RoutingPolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoutingPolicy,
        };
        unsafe {
            instance.get(RoutingPolicy::new)
        }
    }
}

impl ::protobuf::Clear for RoutingPolicy {
    fn clear(&mut self) {
        self.clear_time_lock_delta();
        self.clear_min_htlc();
        self.clear_fee_base_msat();
        self.clear_fee_rate_milli_msat();
        self.clear_disabled();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelEdge {
    // message fields
    pub channel_id: u64,
    pub chan_point: ::std::string::String,
    pub last_update: u32,
    pub node1_pub: ::std::string::String,
    pub node2_pub: ::std::string::String,
    pub capacity: i64,
    pub node1_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    pub node2_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelEdge {
    pub fn new() -> ChannelEdge {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;

    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }

    // string chan_point = 2;

    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ::std::string::String) {
        self.chan_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ::std::string::String {
        &mut self.chan_point
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_point, ::std::string::String::new())
    }

    pub fn get_chan_point(&self) -> &str {
        &self.chan_point
    }

    // uint32 last_update = 3;

    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }

    // string node1_pub = 4;

    pub fn clear_node1_pub(&mut self) {
        self.node1_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node1_pub(&mut self, v: ::std::string::String) {
        self.node1_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node1_pub
    }

    // Take field
    pub fn take_node1_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node1_pub, ::std::string::String::new())
    }

    pub fn get_node1_pub(&self) -> &str {
        &self.node1_pub
    }

    // string node2_pub = 5;

    pub fn clear_node2_pub(&mut self) {
        self.node2_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node2_pub(&mut self, v: ::std::string::String) {
        self.node2_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node2_pub
    }

    // Take field
    pub fn take_node2_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node2_pub, ::std::string::String::new())
    }

    pub fn get_node2_pub(&self) -> &str {
        &self.node2_pub
    }

    // int64 capacity = 6;

    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }

    // .lnrpc.RoutingPolicy node1_policy = 7;

    pub fn clear_node1_policy(&mut self) {
        self.node1_policy.clear();
    }

    pub fn has_node1_policy(&self) -> bool {
        self.node1_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node1_policy(&mut self, v: RoutingPolicy) {
        self.node1_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_policy(&mut self) -> &mut RoutingPolicy {
        if self.node1_policy.is_none() {
            self.node1_policy.set_default();
        }
        self.node1_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node1_policy(&mut self) -> RoutingPolicy {
        self.node1_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    pub fn get_node1_policy(&self) -> &RoutingPolicy {
        self.node1_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }

    // .lnrpc.RoutingPolicy node2_policy = 8;

    pub fn clear_node2_policy(&mut self) {
        self.node2_policy.clear();
    }

    pub fn has_node2_policy(&self) -> bool {
        self.node2_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node2_policy(&mut self, v: RoutingPolicy) {
        self.node2_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_policy(&mut self) -> &mut RoutingPolicy {
        if self.node2_policy.is_none() {
            self.node2_policy.set_default();
        }
        self.node2_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node2_policy(&mut self) -> RoutingPolicy {
        self.node2_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    pub fn get_node2_policy(&self) -> &RoutingPolicy {
        self.node2_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }
}

impl ::protobuf::Message for ChannelEdge {
    fn is_initialized(&self) -> bool {
        for v in &self.node1_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node2_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node1_pub)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node2_pub)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node1_policy)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node2_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chan_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chan_point);
        }
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.node1_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node1_pub);
        }
        if !self.node2_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.node2_pub);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if !self.chan_point.is_empty() {
            os.write_string(2, &self.chan_point)?;
        }
        if self.last_update != 0 {
            os.write_uint32(3, self.last_update)?;
        }
        if !self.node1_pub.is_empty() {
            os.write_string(4, &self.node1_pub)?;
        }
        if !self.node2_pub.is_empty() {
            os.write_string(5, &self.node2_pub)?;
        }
        if self.capacity != 0 {
            os.write_int64(6, self.capacity)?;
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEdge {
        ChannelEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "channel_id",
                    |m: &ChannelEdge| { &m.channel_id },
                    |m: &mut ChannelEdge| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chan_point",
                    |m: &ChannelEdge| { &m.chan_point },
                    |m: &mut ChannelEdge| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_update",
                    |m: &ChannelEdge| { &m.last_update },
                    |m: &mut ChannelEdge| { &mut m.last_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node1_pub",
                    |m: &ChannelEdge| { &m.node1_pub },
                    |m: &mut ChannelEdge| { &mut m.node1_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node2_pub",
                    |m: &ChannelEdge| { &m.node2_pub },
                    |m: &mut ChannelEdge| { &mut m.node2_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ChannelEdge| { &m.capacity },
                    |m: &mut ChannelEdge| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "node1_policy",
                    |m: &ChannelEdge| { &m.node1_policy },
                    |m: &mut ChannelEdge| { &mut m.node1_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "node2_policy",
                    |m: &ChannelEdge| { &m.node2_policy },
                    |m: &mut ChannelEdge| { &mut m.node2_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelEdge>(
                    "ChannelEdge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelEdge {
        static mut instance: ::protobuf::lazy::Lazy<ChannelEdge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelEdge,
        };
        unsafe {
            instance.get(ChannelEdge::new)
        }
    }
}

impl ::protobuf::Clear for ChannelEdge {
    fn clear(&mut self) {
        self.clear_channel_id();
        self.clear_chan_point();
        self.clear_last_update();
        self.clear_node1_pub();
        self.clear_node2_pub();
        self.clear_capacity();
        self.clear_node1_policy();
        self.clear_node2_policy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelGraphRequest {
    // message fields
    pub include_unannounced: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelGraphRequest {
    pub fn new() -> ChannelGraphRequest {
        ::std::default::Default::default()
    }

    // bool include_unannounced = 1;

    pub fn clear_include_unannounced(&mut self) {
        self.include_unannounced = false;
    }

    // Param is passed by value, moved
    pub fn set_include_unannounced(&mut self, v: bool) {
        self.include_unannounced = v;
    }

    pub fn get_include_unannounced(&self) -> bool {
        self.include_unannounced
    }
}

impl ::protobuf::Message for ChannelGraphRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_unannounced = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.include_unannounced != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.include_unannounced != false {
            os.write_bool(1, self.include_unannounced)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraphRequest {
        ChannelGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_unannounced",
                    |m: &ChannelGraphRequest| { &m.include_unannounced },
                    |m: &mut ChannelGraphRequest| { &mut m.include_unannounced },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelGraphRequest>(
                    "ChannelGraphRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelGraphRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChannelGraphRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelGraphRequest,
        };
        unsafe {
            instance.get(ChannelGraphRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChannelGraphRequest {
    fn clear(&mut self) {
        self.clear_include_unannounced();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelGraph {
    // message fields
    pub nodes: ::protobuf::RepeatedField<LightningNode>,
    pub edges: ::protobuf::RepeatedField<ChannelEdge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelGraph {
    pub fn new() -> ChannelGraph {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.LightningNode nodes = 1;

    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<LightningNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<LightningNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<LightningNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    pub fn get_nodes(&self) -> &[LightningNode] {
        &self.nodes
    }

    // repeated .lnrpc.ChannelEdge edges = 2;

    pub fn clear_edges(&mut self) {
        self.edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_edges(&mut self, v: ::protobuf::RepeatedField<ChannelEdge>) {
        self.edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edges(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdge> {
        &mut self.edges
    }

    // Take field
    pub fn take_edges(&mut self) -> ::protobuf::RepeatedField<ChannelEdge> {
        ::std::mem::replace(&mut self.edges, ::protobuf::RepeatedField::new())
    }

    pub fn get_edges(&self) -> &[ChannelEdge] {
        &self.edges
    }
}

impl ::protobuf::Message for ChannelGraph {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraph {
        ChannelGraph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningNode>>(
                    "nodes",
                    |m: &ChannelGraph| { &m.nodes },
                    |m: &mut ChannelGraph| { &mut m.nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdge>>(
                    "edges",
                    |m: &ChannelGraph| { &m.edges },
                    |m: &mut ChannelGraph| { &mut m.edges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelGraph>(
                    "ChannelGraph",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelGraph {
        static mut instance: ::protobuf::lazy::Lazy<ChannelGraph> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelGraph,
        };
        unsafe {
            instance.get(ChannelGraph::new)
        }
    }
}

impl ::protobuf::Clear for ChannelGraph {
    fn clear(&mut self) {
        self.clear_nodes();
        self.clear_edges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraph {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChanInfoRequest {
    // message fields
    pub chan_id: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChanInfoRequest {
    pub fn new() -> ChanInfoRequest {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
}

impl ::protobuf::Message for ChanInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanInfoRequest {
        ChanInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ChanInfoRequest| { &m.chan_id },
                    |m: &mut ChanInfoRequest| { &mut m.chan_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChanInfoRequest>(
                    "ChanInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChanInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChanInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChanInfoRequest,
        };
        unsafe {
            instance.get(ChanInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChanInfoRequest {
    fn clear(&mut self) {
        self.clear_chan_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkInfoRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NetworkInfoRequest {
    pub fn new() -> NetworkInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NetworkInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkInfoRequest {
        NetworkInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfoRequest>(
                    "NetworkInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NetworkInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfoRequest,
        };
        unsafe {
            instance.get(NetworkInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for NetworkInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkInfo {
    // message fields
    pub graph_diameter: u32,
    pub avg_out_degree: f64,
    pub max_out_degree: u32,
    pub num_nodes: u32,
    pub num_channels: u32,
    pub total_network_capacity: i64,
    pub avg_channel_size: f64,
    pub min_channel_size: i64,
    pub max_channel_size: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NetworkInfo {
    pub fn new() -> NetworkInfo {
        ::std::default::Default::default()
    }

    // uint32 graph_diameter = 1;

    pub fn clear_graph_diameter(&mut self) {
        self.graph_diameter = 0;
    }

    // Param is passed by value, moved
    pub fn set_graph_diameter(&mut self, v: u32) {
        self.graph_diameter = v;
    }

    pub fn get_graph_diameter(&self) -> u32 {
        self.graph_diameter
    }

    // double avg_out_degree = 2;

    pub fn clear_avg_out_degree(&mut self) {
        self.avg_out_degree = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_out_degree(&mut self, v: f64) {
        self.avg_out_degree = v;
    }

    pub fn get_avg_out_degree(&self) -> f64 {
        self.avg_out_degree
    }

    // uint32 max_out_degree = 3;

    pub fn clear_max_out_degree(&mut self) {
        self.max_out_degree = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_out_degree(&mut self, v: u32) {
        self.max_out_degree = v;
    }

    pub fn get_max_out_degree(&self) -> u32 {
        self.max_out_degree
    }

    // uint32 num_nodes = 4;

    pub fn clear_num_nodes(&mut self) {
        self.num_nodes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_nodes(&mut self, v: u32) {
        self.num_nodes = v;
    }

    pub fn get_num_nodes(&self) -> u32 {
        self.num_nodes
    }

    // uint32 num_channels = 5;

    pub fn clear_num_channels(&mut self) {
        self.num_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_channels(&mut self, v: u32) {
        self.num_channels = v;
    }

    pub fn get_num_channels(&self) -> u32 {
        self.num_channels
    }

    // int64 total_network_capacity = 6;

    pub fn clear_total_network_capacity(&mut self) {
        self.total_network_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_network_capacity(&mut self, v: i64) {
        self.total_network_capacity = v;
    }

    pub fn get_total_network_capacity(&self) -> i64 {
        self.total_network_capacity
    }

    // double avg_channel_size = 7;

    pub fn clear_avg_channel_size(&mut self) {
        self.avg_channel_size = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_channel_size(&mut self, v: f64) {
        self.avg_channel_size = v;
    }

    pub fn get_avg_channel_size(&self) -> f64 {
        self.avg_channel_size
    }

    // int64 min_channel_size = 8;

    pub fn clear_min_channel_size(&mut self) {
        self.min_channel_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_channel_size(&mut self, v: i64) {
        self.min_channel_size = v;
    }

    pub fn get_min_channel_size(&self) -> i64 {
        self.min_channel_size
    }

    // int64 max_channel_size = 9;

    pub fn clear_max_channel_size(&mut self) {
        self.max_channel_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_channel_size(&mut self, v: i64) {
        self.max_channel_size = v;
    }

    pub fn get_max_channel_size(&self) -> i64 {
        self.max_channel_size
    }
}

impl ::protobuf::Message for NetworkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.graph_diameter = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_out_degree = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_out_degree = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_nodes = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_channels = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_network_capacity = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_channel_size = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_channel_size = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_channel_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.graph_diameter != 0 {
            my_size += ::protobuf::rt::value_size(1, self.graph_diameter, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_out_degree != 0. {
            my_size += 9;
        }
        if self.max_out_degree != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_out_degree, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_nodes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_nodes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_network_capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.total_network_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_channel_size != 0. {
            my_size += 9;
        }
        if self.min_channel_size != 0 {
            my_size += ::protobuf::rt::value_size(8, self.min_channel_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_channel_size != 0 {
            my_size += ::protobuf::rt::value_size(9, self.max_channel_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.graph_diameter != 0 {
            os.write_uint32(1, self.graph_diameter)?;
        }
        if self.avg_out_degree != 0. {
            os.write_double(2, self.avg_out_degree)?;
        }
        if self.max_out_degree != 0 {
            os.write_uint32(3, self.max_out_degree)?;
        }
        if self.num_nodes != 0 {
            os.write_uint32(4, self.num_nodes)?;
        }
        if self.num_channels != 0 {
            os.write_uint32(5, self.num_channels)?;
        }
        if self.total_network_capacity != 0 {
            os.write_int64(6, self.total_network_capacity)?;
        }
        if self.avg_channel_size != 0. {
            os.write_double(7, self.avg_channel_size)?;
        }
        if self.min_channel_size != 0 {
            os.write_int64(8, self.min_channel_size)?;
        }
        if self.max_channel_size != 0 {
            os.write_int64(9, self.max_channel_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkInfo {
        NetworkInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "graph_diameter",
                    |m: &NetworkInfo| { &m.graph_diameter },
                    |m: &mut NetworkInfo| { &mut m.graph_diameter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "avg_out_degree",
                    |m: &NetworkInfo| { &m.avg_out_degree },
                    |m: &mut NetworkInfo| { &mut m.avg_out_degree },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_out_degree",
                    |m: &NetworkInfo| { &m.max_out_degree },
                    |m: &mut NetworkInfo| { &mut m.max_out_degree },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_nodes",
                    |m: &NetworkInfo| { &m.num_nodes },
                    |m: &mut NetworkInfo| { &mut m.num_nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_channels",
                    |m: &NetworkInfo| { &m.num_channels },
                    |m: &mut NetworkInfo| { &mut m.num_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_network_capacity",
                    |m: &NetworkInfo| { &m.total_network_capacity },
                    |m: &mut NetworkInfo| { &mut m.total_network_capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "avg_channel_size",
                    |m: &NetworkInfo| { &m.avg_channel_size },
                    |m: &mut NetworkInfo| { &mut m.avg_channel_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_channel_size",
                    |m: &NetworkInfo| { &m.min_channel_size },
                    |m: &mut NetworkInfo| { &mut m.min_channel_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_channel_size",
                    |m: &NetworkInfo| { &m.max_channel_size },
                    |m: &mut NetworkInfo| { &mut m.max_channel_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfo>(
                    "NetworkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NetworkInfo {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfo,
        };
        unsafe {
            instance.get(NetworkInfo::new)
        }
    }
}

impl ::protobuf::Clear for NetworkInfo {
    fn clear(&mut self) {
        self.clear_graph_diameter();
        self.clear_avg_out_degree();
        self.clear_max_out_degree();
        self.clear_num_nodes();
        self.clear_num_channels();
        self.clear_total_network_capacity();
        self.clear_avg_channel_size();
        self.clear_min_channel_size();
        self.clear_max_channel_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StopRequest {
    pub fn new() -> StopRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopRequest {
        StopRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopRequest>(
                    "StopRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopRequest,
        };
        unsafe {
            instance.get(StopRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StopResponse {
    pub fn new() -> StopResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopResponse {
        StopResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopResponse>(
                    "StopResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopResponse {
        static mut instance: ::protobuf::lazy::Lazy<StopResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopResponse,
        };
        unsafe {
            instance.get(StopResponse::new)
        }
    }
}

impl ::protobuf::Clear for StopResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphTopologySubscription {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GraphTopologySubscription {
    pub fn new() -> GraphTopologySubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GraphTopologySubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphTopologySubscription {
        GraphTopologySubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GraphTopologySubscription>(
                    "GraphTopologySubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphTopologySubscription {
        static mut instance: ::protobuf::lazy::Lazy<GraphTopologySubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphTopologySubscription,
        };
        unsafe {
            instance.get(GraphTopologySubscription::new)
        }
    }
}

impl ::protobuf::Clear for GraphTopologySubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphTopologySubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphTopologySubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphTopologyUpdate {
    // message fields
    pub node_updates: ::protobuf::RepeatedField<NodeUpdate>,
    pub channel_updates: ::protobuf::RepeatedField<ChannelEdgeUpdate>,
    pub closed_chans: ::protobuf::RepeatedField<ClosedChannelUpdate>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GraphTopologyUpdate {
    pub fn new() -> GraphTopologyUpdate {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.NodeUpdate node_updates = 1;

    pub fn clear_node_updates(&mut self) {
        self.node_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_updates(&mut self, v: ::protobuf::RepeatedField<NodeUpdate>) {
        self.node_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_updates(&mut self) -> &mut ::protobuf::RepeatedField<NodeUpdate> {
        &mut self.node_updates
    }

    // Take field
    pub fn take_node_updates(&mut self) -> ::protobuf::RepeatedField<NodeUpdate> {
        ::std::mem::replace(&mut self.node_updates, ::protobuf::RepeatedField::new())
    }

    pub fn get_node_updates(&self) -> &[NodeUpdate] {
        &self.node_updates
    }

    // repeated .lnrpc.ChannelEdgeUpdate channel_updates = 2;

    pub fn clear_channel_updates(&mut self) {
        self.channel_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_updates(&mut self, v: ::protobuf::RepeatedField<ChannelEdgeUpdate>) {
        self.channel_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_updates(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdgeUpdate> {
        &mut self.channel_updates
    }

    // Take field
    pub fn take_channel_updates(&mut self) -> ::protobuf::RepeatedField<ChannelEdgeUpdate> {
        ::std::mem::replace(&mut self.channel_updates, ::protobuf::RepeatedField::new())
    }

    pub fn get_channel_updates(&self) -> &[ChannelEdgeUpdate] {
        &self.channel_updates
    }

    // repeated .lnrpc.ClosedChannelUpdate closed_chans = 3;

    pub fn clear_closed_chans(&mut self) {
        self.closed_chans.clear();
    }

    // Param is passed by value, moved
    pub fn set_closed_chans(&mut self, v: ::protobuf::RepeatedField<ClosedChannelUpdate>) {
        self.closed_chans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_closed_chans(&mut self) -> &mut ::protobuf::RepeatedField<ClosedChannelUpdate> {
        &mut self.closed_chans
    }

    // Take field
    pub fn take_closed_chans(&mut self) -> ::protobuf::RepeatedField<ClosedChannelUpdate> {
        ::std::mem::replace(&mut self.closed_chans, ::protobuf::RepeatedField::new())
    }

    pub fn get_closed_chans(&self) -> &[ClosedChannelUpdate] {
        &self.closed_chans
    }
}

impl ::protobuf::Message for GraphTopologyUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.node_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.closed_chans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node_updates)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_updates)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.closed_chans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.channel_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.closed_chans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node_updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.channel_updates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.closed_chans {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphTopologyUpdate {
        GraphTopologyUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeUpdate>>(
                    "node_updates",
                    |m: &GraphTopologyUpdate| { &m.node_updates },
                    |m: &mut GraphTopologyUpdate| { &mut m.node_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdgeUpdate>>(
                    "channel_updates",
                    |m: &GraphTopologyUpdate| { &m.channel_updates },
                    |m: &mut GraphTopologyUpdate| { &mut m.channel_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClosedChannelUpdate>>(
                    "closed_chans",
                    |m: &GraphTopologyUpdate| { &m.closed_chans },
                    |m: &mut GraphTopologyUpdate| { &mut m.closed_chans },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphTopologyUpdate>(
                    "GraphTopologyUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphTopologyUpdate {
        static mut instance: ::protobuf::lazy::Lazy<GraphTopologyUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphTopologyUpdate,
        };
        unsafe {
            instance.get(GraphTopologyUpdate::new)
        }
    }
}

impl ::protobuf::Clear for GraphTopologyUpdate {
    fn clear(&mut self) {
        self.clear_node_updates();
        self.clear_channel_updates();
        self.clear_closed_chans();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphTopologyUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphTopologyUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeUpdate {
    // message fields
    pub addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub identity_key: ::std::string::String,
    pub global_features: ::std::vec::Vec<u8>,
    pub alias: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl NodeUpdate {
    pub fn new() -> NodeUpdate {
        ::std::default::Default::default()
    }

    // repeated string addresses = 1;

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_addresses(&self) -> &[::std::string::String] {
        &self.addresses
    }

    // string identity_key = 2;

    pub fn clear_identity_key(&mut self) {
        self.identity_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_key(&mut self, v: ::std::string::String) {
        self.identity_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_key(&mut self) -> &mut ::std::string::String {
        &mut self.identity_key
    }

    // Take field
    pub fn take_identity_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_key, ::std::string::String::new())
    }

    pub fn get_identity_key(&self) -> &str {
        &self.identity_key
    }

    // bytes global_features = 3;

    pub fn clear_global_features(&mut self) {
        self.global_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_global_features(&mut self, v: ::std::vec::Vec<u8>) {
        self.global_features = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_features(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.global_features
    }

    // Take field
    pub fn take_global_features(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.global_features, ::std::vec::Vec::new())
    }

    pub fn get_global_features(&self) -> &[u8] {
        &self.global_features
    }

    // string alias = 4;

    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    pub fn get_alias(&self) -> &str {
        &self.alias
    }
}

impl ::protobuf::Message for NodeUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.global_features)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.identity_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity_key);
        }
        if !self.global_features.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.global_features);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.alias);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_string(1, &v)?;
        };
        if !self.identity_key.is_empty() {
            os.write_string(2, &self.identity_key)?;
        }
        if !self.global_features.is_empty() {
            os.write_bytes(3, &self.global_features)?;
        }
        if !self.alias.is_empty() {
            os.write_string(4, &self.alias)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeUpdate {
        NodeUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addresses",
                    |m: &NodeUpdate| { &m.addresses },
                    |m: &mut NodeUpdate| { &mut m.addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity_key",
                    |m: &NodeUpdate| { &m.identity_key },
                    |m: &mut NodeUpdate| { &mut m.identity_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "global_features",
                    |m: &NodeUpdate| { &m.global_features },
                    |m: &mut NodeUpdate| { &mut m.global_features },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &NodeUpdate| { &m.alias },
                    |m: &mut NodeUpdate| { &mut m.alias },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeUpdate>(
                    "NodeUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeUpdate {
        static mut instance: ::protobuf::lazy::Lazy<NodeUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeUpdate,
        };
        unsafe {
            instance.get(NodeUpdate::new)
        }
    }
}

impl ::protobuf::Clear for NodeUpdate {
    fn clear(&mut self) {
        self.clear_addresses();
        self.clear_identity_key();
        self.clear_global_features();
        self.clear_alias();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelEdgeUpdate {
    // message fields
    pub chan_id: u64,
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub capacity: i64,
    pub routing_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    pub advertising_node: ::std::string::String,
    pub connecting_node: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelEdgeUpdate {
    pub fn new() -> ChannelEdgeUpdate {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }

    // .lnrpc.ChannelPoint chan_point = 2;

    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }

    // int64 capacity = 3;

    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }

    // .lnrpc.RoutingPolicy routing_policy = 4;

    pub fn clear_routing_policy(&mut self) {
        self.routing_policy.clear();
    }

    pub fn has_routing_policy(&self) -> bool {
        self.routing_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_policy(&mut self, v: RoutingPolicy) {
        self.routing_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routing_policy(&mut self) -> &mut RoutingPolicy {
        if self.routing_policy.is_none() {
            self.routing_policy.set_default();
        }
        self.routing_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_routing_policy(&mut self) -> RoutingPolicy {
        self.routing_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    pub fn get_routing_policy(&self) -> &RoutingPolicy {
        self.routing_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }

    // string advertising_node = 5;

    pub fn clear_advertising_node(&mut self) {
        self.advertising_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_advertising_node(&mut self, v: ::std::string::String) {
        self.advertising_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_advertising_node(&mut self) -> &mut ::std::string::String {
        &mut self.advertising_node
    }

    // Take field
    pub fn take_advertising_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.advertising_node, ::std::string::String::new())
    }

    pub fn get_advertising_node(&self) -> &str {
        &self.advertising_node
    }

    // string connecting_node = 6;

    pub fn clear_connecting_node(&mut self) {
        self.connecting_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_connecting_node(&mut self, v: ::std::string::String) {
        self.connecting_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connecting_node(&mut self) -> &mut ::std::string::String {
        &mut self.connecting_node
    }

    // Take field
    pub fn take_connecting_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.connecting_node, ::std::string::String::new())
    }

    pub fn get_connecting_node(&self) -> &str {
        &self.connecting_node
    }
}

impl ::protobuf::Message for ChannelEdgeUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routing_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routing_policy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.advertising_node)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.connecting_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routing_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.advertising_node.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.advertising_node);
        }
        if !self.connecting_node.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.connecting_node);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.capacity != 0 {
            os.write_int64(3, self.capacity)?;
        }
        if let Some(ref v) = self.routing_policy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.advertising_node.is_empty() {
            os.write_string(5, &self.advertising_node)?;
        }
        if !self.connecting_node.is_empty() {
            os.write_string(6, &self.connecting_node)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEdgeUpdate {
        ChannelEdgeUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ChannelEdgeUpdate| { &m.chan_id },
                    |m: &mut ChannelEdgeUpdate| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "chan_point",
                    |m: &ChannelEdgeUpdate| { &m.chan_point },
                    |m: &mut ChannelEdgeUpdate| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ChannelEdgeUpdate| { &m.capacity },
                    |m: &mut ChannelEdgeUpdate| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "routing_policy",
                    |m: &ChannelEdgeUpdate| { &m.routing_policy },
                    |m: &mut ChannelEdgeUpdate| { &mut m.routing_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "advertising_node",
                    |m: &ChannelEdgeUpdate| { &m.advertising_node },
                    |m: &mut ChannelEdgeUpdate| { &mut m.advertising_node },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "connecting_node",
                    |m: &ChannelEdgeUpdate| { &m.connecting_node },
                    |m: &mut ChannelEdgeUpdate| { &mut m.connecting_node },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelEdgeUpdate>(
                    "ChannelEdgeUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelEdgeUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelEdgeUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelEdgeUpdate,
        };
        unsafe {
            instance.get(ChannelEdgeUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelEdgeUpdate {
    fn clear(&mut self) {
        self.clear_chan_id();
        self.clear_chan_point();
        self.clear_capacity();
        self.clear_routing_policy();
        self.clear_advertising_node();
        self.clear_connecting_node();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEdgeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEdgeUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClosedChannelUpdate {
    // message fields
    pub chan_id: u64,
    pub capacity: i64,
    pub closed_height: u32,
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ClosedChannelUpdate {
    pub fn new() -> ClosedChannelUpdate {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }

    // int64 capacity = 2;

    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }

    // uint32 closed_height = 3;

    pub fn clear_closed_height(&mut self) {
        self.closed_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_closed_height(&mut self, v: u32) {
        self.closed_height = v;
    }

    pub fn get_closed_height(&self) -> u32 {
        self.closed_height
    }

    // .lnrpc.ChannelPoint chan_point = 4;

    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
}

impl ::protobuf::Message for ClosedChannelUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.closed_height = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.closed_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.closed_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.capacity != 0 {
            os.write_int64(2, self.capacity)?;
        }
        if self.closed_height != 0 {
            os.write_uint32(3, self.closed_height)?;
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelUpdate {
        ClosedChannelUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ClosedChannelUpdate| { &m.chan_id },
                    |m: &mut ClosedChannelUpdate| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ClosedChannelUpdate| { &m.capacity },
                    |m: &mut ClosedChannelUpdate| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "closed_height",
                    |m: &ClosedChannelUpdate| { &m.closed_height },
                    |m: &mut ClosedChannelUpdate| { &mut m.closed_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "chan_point",
                    |m: &ClosedChannelUpdate| { &m.chan_point },
                    |m: &mut ClosedChannelUpdate| { &mut m.chan_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClosedChannelUpdate>(
                    "ClosedChannelUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClosedChannelUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ClosedChannelUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClosedChannelUpdate,
        };
        unsafe {
            instance.get(ClosedChannelUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ClosedChannelUpdate {
    fn clear(&mut self) {
        self.clear_chan_id();
        self.clear_capacity();
        self.clear_closed_height();
        self.clear_chan_point();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HopHint {
    // message fields
    pub node_id: ::std::string::String,
    pub chan_id: u64,
    pub fee_base_msat: u32,
    pub fee_proportional_millionths: u32,
    pub cltv_expiry_delta: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl HopHint {
    pub fn new() -> HopHint {
        ::std::default::Default::default()
    }

    // string node_id = 1;

    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }

    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }

    // uint64 chan_id = 2;

    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }

    // uint32 fee_base_msat = 3;

    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: u32) {
        self.fee_base_msat = v;
    }

    pub fn get_fee_base_msat(&self) -> u32 {
        self.fee_base_msat
    }

    // uint32 fee_proportional_millionths = 4;

    pub fn clear_fee_proportional_millionths(&mut self) {
        self.fee_proportional_millionths = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_proportional_millionths(&mut self, v: u32) {
        self.fee_proportional_millionths = v;
    }

    pub fn get_fee_proportional_millionths(&self) -> u32 {
        self.fee_proportional_millionths
    }

    // uint32 cltv_expiry_delta = 5;

    pub fn clear_cltv_expiry_delta(&mut self) {
        self.cltv_expiry_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry_delta(&mut self, v: u32) {
        self.cltv_expiry_delta = v;
    }

    pub fn get_cltv_expiry_delta(&self) -> u32 {
        self.cltv_expiry_delta
    }
}

impl ::protobuf::Message for HopHint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_base_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_proportional_millionths = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_expiry_delta = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_base_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_base_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_proportional_millionths != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee_proportional_millionths, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cltv_expiry_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.cltv_expiry_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(2, self.chan_id)?;
        }
        if self.fee_base_msat != 0 {
            os.write_uint32(3, self.fee_base_msat)?;
        }
        if self.fee_proportional_millionths != 0 {
            os.write_uint32(4, self.fee_proportional_millionths)?;
        }
        if self.cltv_expiry_delta != 0 {
            os.write_uint32(5, self.cltv_expiry_delta)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HopHint {
        HopHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node_id",
                    |m: &HopHint| { &m.node_id },
                    |m: &mut HopHint| { &mut m.node_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &HopHint| { &m.chan_id },
                    |m: &mut HopHint| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fee_base_msat",
                    |m: &HopHint| { &m.fee_base_msat },
                    |m: &mut HopHint| { &mut m.fee_base_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fee_proportional_millionths",
                    |m: &HopHint| { &m.fee_proportional_millionths },
                    |m: &mut HopHint| { &mut m.fee_proportional_millionths },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cltv_expiry_delta",
                    |m: &HopHint| { &m.cltv_expiry_delta },
                    |m: &mut HopHint| { &mut m.cltv_expiry_delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HopHint>(
                    "HopHint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HopHint {
        static mut instance: ::protobuf::lazy::Lazy<HopHint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HopHint,
        };
        unsafe {
            instance.get(HopHint::new)
        }
    }
}

impl ::protobuf::Clear for HopHint {
    fn clear(&mut self) {
        self.clear_node_id();
        self.clear_chan_id();
        self.clear_fee_base_msat();
        self.clear_fee_proportional_millionths();
        self.clear_cltv_expiry_delta();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HopHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HopHint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteHint {
    // message fields
    pub hop_hints: ::protobuf::RepeatedField<HopHint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RouteHint {
    pub fn new() -> RouteHint {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.HopHint hop_hints = 1;

    pub fn clear_hop_hints(&mut self) {
        self.hop_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_hop_hints(&mut self, v: ::protobuf::RepeatedField<HopHint>) {
        self.hop_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hop_hints(&mut self) -> &mut ::protobuf::RepeatedField<HopHint> {
        &mut self.hop_hints
    }

    // Take field
    pub fn take_hop_hints(&mut self) -> ::protobuf::RepeatedField<HopHint> {
        ::std::mem::replace(&mut self.hop_hints, ::protobuf::RepeatedField::new())
    }

    pub fn get_hop_hints(&self) -> &[HopHint] {
        &self.hop_hints
    }
}

impl ::protobuf::Message for RouteHint {
    fn is_initialized(&self) -> bool {
        for v in &self.hop_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hop_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hop_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hop_hints {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteHint {
        RouteHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HopHint>>(
                    "hop_hints",
                    |m: &RouteHint| { &m.hop_hints },
                    |m: &mut RouteHint| { &mut m.hop_hints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteHint>(
                    "RouteHint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteHint {
        static mut instance: ::protobuf::lazy::Lazy<RouteHint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteHint,
        };
        unsafe {
            instance.get(RouteHint::new)
        }
    }
}

impl ::protobuf::Clear for RouteHint {
    fn clear(&mut self) {
        self.clear_hop_hints();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteHint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Invoice {
    // message fields
    pub memo: ::std::string::String,
    pub receipt: ::std::vec::Vec<u8>,
    pub r_preimage: ::std::vec::Vec<u8>,
    pub r_hash: ::std::vec::Vec<u8>,
    pub value: i64,
    pub settled: bool,
    pub creation_date: i64,
    pub settle_date: i64,
    pub payment_request: ::std::string::String,
    pub description_hash: ::std::vec::Vec<u8>,
    pub expiry: i64,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: u64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    pub private: bool,
    pub add_index: u64,
    pub settle_index: u64,
    pub amt_paid: i64,
    pub amt_paid_sat: i64,
    pub amt_paid_msat: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Invoice {
    pub fn new() -> Invoice {
        ::std::default::Default::default()
    }

    // string memo = 1;

    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::string::String) {
        self.memo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::string::String {
        &mut self.memo
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.memo, ::std::string::String::new())
    }

    pub fn get_memo(&self) -> &str {
        &self.memo
    }

    // bytes receipt = 2;

    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ::std::vec::Vec<u8>) {
        self.receipt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receipt
    }

    // Take field
    pub fn take_receipt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receipt, ::std::vec::Vec::new())
    }

    pub fn get_receipt(&self) -> &[u8] {
        &self.receipt
    }

    // bytes r_preimage = 3;

    pub fn clear_r_preimage(&mut self) {
        self.r_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_preimage
    }

    // Take field
    pub fn take_r_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_preimage, ::std::vec::Vec::new())
    }

    pub fn get_r_preimage(&self) -> &[u8] {
        &self.r_preimage
    }

    // bytes r_hash = 4;

    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }

    // int64 value = 5;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    pub fn get_value(&self) -> i64 {
        self.value
    }

    // bool settled = 6;

    pub fn clear_settled(&mut self) {
        self.settled = false;
    }

    // Param is passed by value, moved
    pub fn set_settled(&mut self, v: bool) {
        self.settled = v;
    }

    pub fn get_settled(&self) -> bool {
        self.settled
    }

    // int64 creation_date = 7;

    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }

    // int64 settle_date = 8;

    pub fn clear_settle_date(&mut self) {
        self.settle_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_date(&mut self, v: i64) {
        self.settle_date = v;
    }

    pub fn get_settle_date(&self) -> i64 {
        self.settle_date
    }

    // string payment_request = 9;

    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }

    // bytes description_hash = 10;

    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description_hash, ::std::vec::Vec::new())
    }

    pub fn get_description_hash(&self) -> &[u8] {
        &self.description_hash
    }

    // int64 expiry = 11;

    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }

    // string fallback_addr = 12;

    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }

    // uint64 cltv_expiry = 13;

    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: u64) {
        self.cltv_expiry = v;
    }

    pub fn get_cltv_expiry(&self) -> u64 {
        self.cltv_expiry
    }

    // repeated .lnrpc.RouteHint route_hints = 14;

    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }

    // bool private = 15;

    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    pub fn get_private(&self) -> bool {
        self.private
    }

    // uint64 add_index = 16;

    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }

    // uint64 settle_index = 17;

    pub fn clear_settle_index(&mut self) {
        self.settle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_index(&mut self, v: u64) {
        self.settle_index = v;
    }

    pub fn get_settle_index(&self) -> u64 {
        self.settle_index
    }

    // int64 amt_paid = 18;

    pub fn clear_amt_paid(&mut self) {
        self.amt_paid = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid(&mut self, v: i64) {
        self.amt_paid = v;
    }

    pub fn get_amt_paid(&self) -> i64 {
        self.amt_paid
    }

    // int64 amt_paid_sat = 19;

    pub fn clear_amt_paid_sat(&mut self) {
        self.amt_paid_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_sat(&mut self, v: i64) {
        self.amt_paid_sat = v;
    }

    pub fn get_amt_paid_sat(&self) -> i64 {
        self.amt_paid_sat
    }

    // int64 amt_paid_msat = 20;

    pub fn clear_amt_paid_msat(&mut self) {
        self.amt_paid_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_msat(&mut self, v: i64) {
        self.amt_paid_msat = v;
    }

    pub fn get_amt_paid_msat(&self) -> i64 {
        self.amt_paid_msat
    }
}

impl ::protobuf::Message for Invoice {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.memo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receipt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_preimage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.settled = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settle_date = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description_hash)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cltv_expiry = tmp;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_index = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_sat = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.memo.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.memo);
        }
        if !self.receipt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.receipt);
        }
        if !self.r_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.r_preimage);
        }
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.r_hash);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settled != false {
            my_size += 2;
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(7, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_date != 0 {
            my_size += ::protobuf::rt::value_size(8, self.settle_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.payment_request);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.description_hash);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(11, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(13, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.private != false {
            my_size += 2;
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_index != 0 {
            my_size += ::protobuf::rt::value_size(17, self.settle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid != 0 {
            my_size += ::protobuf::rt::value_size(18, self.amt_paid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_sat != 0 {
            my_size += ::protobuf::rt::value_size(19, self.amt_paid_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_msat != 0 {
            my_size += ::protobuf::rt::value_size(20, self.amt_paid_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.memo.is_empty() {
            os.write_string(1, &self.memo)?;
        }
        if !self.receipt.is_empty() {
            os.write_bytes(2, &self.receipt)?;
        }
        if !self.r_preimage.is_empty() {
            os.write_bytes(3, &self.r_preimage)?;
        }
        if !self.r_hash.is_empty() {
            os.write_bytes(4, &self.r_hash)?;
        }
        if self.value != 0 {
            os.write_int64(5, self.value)?;
        }
        if self.settled != false {
            os.write_bool(6, self.settled)?;
        }
        if self.creation_date != 0 {
            os.write_int64(7, self.creation_date)?;
        }
        if self.settle_date != 0 {
            os.write_int64(8, self.settle_date)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(9, &self.payment_request)?;
        }
        if !self.description_hash.is_empty() {
            os.write_bytes(10, &self.description_hash)?;
        }
        if self.expiry != 0 {
            os.write_int64(11, self.expiry)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(12, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_uint64(13, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.private != false {
            os.write_bool(15, self.private)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        if self.settle_index != 0 {
            os.write_uint64(17, self.settle_index)?;
        }
        if self.amt_paid != 0 {
            os.write_int64(18, self.amt_paid)?;
        }
        if self.amt_paid_sat != 0 {
            os.write_int64(19, self.amt_paid_sat)?;
        }
        if self.amt_paid_msat != 0 {
            os.write_int64(20, self.amt_paid_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Invoice {
        Invoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "memo",
                    |m: &Invoice| { &m.memo },
                    |m: &mut Invoice| { &mut m.memo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receipt",
                    |m: &Invoice| { &m.receipt },
                    |m: &mut Invoice| { &mut m.receipt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_preimage",
                    |m: &Invoice| { &m.r_preimage },
                    |m: &mut Invoice| { &mut m.r_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &Invoice| { &m.r_hash },
                    |m: &mut Invoice| { &mut m.r_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &Invoice| { &m.value },
                    |m: &mut Invoice| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "settled",
                    |m: &Invoice| { &m.settled },
                    |m: &mut Invoice| { &mut m.settled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "creation_date",
                    |m: &Invoice| { &m.creation_date },
                    |m: &mut Invoice| { &mut m.creation_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "settle_date",
                    |m: &Invoice| { &m.settle_date },
                    |m: &mut Invoice| { &mut m.settle_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &Invoice| { &m.payment_request },
                    |m: &mut Invoice| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "description_hash",
                    |m: &Invoice| { &m.description_hash },
                    |m: &mut Invoice| { &mut m.description_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiry",
                    |m: &Invoice| { &m.expiry },
                    |m: &mut Invoice| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fallback_addr",
                    |m: &Invoice| { &m.fallback_addr },
                    |m: &mut Invoice| { &mut m.fallback_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cltv_expiry",
                    |m: &Invoice| { &m.cltv_expiry },
                    |m: &mut Invoice| { &mut m.cltv_expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                    "route_hints",
                    |m: &Invoice| { &m.route_hints },
                    |m: &mut Invoice| { &mut m.route_hints },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &Invoice| { &m.private },
                    |m: &mut Invoice| { &mut m.private },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &Invoice| { &m.add_index },
                    |m: &mut Invoice| { &mut m.add_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settle_index",
                    |m: &Invoice| { &m.settle_index },
                    |m: &mut Invoice| { &mut m.settle_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid",
                    |m: &Invoice| { &m.amt_paid },
                    |m: &mut Invoice| { &mut m.amt_paid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid_sat",
                    |m: &Invoice| { &m.amt_paid_sat },
                    |m: &mut Invoice| { &mut m.amt_paid_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid_msat",
                    |m: &Invoice| { &m.amt_paid_msat },
                    |m: &mut Invoice| { &mut m.amt_paid_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Invoice>(
                    "Invoice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Invoice {
        static mut instance: ::protobuf::lazy::Lazy<Invoice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Invoice,
        };
        unsafe {
            instance.get(Invoice::new)
        }
    }
}

impl ::protobuf::Clear for Invoice {
    fn clear(&mut self) {
        self.clear_memo();
        self.clear_receipt();
        self.clear_r_preimage();
        self.clear_r_hash();
        self.clear_value();
        self.clear_settled();
        self.clear_creation_date();
        self.clear_settle_date();
        self.clear_payment_request();
        self.clear_description_hash();
        self.clear_expiry();
        self.clear_fallback_addr();
        self.clear_cltv_expiry();
        self.clear_route_hints();
        self.clear_private();
        self.clear_add_index();
        self.clear_settle_index();
        self.clear_amt_paid();
        self.clear_amt_paid_sat();
        self.clear_amt_paid_msat();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Invoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Invoice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddInvoiceResponse {
    // message fields
    pub r_hash: ::std::vec::Vec<u8>,
    pub payment_request: ::std::string::String,
    pub add_index: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AddInvoiceResponse {
    pub fn new() -> AddInvoiceResponse {
        ::std::default::Default::default()
    }

    // bytes r_hash = 1;

    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }

    // string payment_request = 2;

    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }

    // uint64 add_index = 16;

    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
}

impl ::protobuf::Message for AddInvoiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.r_hash);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_request);
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.r_hash.is_empty() {
            os.write_bytes(1, &self.r_hash)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(2, &self.payment_request)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddInvoiceResponse {
        AddInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &AddInvoiceResponse| { &m.r_hash },
                    |m: &mut AddInvoiceResponse| { &mut m.r_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &AddInvoiceResponse| { &m.payment_request },
                    |m: &mut AddInvoiceResponse| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &AddInvoiceResponse| { &m.add_index },
                    |m: &mut AddInvoiceResponse| { &mut m.add_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddInvoiceResponse>(
                    "AddInvoiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddInvoiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddInvoiceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddInvoiceResponse,
        };
        unsafe {
            instance.get(AddInvoiceResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddInvoiceResponse {
    fn clear(&mut self) {
        self.clear_r_hash();
        self.clear_payment_request();
        self.clear_add_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentHash {
    // message fields
    pub r_hash_str: ::std::string::String,
    pub r_hash: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PaymentHash {
    pub fn new() -> PaymentHash {
        ::std::default::Default::default()
    }

    // string r_hash_str = 1;

    pub fn clear_r_hash_str(&mut self) {
        self.r_hash_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash_str(&mut self, v: ::std::string::String) {
        self.r_hash_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash_str(&mut self) -> &mut ::std::string::String {
        &mut self.r_hash_str
    }

    // Take field
    pub fn take_r_hash_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.r_hash_str, ::std::string::String::new())
    }

    pub fn get_r_hash_str(&self) -> &str {
        &self.r_hash_str
    }

    // bytes r_hash = 2;

    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }
}

impl ::protobuf::Message for PaymentHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.r_hash_str)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.r_hash_str.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.r_hash_str);
        }
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.r_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.r_hash_str.is_empty() {
            os.write_string(1, &self.r_hash_str)?;
        }
        if !self.r_hash.is_empty() {
            os.write_bytes(2, &self.r_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentHash {
        PaymentHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "r_hash_str",
                    |m: &PaymentHash| { &m.r_hash_str },
                    |m: &mut PaymentHash| { &mut m.r_hash_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &PaymentHash| { &m.r_hash },
                    |m: &mut PaymentHash| { &mut m.r_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PaymentHash>(
                    "PaymentHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentHash {
        static mut instance: ::protobuf::lazy::Lazy<PaymentHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PaymentHash,
        };
        unsafe {
            instance.get(PaymentHash::new)
        }
    }
}

impl ::protobuf::Clear for PaymentHash {
    fn clear(&mut self) {
        self.clear_r_hash_str();
        self.clear_r_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInvoiceRequest {
    // message fields
    pub pending_only: bool,
    pub index_offset: u64,
    pub num_max_invoices: u64,
    pub reversed: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListInvoiceRequest {
    pub fn new() -> ListInvoiceRequest {
        ::std::default::Default::default()
    }

    // bool pending_only = 1;

    pub fn clear_pending_only(&mut self) {
        self.pending_only = false;
    }

    // Param is passed by value, moved
    pub fn set_pending_only(&mut self, v: bool) {
        self.pending_only = v;
    }

    pub fn get_pending_only(&self) -> bool {
        self.pending_only
    }

    // uint64 index_offset = 4;

    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u64) {
        self.index_offset = v;
    }

    pub fn get_index_offset(&self) -> u64 {
        self.index_offset
    }

    // uint64 num_max_invoices = 5;

    pub fn clear_num_max_invoices(&mut self) {
        self.num_max_invoices = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_max_invoices(&mut self, v: u64) {
        self.num_max_invoices = v;
    }

    pub fn get_num_max_invoices(&self) -> u64 {
        self.num_max_invoices
    }

    // bool reversed = 6;

    pub fn clear_reversed(&mut self) {
        self.reversed = false;
    }

    // Param is passed by value, moved
    pub fn set_reversed(&mut self, v: bool) {
        self.reversed = v;
    }

    pub fn get_reversed(&self) -> bool {
        self.reversed
    }
}

impl ::protobuf::Message for ListInvoiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index_offset = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_max_invoices = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reversed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pending_only != false {
            my_size += 2;
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_max_invoices != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_max_invoices, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reversed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.pending_only != false {
            os.write_bool(1, self.pending_only)?;
        }
        if self.index_offset != 0 {
            os.write_uint64(4, self.index_offset)?;
        }
        if self.num_max_invoices != 0 {
            os.write_uint64(5, self.num_max_invoices)?;
        }
        if self.reversed != false {
            os.write_bool(6, self.reversed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceRequest {
        ListInvoiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pending_only",
                    |m: &ListInvoiceRequest| { &m.pending_only },
                    |m: &mut ListInvoiceRequest| { &mut m.pending_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "index_offset",
                    |m: &ListInvoiceRequest| { &m.index_offset },
                    |m: &mut ListInvoiceRequest| { &mut m.index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_max_invoices",
                    |m: &ListInvoiceRequest| { &m.num_max_invoices },
                    |m: &mut ListInvoiceRequest| { &mut m.num_max_invoices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reversed",
                    |m: &ListInvoiceRequest| { &m.reversed },
                    |m: &mut ListInvoiceRequest| { &mut m.reversed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListInvoiceRequest>(
                    "ListInvoiceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInvoiceRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListInvoiceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInvoiceRequest,
        };
        unsafe {
            instance.get(ListInvoiceRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListInvoiceRequest {
    fn clear(&mut self) {
        self.clear_pending_only();
        self.clear_index_offset();
        self.clear_num_max_invoices();
        self.clear_reversed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInvoiceResponse {
    // message fields
    pub invoices: ::protobuf::RepeatedField<Invoice>,
    pub last_index_offset: u64,
    pub first_index_offset: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListInvoiceResponse {
    pub fn new() -> ListInvoiceResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Invoice invoices = 1;

    pub fn clear_invoices(&mut self) {
        self.invoices.clear();
    }

    // Param is passed by value, moved
    pub fn set_invoices(&mut self, v: ::protobuf::RepeatedField<Invoice>) {
        self.invoices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invoices(&mut self) -> &mut ::protobuf::RepeatedField<Invoice> {
        &mut self.invoices
    }

    // Take field
    pub fn take_invoices(&mut self) -> ::protobuf::RepeatedField<Invoice> {
        ::std::mem::replace(&mut self.invoices, ::protobuf::RepeatedField::new())
    }

    pub fn get_invoices(&self) -> &[Invoice] {
        &self.invoices
    }

    // uint64 last_index_offset = 2;

    pub fn clear_last_index_offset(&mut self) {
        self.last_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_index_offset(&mut self, v: u64) {
        self.last_index_offset = v;
    }

    pub fn get_last_index_offset(&self) -> u64 {
        self.last_index_offset
    }

    // uint64 first_index_offset = 3;

    pub fn clear_first_index_offset(&mut self) {
        self.first_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_index_offset(&mut self, v: u64) {
        self.first_index_offset = v;
    }

    pub fn get_first_index_offset(&self) -> u64 {
        self.first_index_offset
    }
}

impl ::protobuf::Message for ListInvoiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.invoices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invoices)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_index_offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.first_index_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invoices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.last_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.first_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.first_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invoices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.last_index_offset != 0 {
            os.write_uint64(2, self.last_index_offset)?;
        }
        if self.first_index_offset != 0 {
            os.write_uint64(3, self.first_index_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceResponse {
        ListInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Invoice>>(
                    "invoices",
                    |m: &ListInvoiceResponse| { &m.invoices },
                    |m: &mut ListInvoiceResponse| { &mut m.invoices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "last_index_offset",
                    |m: &ListInvoiceResponse| { &m.last_index_offset },
                    |m: &mut ListInvoiceResponse| { &mut m.last_index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "first_index_offset",
                    |m: &ListInvoiceResponse| { &m.first_index_offset },
                    |m: &mut ListInvoiceResponse| { &mut m.first_index_offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListInvoiceResponse>(
                    "ListInvoiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInvoiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListInvoiceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInvoiceResponse,
        };
        unsafe {
            instance.get(ListInvoiceResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListInvoiceResponse {
    fn clear(&mut self) {
        self.clear_invoices();
        self.clear_last_index_offset();
        self.clear_first_index_offset();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvoiceSubscription {
    // message fields
    pub add_index: u64,
    pub settle_index: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl InvoiceSubscription {
    pub fn new() -> InvoiceSubscription {
        ::std::default::Default::default()
    }

    // uint64 add_index = 1;

    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }

    // uint64 settle_index = 2;

    pub fn clear_settle_index(&mut self) {
        self.settle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_index(&mut self, v: u64) {
        self.settle_index = v;
    }

    pub fn get_settle_index(&self) -> u64 {
        self.settle_index
    }
}

impl ::protobuf::Message for InvoiceSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.settle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.add_index != 0 {
            os.write_uint64(1, self.add_index)?;
        }
        if self.settle_index != 0 {
            os.write_uint64(2, self.settle_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvoiceSubscription {
        InvoiceSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &InvoiceSubscription| { &m.add_index },
                    |m: &mut InvoiceSubscription| { &mut m.add_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settle_index",
                    |m: &InvoiceSubscription| { &m.settle_index },
                    |m: &mut InvoiceSubscription| { &mut m.settle_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InvoiceSubscription>(
                    "InvoiceSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvoiceSubscription {
        static mut instance: ::protobuf::lazy::Lazy<InvoiceSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InvoiceSubscription,
        };
        unsafe {
            instance.get(InvoiceSubscription::new)
        }
    }
}

impl ::protobuf::Clear for InvoiceSubscription {
    fn clear(&mut self) {
        self.clear_add_index();
        self.clear_settle_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvoiceSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payment {
    // message fields
    pub payment_hash: ::std::string::String,
    pub value: i64,
    pub creation_date: i64,
    pub path: ::protobuf::RepeatedField<::std::string::String>,
    pub fee: i64,
    pub payment_preimage: ::std::string::String,
    pub value_sat: i64,
    pub value_msat: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Payment {
    pub fn new() -> Payment {
        ::std::default::Default::default()
    }

    // string payment_hash = 1;

    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }

    // int64 value = 2;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    pub fn get_value(&self) -> i64 {
        self.value
    }

    // int64 creation_date = 3;

    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }

    // repeated string path = 4;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[::std::string::String] {
        &self.path
    }

    // int64 fee = 5;

    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    pub fn get_fee(&self) -> i64 {
        self.fee
    }

    // string payment_preimage = 6;

    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::string::String) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::string::String {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_preimage, ::std::string::String::new())
    }

    pub fn get_payment_preimage(&self) -> &str {
        &self.payment_preimage
    }

    // int64 value_sat = 7;

    pub fn clear_value_sat(&mut self) {
        self.value_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_sat(&mut self, v: i64) {
        self.value_sat = v;
    }

    pub fn get_value_sat(&self) -> i64 {
        self.value_sat
    }

    // int64 value_msat = 8;

    pub fn clear_value_msat(&mut self) {
        self.value_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_msat(&mut self, v: i64) {
        self.value_msat = v;
    }

    pub fn get_value_msat(&self) -> i64 {
        self.value_msat
    }
}

impl ::protobuf::Message for Payment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.path)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_preimage)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_sat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_hash);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(3, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.path {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(5, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_preimage);
        }
        if self.value_sat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.value_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value_msat != 0 {
            my_size += ::protobuf::rt::value_size(8, self.value_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_string(1, &self.payment_hash)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        if self.creation_date != 0 {
            os.write_int64(3, self.creation_date)?;
        }
        for v in &self.path {
            os.write_string(4, &v)?;
        };
        if self.fee != 0 {
            os.write_int64(5, self.fee)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_string(6, &self.payment_preimage)?;
        }
        if self.value_sat != 0 {
            os.write_int64(7, self.value_sat)?;
        }
        if self.value_msat != 0 {
            os.write_int64(8, self.value_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payment {
        Payment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash",
                    |m: &Payment| { &m.payment_hash },
                    |m: &mut Payment| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &Payment| { &m.value },
                    |m: &mut Payment| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "creation_date",
                    |m: &Payment| { &m.creation_date },
                    |m: &mut Payment| { &mut m.creation_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &Payment| { &m.path },
                    |m: &mut Payment| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &Payment| { &m.fee },
                    |m: &mut Payment| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_preimage",
                    |m: &Payment| { &m.payment_preimage },
                    |m: &mut Payment| { &mut m.payment_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_sat",
                    |m: &Payment| { &m.value_sat },
                    |m: &mut Payment| { &mut m.value_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_msat",
                    |m: &Payment| { &m.value_msat },
                    |m: &mut Payment| { &mut m.value_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Payment>(
                    "Payment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Payment {
        static mut instance: ::protobuf::lazy::Lazy<Payment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Payment,
        };
        unsafe {
            instance.get(Payment::new)
        }
    }
}

impl ::protobuf::Clear for Payment {
    fn clear(&mut self) {
        self.clear_payment_hash();
        self.clear_value();
        self.clear_creation_date();
        self.clear_path();
        self.clear_fee();
        self.clear_payment_preimage();
        self.clear_value_sat();
        self.clear_value_msat();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPaymentsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListPaymentsRequest {
    pub fn new() -> ListPaymentsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListPaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPaymentsRequest {
        ListPaymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ListPaymentsRequest>(
                    "ListPaymentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPaymentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPaymentsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPaymentsRequest,
        };
        unsafe {
            instance.get(ListPaymentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPaymentsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPaymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPaymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPaymentsResponse {
    // message fields
    pub payments: ::protobuf::RepeatedField<Payment>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListPaymentsResponse {
    pub fn new() -> ListPaymentsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Payment payments = 1;

    pub fn clear_payments(&mut self) {
        self.payments.clear();
    }

    // Param is passed by value, moved
    pub fn set_payments(&mut self, v: ::protobuf::RepeatedField<Payment>) {
        self.payments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payments(&mut self) -> &mut ::protobuf::RepeatedField<Payment> {
        &mut self.payments
    }

    // Take field
    pub fn take_payments(&mut self) -> ::protobuf::RepeatedField<Payment> {
        ::std::mem::replace(&mut self.payments, ::protobuf::RepeatedField::new())
    }

    pub fn get_payments(&self) -> &[Payment] {
        &self.payments
    }
}

impl ::protobuf::Message for ListPaymentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.payments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.payments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.payments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPaymentsResponse {
        ListPaymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payment>>(
                    "payments",
                    |m: &ListPaymentsResponse| { &m.payments },
                    |m: &mut ListPaymentsResponse| { &mut m.payments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPaymentsResponse>(
                    "ListPaymentsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPaymentsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPaymentsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPaymentsResponse,
        };
        unsafe {
            instance.get(ListPaymentsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPaymentsResponse {
    fn clear(&mut self) {
        self.clear_payments();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPaymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPaymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAllPaymentsRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeleteAllPaymentsRequest {
    pub fn new() -> DeleteAllPaymentsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteAllPaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAllPaymentsRequest {
        DeleteAllPaymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteAllPaymentsRequest>(
                    "DeleteAllPaymentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteAllPaymentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteAllPaymentsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteAllPaymentsRequest,
        };
        unsafe {
            instance.get(DeleteAllPaymentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteAllPaymentsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAllPaymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAllPaymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAllPaymentsResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeleteAllPaymentsResponse {
    pub fn new() -> DeleteAllPaymentsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteAllPaymentsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAllPaymentsResponse {
        DeleteAllPaymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteAllPaymentsResponse>(
                    "DeleteAllPaymentsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteAllPaymentsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteAllPaymentsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteAllPaymentsResponse,
        };
        unsafe {
            instance.get(DeleteAllPaymentsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteAllPaymentsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAllPaymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAllPaymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonChannelRequest {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AbandonChannelRequest {
    pub fn new() -> AbandonChannelRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;

    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
}

impl ::protobuf::Message for AbandonChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonChannelRequest {
        AbandonChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &AbandonChannelRequest| { &m.channel_point },
                    |m: &mut AbandonChannelRequest| { &mut m.channel_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbandonChannelRequest>(
                    "AbandonChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbandonChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<AbandonChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonChannelRequest,
        };
        unsafe {
            instance.get(AbandonChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for AbandonChannelRequest {
    fn clear(&mut self) {
        self.clear_channel_point();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonChannelResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl AbandonChannelResponse {
    pub fn new() -> AbandonChannelResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AbandonChannelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonChannelResponse {
        AbandonChannelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AbandonChannelResponse>(
                    "AbandonChannelResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbandonChannelResponse {
        static mut instance: ::protobuf::lazy::Lazy<AbandonChannelResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonChannelResponse,
        };
        unsafe {
            instance.get(AbandonChannelResponse::new)
        }
    }
}

impl ::protobuf::Clear for AbandonChannelResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonChannelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugLevelRequest {
    // message fields
    pub show: bool,
    pub level_spec: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DebugLevelRequest {
    pub fn new() -> DebugLevelRequest {
        ::std::default::Default::default()
    }

    // bool show = 1;

    pub fn clear_show(&mut self) {
        self.show = false;
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = v;
    }

    pub fn get_show(&self) -> bool {
        self.show
    }

    // string level_spec = 2;

    pub fn clear_level_spec(&mut self) {
        self.level_spec.clear();
    }

    // Param is passed by value, moved
    pub fn set_level_spec(&mut self, v: ::std::string::String) {
        self.level_spec = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_spec(&mut self) -> &mut ::std::string::String {
        &mut self.level_spec
    }

    // Take field
    pub fn take_level_spec(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level_spec, ::std::string::String::new())
    }

    pub fn get_level_spec(&self) -> &str {
        &self.level_spec
    }
}

impl ::protobuf::Message for DebugLevelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.show != false {
            my_size += 2;
        }
        if !self.level_spec.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.level_spec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.show != false {
            os.write_bool(1, self.show)?;
        }
        if !self.level_spec.is_empty() {
            os.write_string(2, &self.level_spec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugLevelRequest {
        DebugLevelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show",
                    |m: &DebugLevelRequest| { &m.show },
                    |m: &mut DebugLevelRequest| { &mut m.show },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "level_spec",
                    |m: &DebugLevelRequest| { &m.level_spec },
                    |m: &mut DebugLevelRequest| { &mut m.level_spec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugLevelRequest>(
                    "DebugLevelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugLevelRequest {
        static mut instance: ::protobuf::lazy::Lazy<DebugLevelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugLevelRequest,
        };
        unsafe {
            instance.get(DebugLevelRequest::new)
        }
    }
}

impl ::protobuf::Clear for DebugLevelRequest {
    fn clear(&mut self) {
        self.clear_show();
        self.clear_level_spec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLevelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugLevelResponse {
    // message fields
    pub sub_systems: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DebugLevelResponse {
    pub fn new() -> DebugLevelResponse {
        ::std::default::Default::default()
    }

    // string sub_systems = 1;

    pub fn clear_sub_systems(&mut self) {
        self.sub_systems.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_systems(&mut self, v: ::std::string::String) {
        self.sub_systems = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_systems(&mut self) -> &mut ::std::string::String {
        &mut self.sub_systems
    }

    // Take field
    pub fn take_sub_systems(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sub_systems, ::std::string::String::new())
    }

    pub fn get_sub_systems(&self) -> &str {
        &self.sub_systems
    }
}

impl ::protobuf::Message for DebugLevelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sub_systems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sub_systems.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sub_systems);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.sub_systems.is_empty() {
            os.write_string(1, &self.sub_systems)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugLevelResponse {
        DebugLevelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sub_systems",
                    |m: &DebugLevelResponse| { &m.sub_systems },
                    |m: &mut DebugLevelResponse| { &mut m.sub_systems },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugLevelResponse>(
                    "DebugLevelResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugLevelResponse {
        static mut instance: ::protobuf::lazy::Lazy<DebugLevelResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugLevelResponse,
        };
        unsafe {
            instance.get(DebugLevelResponse::new)
        }
    }
}

impl ::protobuf::Clear for DebugLevelResponse {
    fn clear(&mut self) {
        self.clear_sub_systems();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugLevelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLevelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayReqString {
    // message fields
    pub pay_req: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PayReqString {
    pub fn new() -> PayReqString {
        ::std::default::Default::default()
    }

    // string pay_req = 1;

    pub fn clear_pay_req(&mut self) {
        self.pay_req.clear();
    }

    // Param is passed by value, moved
    pub fn set_pay_req(&mut self, v: ::std::string::String) {
        self.pay_req = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pay_req(&mut self) -> &mut ::std::string::String {
        &mut self.pay_req
    }

    // Take field
    pub fn take_pay_req(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pay_req, ::std::string::String::new())
    }

    pub fn get_pay_req(&self) -> &str {
        &self.pay_req
    }
}

impl ::protobuf::Message for PayReqString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pay_req)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pay_req.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pay_req);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.pay_req.is_empty() {
            os.write_string(1, &self.pay_req)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReqString {
        PayReqString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pay_req",
                    |m: &PayReqString| { &m.pay_req },
                    |m: &mut PayReqString| { &mut m.pay_req },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayReqString>(
                    "PayReqString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PayReqString {
        static mut instance: ::protobuf::lazy::Lazy<PayReqString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PayReqString,
        };
        unsafe {
            instance.get(PayReqString::new)
        }
    }
}

impl ::protobuf::Clear for PayReqString {
    fn clear(&mut self) {
        self.clear_pay_req();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReqString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReqString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayReq {
    // message fields
    pub destination: ::std::string::String,
    pub payment_hash: ::std::string::String,
    pub num_satoshis: i64,
    pub timestamp: i64,
    pub expiry: i64,
    pub description: ::std::string::String,
    pub description_hash: ::std::string::String,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: i64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PayReq {
    pub fn new() -> PayReq {
        ::std::default::Default::default()
    }

    // string destination = 1;

    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    pub fn get_destination(&self) -> &str {
        &self.destination
    }

    // string payment_hash = 2;

    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }

    // int64 num_satoshis = 3;

    pub fn clear_num_satoshis(&mut self) {
        self.num_satoshis = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_satoshis(&mut self, v: i64) {
        self.num_satoshis = v;
    }

    pub fn get_num_satoshis(&self) -> i64 {
        self.num_satoshis
    }

    // int64 timestamp = 4;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }

    // int64 expiry = 5;

    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }

    // string description = 6;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        &self.description
    }

    // string description_hash = 7;

    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::string::String) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::string::String {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description_hash, ::std::string::String::new())
    }

    pub fn get_description_hash(&self) -> &str {
        &self.description_hash
    }

    // string fallback_addr = 8;

    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }

    // int64 cltv_expiry = 9;

    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: i64) {
        self.cltv_expiry = v;
    }

    pub fn get_cltv_expiry(&self) -> i64 {
        self.cltv_expiry
    }

    // repeated .lnrpc.RouteHint route_hints = 10;

    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }
}

impl ::protobuf::Message for PayReq {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_satoshis = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description_hash)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cltv_expiry = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_hash);
        }
        if self.num_satoshis != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_satoshis, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description_hash);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(9, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.destination.is_empty() {
            os.write_string(1, &self.destination)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_string(2, &self.payment_hash)?;
        }
        if self.num_satoshis != 0 {
            os.write_int64(3, self.num_satoshis)?;
        }
        if self.timestamp != 0 {
            os.write_int64(4, self.timestamp)?;
        }
        if self.expiry != 0 {
            os.write_int64(5, self.expiry)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if !self.description_hash.is_empty() {
            os.write_string(7, &self.description_hash)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(8, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_int64(9, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReq {
        PayReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "destination",
                    |m: &PayReq| { &m.destination },
                    |m: &mut PayReq| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash",
                    |m: &PayReq| { &m.payment_hash },
                    |m: &mut PayReq| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "num_satoshis",
                    |m: &PayReq| { &m.num_satoshis },
                    |m: &mut PayReq| { &mut m.num_satoshis },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &PayReq| { &m.timestamp },
                    |m: &mut PayReq| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiry",
                    |m: &PayReq| { &m.expiry },
                    |m: &mut PayReq| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &PayReq| { &m.description },
                    |m: &mut PayReq| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description_hash",
                    |m: &PayReq| { &m.description_hash },
                    |m: &mut PayReq| { &mut m.description_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fallback_addr",
                    |m: &PayReq| { &m.fallback_addr },
                    |m: &mut PayReq| { &mut m.fallback_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cltv_expiry",
                    |m: &PayReq| { &m.cltv_expiry },
                    |m: &mut PayReq| { &mut m.cltv_expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                    "route_hints",
                    |m: &PayReq| { &m.route_hints },
                    |m: &mut PayReq| { &mut m.route_hints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayReq>(
                    "PayReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PayReq {
        static mut instance: ::protobuf::lazy::Lazy<PayReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PayReq,
        };
        unsafe {
            instance.get(PayReq::new)
        }
    }
}

impl ::protobuf::Clear for PayReq {
    fn clear(&mut self) {
        self.clear_destination();
        self.clear_payment_hash();
        self.clear_num_satoshis();
        self.clear_timestamp();
        self.clear_expiry();
        self.clear_description();
        self.clear_description_hash();
        self.clear_fallback_addr();
        self.clear_cltv_expiry();
        self.clear_route_hints();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeReportRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FeeReportRequest {
    pub fn new() -> FeeReportRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FeeReportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeReportRequest {
        FeeReportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FeeReportRequest>(
                    "FeeReportRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeReportRequest {
        static mut instance: ::protobuf::lazy::Lazy<FeeReportRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeReportRequest,
        };
        unsafe {
            instance.get(FeeReportRequest::new)
        }
    }
}

impl ::protobuf::Clear for FeeReportRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeReportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelFeeReport {
    // message fields
    pub chan_point: ::std::string::String,
    pub base_fee_msat: i64,
    pub fee_per_mil: i64,
    pub fee_rate: f64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ChannelFeeReport {
    pub fn new() -> ChannelFeeReport {
        ::std::default::Default::default()
    }

    // string chan_point = 1;

    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ::std::string::String) {
        self.chan_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ::std::string::String {
        &mut self.chan_point
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_point, ::std::string::String::new())
    }

    pub fn get_chan_point(&self) -> &str {
        &self.chan_point
    }

    // int64 base_fee_msat = 2;

    pub fn clear_base_fee_msat(&mut self) {
        self.base_fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_fee_msat(&mut self, v: i64) {
        self.base_fee_msat = v;
    }

    pub fn get_base_fee_msat(&self) -> i64 {
        self.base_fee_msat
    }

    // int64 fee_per_mil = 3;

    pub fn clear_fee_per_mil(&mut self) {
        self.fee_per_mil = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_mil(&mut self, v: i64) {
        self.fee_per_mil = v;
    }

    pub fn get_fee_per_mil(&self) -> i64 {
        self.fee_per_mil
    }

    // double fee_rate = 4;

    pub fn clear_fee_rate(&mut self) {
        self.fee_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate(&mut self, v: f64) {
        self.fee_rate = v;
    }

    pub fn get_fee_rate(&self) -> f64 {
        self.fee_rate
    }
}

impl ::protobuf::Message for ChannelFeeReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_fee_msat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_mil = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.fee_rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.chan_point.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chan_point);
        }
        if self.base_fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.base_fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_mil != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_per_mil, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.chan_point.is_empty() {
            os.write_string(1, &self.chan_point)?;
        }
        if self.base_fee_msat != 0 {
            os.write_int64(2, self.base_fee_msat)?;
        }
        if self.fee_per_mil != 0 {
            os.write_int64(3, self.fee_per_mil)?;
        }
        if self.fee_rate != 0. {
            os.write_double(4, self.fee_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelFeeReport {
        ChannelFeeReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chan_point",
                    |m: &ChannelFeeReport| { &m.chan_point },
                    |m: &mut ChannelFeeReport| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "base_fee_msat",
                    |m: &ChannelFeeReport| { &m.base_fee_msat },
                    |m: &mut ChannelFeeReport| { &mut m.base_fee_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_per_mil",
                    |m: &ChannelFeeReport| { &m.fee_per_mil },
                    |m: &mut ChannelFeeReport| { &mut m.fee_per_mil },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "fee_rate",
                    |m: &ChannelFeeReport| { &m.fee_rate },
                    |m: &mut ChannelFeeReport| { &mut m.fee_rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelFeeReport>(
                    "ChannelFeeReport",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelFeeReport {
        static mut instance: ::protobuf::lazy::Lazy<ChannelFeeReport> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelFeeReport,
        };
        unsafe {
            instance.get(ChannelFeeReport::new)
        }
    }
}

impl ::protobuf::Clear for ChannelFeeReport {
    fn clear(&mut self) {
        self.clear_chan_point();
        self.clear_base_fee_msat();
        self.clear_fee_per_mil();
        self.clear_fee_rate();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelFeeReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelFeeReport {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeReportResponse {
    // message fields
    pub channel_fees: ::protobuf::RepeatedField<ChannelFeeReport>,
    pub day_fee_sum: u64,
    pub week_fee_sum: u64,
    pub month_fee_sum: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl FeeReportResponse {
    pub fn new() -> FeeReportResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelFeeReport channel_fees = 1;

    pub fn clear_channel_fees(&mut self) {
        self.channel_fees.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_fees(&mut self, v: ::protobuf::RepeatedField<ChannelFeeReport>) {
        self.channel_fees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_fees(&mut self) -> &mut ::protobuf::RepeatedField<ChannelFeeReport> {
        &mut self.channel_fees
    }

    // Take field
    pub fn take_channel_fees(&mut self) -> ::protobuf::RepeatedField<ChannelFeeReport> {
        ::std::mem::replace(&mut self.channel_fees, ::protobuf::RepeatedField::new())
    }

    pub fn get_channel_fees(&self) -> &[ChannelFeeReport] {
        &self.channel_fees
    }

    // uint64 day_fee_sum = 2;

    pub fn clear_day_fee_sum(&mut self) {
        self.day_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_day_fee_sum(&mut self, v: u64) {
        self.day_fee_sum = v;
    }

    pub fn get_day_fee_sum(&self) -> u64 {
        self.day_fee_sum
    }

    // uint64 week_fee_sum = 3;

    pub fn clear_week_fee_sum(&mut self) {
        self.week_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_week_fee_sum(&mut self, v: u64) {
        self.week_fee_sum = v;
    }

    pub fn get_week_fee_sum(&self) -> u64 {
        self.week_fee_sum
    }

    // uint64 month_fee_sum = 4;

    pub fn clear_month_fee_sum(&mut self) {
        self.month_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_month_fee_sum(&mut self, v: u64) {
        self.month_fee_sum = v;
    }

    pub fn get_month_fee_sum(&self) -> u64 {
        self.month_fee_sum
    }
}

impl ::protobuf::Message for FeeReportResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_fees {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_fees)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.day_fee_sum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.week_fee_sum = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.month_fee_sum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channel_fees {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.day_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.day_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.week_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.week_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.month_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(4, self.month_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channel_fees {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.day_fee_sum != 0 {
            os.write_uint64(2, self.day_fee_sum)?;
        }
        if self.week_fee_sum != 0 {
            os.write_uint64(3, self.week_fee_sum)?;
        }
        if self.month_fee_sum != 0 {
            os.write_uint64(4, self.month_fee_sum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeReportResponse {
        FeeReportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelFeeReport>>(
                    "channel_fees",
                    |m: &FeeReportResponse| { &m.channel_fees },
                    |m: &mut FeeReportResponse| { &mut m.channel_fees },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "day_fee_sum",
                    |m: &FeeReportResponse| { &m.day_fee_sum },
                    |m: &mut FeeReportResponse| { &mut m.day_fee_sum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "week_fee_sum",
                    |m: &FeeReportResponse| { &m.week_fee_sum },
                    |m: &mut FeeReportResponse| { &mut m.week_fee_sum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "month_fee_sum",
                    |m: &FeeReportResponse| { &m.month_fee_sum },
                    |m: &mut FeeReportResponse| { &mut m.month_fee_sum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeeReportResponse>(
                    "FeeReportResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeReportResponse {
        static mut instance: ::protobuf::lazy::Lazy<FeeReportResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeReportResponse,
        };
        unsafe {
            instance.get(FeeReportResponse::new)
        }
    }
}

impl ::protobuf::Clear for FeeReportResponse {
    fn clear(&mut self) {
        self.clear_channel_fees();
        self.clear_day_fee_sum();
        self.clear_week_fee_sum();
        self.clear_month_fee_sum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PolicyUpdateRequest {
    // message fields
    pub base_fee_msat: i64,
    pub fee_rate: f64,
    pub time_lock_delta: u32,
    // message oneof groups
    pub scope: ::std::option::Option<PolicyUpdateRequest_oneof_scope>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum PolicyUpdateRequest_oneof_scope {
    global(bool),
    chan_point(ChannelPoint),
}

impl PolicyUpdateRequest {
    pub fn new() -> PolicyUpdateRequest {
        ::std::default::Default::default()
    }

    // bool global = 1;

    pub fn clear_global(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_global(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_global(&mut self, v: bool) {
        self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(v))
    }

    pub fn get_global(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(v)) => v,
            _ => false,
        }
    }

    // .lnrpc.ChannelPoint chan_point = 2;

    pub fn clear_chan_point(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_chan_point(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if let ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(_)) = self.scope {
        } else {
            self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ChannelPoint::new()));
        }
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        if self.has_chan_point() {
            match self.scope.take() {
                ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPoint::new()
        }
    }

    pub fn get_chan_point(&self) -> &ChannelPoint {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ref v)) => v,
            _ => ChannelPoint::default_instance(),
        }
    }

    // int64 base_fee_msat = 3;

    pub fn clear_base_fee_msat(&mut self) {
        self.base_fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_fee_msat(&mut self, v: i64) {
        self.base_fee_msat = v;
    }

    pub fn get_base_fee_msat(&self) -> i64 {
        self.base_fee_msat
    }

    // double fee_rate = 4;

    pub fn clear_fee_rate(&mut self) {
        self.fee_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate(&mut self, v: f64) {
        self.fee_rate = v;
    }

    pub fn get_fee_rate(&self) -> f64 {
        self.fee_rate
    }

    // uint32 time_lock_delta = 5;

    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }

    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }
}

impl ::protobuf::Message for PolicyUpdateRequest {
    fn is_initialized(&self) -> bool {
        if let Some(PolicyUpdateRequest_oneof_scope::chan_point(ref v)) = self.scope {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_fee_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.fee_rate = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.base_fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.base_fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate != 0. {
            my_size += 9;
        }
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &PolicyUpdateRequest_oneof_scope::global(v) => {
                    my_size += 2;
                },
                &PolicyUpdateRequest_oneof_scope::chan_point(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.base_fee_msat != 0 {
            os.write_int64(3, self.base_fee_msat)?;
        }
        if self.fee_rate != 0. {
            os.write_double(4, self.fee_rate)?;
        }
        if self.time_lock_delta != 0 {
            os.write_uint32(5, self.time_lock_delta)?;
        }
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &PolicyUpdateRequest_oneof_scope::global(v) => {
                    os.write_bool(1, v)?;
                },
                &PolicyUpdateRequest_oneof_scope::chan_point(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyUpdateRequest {
        PolicyUpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "global",
                    PolicyUpdateRequest::has_global,
                    PolicyUpdateRequest::get_global,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPoint>(
                    "chan_point",
                    PolicyUpdateRequest::has_chan_point,
                    PolicyUpdateRequest::get_chan_point,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "base_fee_msat",
                    |m: &PolicyUpdateRequest| { &m.base_fee_msat },
                    |m: &mut PolicyUpdateRequest| { &mut m.base_fee_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "fee_rate",
                    |m: &PolicyUpdateRequest| { &m.fee_rate },
                    |m: &mut PolicyUpdateRequest| { &mut m.fee_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_lock_delta",
                    |m: &PolicyUpdateRequest| { &m.time_lock_delta },
                    |m: &mut PolicyUpdateRequest| { &mut m.time_lock_delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PolicyUpdateRequest>(
                    "PolicyUpdateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PolicyUpdateRequest {
        static mut instance: ::protobuf::lazy::Lazy<PolicyUpdateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PolicyUpdateRequest,
        };
        unsafe {
            instance.get(PolicyUpdateRequest::new)
        }
    }
}

impl ::protobuf::Clear for PolicyUpdateRequest {
    fn clear(&mut self) {
        self.clear_global();
        self.clear_chan_point();
        self.clear_base_fee_msat();
        self.clear_fee_rate();
        self.clear_time_lock_delta();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PolicyUpdateResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PolicyUpdateResponse {
    pub fn new() -> PolicyUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PolicyUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyUpdateResponse {
        PolicyUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<PolicyUpdateResponse>(
                    "PolicyUpdateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PolicyUpdateResponse {
        static mut instance: ::protobuf::lazy::Lazy<PolicyUpdateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PolicyUpdateResponse,
        };
        unsafe {
            instance.get(PolicyUpdateResponse::new)
        }
    }
}

impl ::protobuf::Clear for PolicyUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingHistoryRequest {
    // message fields
    pub start_time: u64,
    pub end_time: u64,
    pub index_offset: u32,
    pub num_max_events: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ForwardingHistoryRequest {
    pub fn new() -> ForwardingHistoryRequest {
        ::std::default::Default::default()
    }

    // uint64 start_time = 1;

    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u64) {
        self.start_time = v;
    }

    pub fn get_start_time(&self) -> u64 {
        self.start_time
    }

    // uint64 end_time = 2;

    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u64) {
        self.end_time = v;
    }

    pub fn get_end_time(&self) -> u64 {
        self.end_time
    }

    // uint32 index_offset = 3;

    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u32) {
        self.index_offset = v;
    }

    pub fn get_index_offset(&self) -> u32 {
        self.index_offset
    }

    // uint32 num_max_events = 4;

    pub fn clear_num_max_events(&mut self) {
        self.num_max_events = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_max_events(&mut self, v: u32) {
        self.num_max_events = v;
    }

    pub fn get_num_max_events(&self) -> u32 {
        self.num_max_events
    }
}

impl ::protobuf::Message for ForwardingHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index_offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_max_events = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_max_events != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_max_events, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_time != 0 {
            os.write_uint64(1, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_uint64(2, self.end_time)?;
        }
        if self.index_offset != 0 {
            os.write_uint32(3, self.index_offset)?;
        }
        if self.num_max_events != 0 {
            os.write_uint32(4, self.num_max_events)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingHistoryRequest {
        ForwardingHistoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_time",
                    |m: &ForwardingHistoryRequest| { &m.start_time },
                    |m: &mut ForwardingHistoryRequest| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "end_time",
                    |m: &ForwardingHistoryRequest| { &m.end_time },
                    |m: &mut ForwardingHistoryRequest| { &mut m.end_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "index_offset",
                    |m: &ForwardingHistoryRequest| { &m.index_offset },
                    |m: &mut ForwardingHistoryRequest| { &mut m.index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_max_events",
                    |m: &ForwardingHistoryRequest| { &m.num_max_events },
                    |m: &mut ForwardingHistoryRequest| { &mut m.num_max_events },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForwardingHistoryRequest>(
                    "ForwardingHistoryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ForwardingHistoryRequest {
        static mut instance: ::protobuf::lazy::Lazy<ForwardingHistoryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ForwardingHistoryRequest,
        };
        unsafe {
            instance.get(ForwardingHistoryRequest::new)
        }
    }
}

impl ::protobuf::Clear for ForwardingHistoryRequest {
    fn clear(&mut self) {
        self.clear_start_time();
        self.clear_end_time();
        self.clear_index_offset();
        self.clear_num_max_events();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingEvent {
    // message fields
    pub timestamp: u64,
    pub chan_id_in: u64,
    pub chan_id_out: u64,
    pub amt_in: u64,
    pub amt_out: u64,
    pub fee: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ForwardingEvent {
    pub fn new() -> ForwardingEvent {
        ::std::default::Default::default()
    }

    // uint64 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }

    // uint64 chan_id_in = 2;

    pub fn clear_chan_id_in(&mut self) {
        self.chan_id_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id_in(&mut self, v: u64) {
        self.chan_id_in = v;
    }

    pub fn get_chan_id_in(&self) -> u64 {
        self.chan_id_in
    }

    // uint64 chan_id_out = 4;

    pub fn clear_chan_id_out(&mut self) {
        self.chan_id_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id_out(&mut self, v: u64) {
        self.chan_id_out = v;
    }

    pub fn get_chan_id_out(&self) -> u64 {
        self.chan_id_out
    }

    // uint64 amt_in = 5;

    pub fn clear_amt_in(&mut self) {
        self.amt_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_in(&mut self, v: u64) {
        self.amt_in = v;
    }

    pub fn get_amt_in(&self) -> u64 {
        self.amt_in
    }

    // uint64 amt_out = 6;

    pub fn clear_amt_out(&mut self) {
        self.amt_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_out(&mut self, v: u64) {
        self.amt_out = v;
    }

    pub fn get_amt_out(&self) -> u64 {
        self.amt_out
    }

    // uint64 fee = 7;

    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = v;
    }

    pub fn get_fee(&self) -> u64 {
        self.fee
    }
}

impl ::protobuf::Message for ForwardingEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id_in = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id_out = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_in = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_out = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_id_in != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_id_out != 0 {
            my_size += ::protobuf::rt::value_size(4, self.chan_id_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_in != 0 {
            my_size += ::protobuf::rt::value_size(5, self.amt_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_out != 0 {
            my_size += ::protobuf::rt::value_size(6, self.amt_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(7, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint64(1, self.timestamp)?;
        }
        if self.chan_id_in != 0 {
            os.write_uint64(2, self.chan_id_in)?;
        }
        if self.chan_id_out != 0 {
            os.write_uint64(4, self.chan_id_out)?;
        }
        if self.amt_in != 0 {
            os.write_uint64(5, self.amt_in)?;
        }
        if self.amt_out != 0 {
            os.write_uint64(6, self.amt_out)?;
        }
        if self.fee != 0 {
            os.write_uint64(7, self.fee)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingEvent {
        ForwardingEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &ForwardingEvent| { &m.timestamp },
                    |m: &mut ForwardingEvent| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id_in",
                    |m: &ForwardingEvent| { &m.chan_id_in },
                    |m: &mut ForwardingEvent| { &mut m.chan_id_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id_out",
                    |m: &ForwardingEvent| { &m.chan_id_out },
                    |m: &mut ForwardingEvent| { &mut m.chan_id_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amt_in",
                    |m: &ForwardingEvent| { &m.amt_in },
                    |m: &mut ForwardingEvent| { &mut m.amt_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amt_out",
                    |m: &ForwardingEvent| { &m.amt_out },
                    |m: &mut ForwardingEvent| { &mut m.amt_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &ForwardingEvent| { &m.fee },
                    |m: &mut ForwardingEvent| { &mut m.fee },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForwardingEvent>(
                    "ForwardingEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ForwardingEvent {
        static mut instance: ::protobuf::lazy::Lazy<ForwardingEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ForwardingEvent,
        };
        unsafe {
            instance.get(ForwardingEvent::new)
        }
    }
}

impl ::protobuf::Clear for ForwardingEvent {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_chan_id_in();
        self.clear_chan_id_out();
        self.clear_amt_in();
        self.clear_amt_out();
        self.clear_fee();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingHistoryResponse {
    // message fields
    pub forwarding_events: ::protobuf::RepeatedField<ForwardingEvent>,
    pub last_offset_index: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ForwardingHistoryResponse {
    pub fn new() -> ForwardingHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ForwardingEvent forwarding_events = 1;

    pub fn clear_forwarding_events(&mut self) {
        self.forwarding_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_forwarding_events(&mut self, v: ::protobuf::RepeatedField<ForwardingEvent>) {
        self.forwarding_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_forwarding_events(&mut self) -> &mut ::protobuf::RepeatedField<ForwardingEvent> {
        &mut self.forwarding_events
    }

    // Take field
    pub fn take_forwarding_events(&mut self) -> ::protobuf::RepeatedField<ForwardingEvent> {
        ::std::mem::replace(&mut self.forwarding_events, ::protobuf::RepeatedField::new())
    }

    pub fn get_forwarding_events(&self) -> &[ForwardingEvent] {
        &self.forwarding_events
    }

    // uint32 last_offset_index = 2;

    pub fn clear_last_offset_index(&mut self) {
        self.last_offset_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_offset_index(&mut self, v: u32) {
        self.last_offset_index = v;
    }

    pub fn get_last_offset_index(&self) -> u32 {
        self.last_offset_index
    }
}

impl ::protobuf::Message for ForwardingHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.forwarding_events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.forwarding_events)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_offset_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.forwarding_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.last_offset_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_offset_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.forwarding_events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.last_offset_index != 0 {
            os.write_uint32(2, self.last_offset_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingHistoryResponse {
        ForwardingHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForwardingEvent>>(
                    "forwarding_events",
                    |m: &ForwardingHistoryResponse| { &m.forwarding_events },
                    |m: &mut ForwardingHistoryResponse| { &mut m.forwarding_events },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_offset_index",
                    |m: &ForwardingHistoryResponse| { &m.last_offset_index },
                    |m: &mut ForwardingHistoryResponse| { &mut m.last_offset_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForwardingHistoryResponse>(
                    "ForwardingHistoryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ForwardingHistoryResponse {
        static mut instance: ::protobuf::lazy::Lazy<ForwardingHistoryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ForwardingHistoryResponse,
        };
        unsafe {
            instance.get(ForwardingHistoryResponse::new)
        }
    }
}

impl ::protobuf::Clear for ForwardingHistoryResponse {
    fn clear(&mut self) {
        self.clear_forwarding_events();
        self.clear_last_offset_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\trpc.proto\x12\x05lnrpc\x1a\x1cgoogle/api/annotations.proto\"`\n\x0eG\
    enSeedRequest\x12+\n\x11aezeed_passphrase\x18\x01\x20\x01(\x0cR\x10aezee\
    dPassphrase\x12!\n\x0cseed_entropy\x18\x02\x20\x01(\x0cR\x0bseedEntropy\
    \"l\n\x0fGenSeedResponse\x120\n\x14cipher_seed_mnemonic\x18\x01\x20\x03(\
    \tR\x12cipherSeedMnemonic\x12'\n\x0fenciphered_seed\x18\x02\x20\x01(\x0c\
    R\x0eencipheredSeed\"\xc4\x01\n\x11InitWalletRequest\x12'\n\x0fwallet_pa\
    ssword\x18\x01\x20\x01(\x0cR\x0ewalletPassword\x120\n\x14cipher_seed_mne\
    monic\x18\x02\x20\x03(\tR\x12cipherSeedMnemonic\x12+\n\x11aezeed_passphr\
    ase\x18\x03\x20\x01(\x0cR\x10aezeedPassphrase\x12'\n\x0frecovery_window\
    \x18\x04\x20\x01(\x05R\x0erecoveryWindow\"\x14\n\x12InitWalletResponse\"\
    g\n\x13UnlockWalletRequest\x12'\n\x0fwallet_password\x18\x01\x20\x01(\
    \x0cR\x0ewalletPassword\x12'\n\x0frecovery_window\x18\x02\x20\x01(\x05R\
    \x0erecoveryWindow\"\x16\n\x14UnlockWalletResponse\"e\n\x15ChangePasswor\
    dRequest\x12)\n\x10current_password\x18\x01\x20\x01(\x0cR\x0fcurrentPass\
    word\x12!\n\x0cnew_password\x18\x02\x20\x01(\x0cR\x0bnewPassword\"\x18\n\
    \x16ChangePasswordResponse\"\x99\x02\n\x0bTransaction\x12\x18\n\x07tx_ha\
    sh\x18\x01\x20\x01(\tR\x07tx_hash\x12\x16\n\x06amount\x18\x02\x20\x01(\
    \x03R\x06amount\x12,\n\x11num_confirmations\x18\x03\x20\x01(\x05R\x11num\
    _confirmations\x12\x1e\n\nblock_hash\x18\x04\x20\x01(\tR\nblock_hash\x12\
    \"\n\x0cblock_height\x18\x05\x20\x01(\x05R\x0cblock_height\x12\x1e\n\nti\
    me_stamp\x18\x06\x20\x01(\x03R\ntime_stamp\x12\x1e\n\ntotal_fees\x18\x07\
    \x20\x01(\x03R\ntotal_fees\x12&\n\x0edest_addresses\x18\x08\x20\x03(\tR\
    \x0edest_addresses\"\x18\n\x16GetTransactionsRequest\"L\n\x12Transaction\
    Details\x126\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x12.lnrpc.Transacti\
    onR\x0ctransactions\"G\n\x08FeeLimit\x12\x16\n\x05fixed\x18\x01\x20\x01(\
    \x03H\0R\x05fixed\x12\x1a\n\x07percent\x18\x02\x20\x01(\x03H\0R\x07perce\
    ntB\x07\n\x05limit\"\xa8\x02\n\x0bSendRequest\x12\x12\n\x04dest\x18\x01\
    \x20\x01(\x0cR\x04dest\x12\x1f\n\x0bdest_string\x18\x02\x20\x01(\tR\ndes\
    tString\x12\x10\n\x03amt\x18\x03\x20\x01(\x03R\x03amt\x12!\n\x0cpayment_\
    hash\x18\x04\x20\x01(\x0cR\x0bpaymentHash\x12.\n\x13payment_hash_string\
    \x18\x05\x20\x01(\tR\x11paymentHashString\x12'\n\x0fpayment_request\x18\
    \x06\x20\x01(\tR\x0epaymentRequest\x12(\n\x10final_cltv_delta\x18\x07\
    \x20\x01(\x05R\x0efinalCltvDelta\x12,\n\tfee_limit\x18\x08\x20\x01(\x0b2\
    \x0f.lnrpc.FeeLimitR\x08feeLimit\"\x94\x01\n\x0cSendResponse\x12$\n\rpay\
    ment_error\x18\x01\x20\x01(\tR\rpayment_error\x12*\n\x10payment_preimage\
    \x18\x02\x20\x01(\x0cR\x10payment_preimage\x122\n\rpayment_route\x18\x03\
    \x20\x01(\x0b2\x0c.lnrpc.RouteR\rpayment_route\"\x8d\x01\n\x12SendToRout\
    eRequest\x12!\n\x0cpayment_hash\x18\x01\x20\x01(\x0cR\x0bpaymentHash\x12\
    .\n\x13payment_hash_string\x18\x02\x20\x01(\tR\x11paymentHashString\x12$\
    \n\x06routes\x18\x03\x20\x03(\x0b2\x0c.lnrpc.RouteR\x06routes\"\xa2\x01\
    \n\x0cChannelPoint\x120\n\x12funding_txid_bytes\x18\x01\x20\x01(\x0cH\0R\
    \x12funding_txid_bytes\x12,\n\x10funding_txid_str\x18\x02\x20\x01(\tH\0R\
    \x10funding_txid_str\x12\"\n\x0coutput_index\x18\x03\x20\x01(\rR\x0coutp\
    ut_indexB\x0e\n\x0cfunding_txid\">\n\x10LightningAddress\x12\x16\n\x06pu\
    bkey\x18\x01\x20\x01(\tR\x06pubkey\x12\x12\n\x04host\x18\x02\x20\x01(\tR\
    \x04host\"\xe3\x01\n\x0fSendManyRequest\x12L\n\x0cAddrToAmount\x18\x01\
    \x20\x03(\x0b2(.lnrpc.SendManyRequest.AddrToAmountEntryR\x0cAddrToAmount\
    \x12\x1f\n\x0btarget_conf\x18\x03\x20\x01(\x05R\ntargetConf\x12\x20\n\
    \x0csat_per_byte\x18\x05\x20\x01(\x03R\nsatPerByte\x1a?\n\x11AddrToAmoun\
    tEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x03R\x05value:\x028\x01\"&\n\x10SendManyResponse\x12\
    \x12\n\x04txid\x18\x01\x20\x01(\tR\x04txid\"\x81\x01\n\x10SendCoinsReque\
    st\x12\x12\n\x04addr\x18\x01\x20\x01(\tR\x04addr\x12\x16\n\x06amount\x18\
    \x02\x20\x01(\x03R\x06amount\x12\x1f\n\x0btarget_conf\x18\x03\x20\x01(\
    \x05R\ntargetConf\x12\x20\n\x0csat_per_byte\x18\x05\x20\x01(\x03R\nsatPe\
    rByte\"'\n\x11SendCoinsResponse\x12\x12\n\x04txid\x18\x01\x20\x01(\tR\
    \x04txid\"\x8d\x01\n\x11NewAddressRequest\x128\n\x04type\x18\x01\x20\x01\
    (\x0e2$.lnrpc.NewAddressRequest.AddressTypeR\x04type\">\n\x0bAddressType\
    \x12\x17\n\x13WITNESS_PUBKEY_HASH\x10\0\x12\x16\n\x12NESTED_PUBKEY_HASH\
    \x10\x01\".\n\x12NewAddressResponse\x12\x18\n\x07address\x18\x01\x20\x01\
    (\tR\x07address\"&\n\x12SignMessageRequest\x12\x10\n\x03msg\x18\x01\x20\
    \x01(\x0cR\x03msg\"3\n\x13SignMessageResponse\x12\x1c\n\tsignature\x18\
    \x01\x20\x01(\tR\tsignature\"F\n\x14VerifyMessageRequest\x12\x10\n\x03ms\
    g\x18\x01\x20\x01(\x0cR\x03msg\x12\x1c\n\tsignature\x18\x02\x20\x01(\tR\
    \tsignature\"E\n\x15VerifyMessageResponse\x12\x14\n\x05valid\x18\x01\x20\
    \x01(\x08R\x05valid\x12\x16\n\x06pubkey\x18\x02\x20\x01(\tR\x06pubkey\"U\
    \n\x12ConnectPeerRequest\x12+\n\x04addr\x18\x01\x20\x01(\x0b2\x17.lnrpc.\
    LightningAddressR\x04addr\x12\x12\n\x04perm\x18\x02\x20\x01(\x08R\x04per\
    m\"\x15\n\x13ConnectPeerResponse\"1\n\x15DisconnectPeerRequest\x12\x18\n\
    \x07pub_key\x18\x01\x20\x01(\tR\x07pub_key\"\x18\n\x16DisconnectPeerResp\
    onse\"\x86\x01\n\x04HTLC\x12\x1a\n\x08incoming\x18\x01\x20\x01(\x08R\x08\
    incoming\x12\x16\n\x06amount\x18\x02\x20\x01(\x03R\x06amount\x12\x1c\n\t\
    hash_lock\x18\x03\x20\x01(\x0cR\thash_lock\x12,\n\x11expiration_height\
    \x18\x04\x20\x01(\rR\x11expiration_height\"\xfe\x04\n\x07Channel\x12\x16\
    \n\x06active\x18\x01\x20\x01(\x08R\x06active\x12$\n\rremote_pubkey\x18\
    \x02\x20\x01(\tR\rremote_pubkey\x12$\n\rchannel_point\x18\x03\x20\x01(\t\
    R\rchannel_point\x12\x18\n\x07chan_id\x18\x04\x20\x01(\x04R\x07chan_id\
    \x12\x1a\n\x08capacity\x18\x05\x20\x01(\x03R\x08capacity\x12$\n\rlocal_b\
    alance\x18\x06\x20\x01(\x03R\rlocal_balance\x12&\n\x0eremote_balance\x18\
    \x07\x20\x01(\x03R\x0eremote_balance\x12\x1e\n\ncommit_fee\x18\x08\x20\
    \x01(\x03R\ncommit_fee\x12$\n\rcommit_weight\x18\t\x20\x01(\x03R\rcommit\
    _weight\x12\x1e\n\nfee_per_kw\x18\n\x20\x01(\x03R\nfee_per_kw\x12,\n\x11\
    unsettled_balance\x18\x0b\x20\x01(\x03R\x11unsettled_balance\x120\n\x13t\
    otal_satoshis_sent\x18\x0c\x20\x01(\x03R\x13total_satoshis_sent\x128\n\
    \x17total_satoshis_received\x18\r\x20\x01(\x03R\x17total_satoshis_receiv\
    ed\x12\x20\n\x0bnum_updates\x18\x0e\x20\x01(\x04R\x0bnum_updates\x121\n\
    \rpending_htlcs\x18\x0f\x20\x03(\x0b2\x0b.lnrpc.HTLCR\rpending_htlcs\x12\
    \x1c\n\tcsv_delay\x18\x10\x20\x01(\rR\tcsv_delay\x12\x18\n\x07private\
    \x18\x11\x20\x01(\x08R\x07private\"\x9f\x01\n\x13ListChannelsRequest\x12\
    \x1f\n\x0bactive_only\x18\x01\x20\x01(\x08R\nactiveOnly\x12#\n\rinactive\
    _only\x18\x02\x20\x01(\x08R\x0cinactiveOnly\x12\x1f\n\x0bpublic_only\x18\
    \x03\x20\x01(\x08R\npublicOnly\x12!\n\x0cprivate_only\x18\x04\x20\x01(\
    \x08R\x0bprivateOnly\"B\n\x14ListChannelsResponse\x12*\n\x08channels\x18\
    \x0b\x20\x03(\x0b2\x0e.lnrpc.ChannelR\x08channels\"\xb6\x04\n\x13Channel\
    CloseSummary\x12$\n\rchannel_point\x18\x01\x20\x01(\tR\rchannel_point\
    \x12\x18\n\x07chan_id\x18\x02\x20\x01(\x04R\x07chan_id\x12\x1e\n\nchain_\
    hash\x18\x03\x20\x01(\tR\nchain_hash\x12(\n\x0fclosing_tx_hash\x18\x04\
    \x20\x01(\tR\x0fclosing_tx_hash\x12$\n\rremote_pubkey\x18\x05\x20\x01(\t\
    R\rremote_pubkey\x12\x1a\n\x08capacity\x18\x06\x20\x01(\x03R\x08capacity\
    \x12\"\n\x0cclose_height\x18\x07\x20\x01(\rR\x0cclose_height\x12(\n\x0fs\
    ettled_balance\x18\x08\x20\x01(\x03R\x0fsettled_balance\x120\n\x13time_l\
    ocked_balance\x18\t\x20\x01(\x03R\x13time_locked_balance\x12F\n\nclose_t\
    ype\x18\n\x20\x01(\x0e2&.lnrpc.ChannelCloseSummary.ClosureTypeR\nclose_t\
    ype\"\x8a\x01\n\x0bClosureType\x12\x15\n\x11COOPERATIVE_CLOSE\x10\0\x12\
    \x15\n\x11LOCAL_FORCE_CLOSE\x10\x01\x12\x16\n\x12REMOTE_FORCE_CLOSE\x10\
    \x02\x12\x10\n\x0cBREACH_CLOSE\x10\x03\x12\x14\n\x10FUNDING_CANCELED\x10\
    \x04\x12\r\n\tABANDONED\x10\x05\"\xde\x01\n\x15ClosedChannelsRequest\x12\
    \x20\n\x0bcooperative\x18\x01\x20\x01(\x08R\x0bcooperative\x12\x1f\n\x0b\
    local_force\x18\x02\x20\x01(\x08R\nlocalForce\x12!\n\x0cremote_force\x18\
    \x03\x20\x01(\x08R\x0bremoteForce\x12\x16\n\x06breach\x18\x04\x20\x01(\
    \x08R\x06breach\x12)\n\x10funding_canceled\x18\x05\x20\x01(\x08R\x0ffund\
    ingCanceled\x12\x1c\n\tabandoned\x18\x06\x20\x01(\x08R\tabandoned\"P\n\
    \x16ClosedChannelsResponse\x126\n\x08channels\x18\x01\x20\x03(\x0b2\x1a.\
    lnrpc.ChannelCloseSummaryR\x08channels\"\xea\x01\n\x04Peer\x12\x18\n\x07\
    pub_key\x18\x01\x20\x01(\tR\x07pub_key\x12\x18\n\x07address\x18\x03\x20\
    \x01(\tR\x07address\x12\x1e\n\nbytes_sent\x18\x04\x20\x01(\x04R\nbytes_s\
    ent\x12\x1e\n\nbytes_recv\x18\x05\x20\x01(\x04R\nbytes_recv\x12\x1a\n\
    \x08sat_sent\x18\x06\x20\x01(\x03R\x08sat_sent\x12\x1a\n\x08sat_recv\x18\
    \x07\x20\x01(\x03R\x08sat_recv\x12\x18\n\x07inbound\x18\x08\x20\x01(\x08\
    R\x07inbound\x12\x1c\n\tping_time\x18\t\x20\x01(\x03R\tping_time\"\x12\n\
    \x10ListPeersRequest\"6\n\x11ListPeersResponse\x12!\n\x05peers\x18\x01\
    \x20\x03(\x0b2\x0b.lnrpc.PeerR\x05peers\"\x10\n\x0eGetInfoRequest\"\x8f\
    \x04\n\x0fGetInfoResponse\x12(\n\x0fidentity_pubkey\x18\x01\x20\x01(\tR\
    \x0fidentity_pubkey\x12\x14\n\x05alias\x18\x02\x20\x01(\tR\x05alias\x122\
    \n\x14num_pending_channels\x18\x03\x20\x01(\rR\x14num_pending_channels\
    \x120\n\x13num_active_channels\x18\x04\x20\x01(\rR\x13num_active_channel\
    s\x12\x1c\n\tnum_peers\x18\x05\x20\x01(\rR\tnum_peers\x12\"\n\x0cblock_h\
    eight\x18\x06\x20\x01(\rR\x0cblock_height\x12\x1e\n\nblock_hash\x18\x08\
    \x20\x01(\tR\nblock_hash\x12(\n\x0fsynced_to_chain\x18\t\x20\x01(\x08R\
    \x0fsynced_to_chain\x12\x18\n\x07testnet\x18\n\x20\x01(\x08R\x07testnet\
    \x12\x16\n\x06chains\x18\x0b\x20\x03(\tR\x06chains\x12\x12\n\x04uris\x18\
    \x0c\x20\x03(\tR\x04uris\x124\n\x15best_header_timestamp\x18\r\x20\x01(\
    \x03R\x15best_header_timestamp\x12\x18\n\x07version\x18\x0e\x20\x01(\tR\
    \x07version\x124\n\x15num_inactive_channels\x18\x0f\x20\x01(\rR\x15num_i\
    nactive_channels\"z\n\x12ConfirmationUpdate\x12\x1b\n\tblock_sha\x18\x01\
    \x20\x01(\x0cR\x08blockSha\x12!\n\x0cblock_height\x18\x02\x20\x01(\x05R\
    \x0bblockHeight\x12$\n\x0enum_confs_left\x18\x03\x20\x01(\rR\x0cnumConfs\
    Left\"N\n\x11ChannelOpenUpdate\x129\n\rchannel_point\x18\x01\x20\x01(\
    \x0b2\x13.lnrpc.ChannelPointR\rchannel_point\"R\n\x12ChannelCloseUpdate\
    \x12\"\n\x0cclosing_txid\x18\x01\x20\x01(\x0cR\x0cclosing_txid\x12\x18\n\
    \x07success\x18\x02\x20\x01(\x08R\x07success\"\xa8\x01\n\x13CloseChannel\
    Request\x128\n\rchannel_point\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPoi\
    ntR\x0cchannelPoint\x12\x14\n\x05force\x18\x02\x20\x01(\x08R\x05force\
    \x12\x1f\n\x0btarget_conf\x18\x03\x20\x01(\x05R\ntargetConf\x12\x20\n\
    \x0csat_per_byte\x18\x04\x20\x01(\x03R\nsatPerByte\"\xd9\x01\n\x11CloseS\
    tatusUpdate\x12<\n\rclose_pending\x18\x01\x20\x01(\x0b2\x14.lnrpc.Pendin\
    gUpdateH\0R\rclose_pending\x12?\n\x0cconfirmation\x18\x02\x20\x01(\x0b2\
    \x19.lnrpc.ConfirmationUpdateH\0R\x0cconfirmation\x12;\n\nchan_close\x18\
    \x03\x20\x01(\x0b2\x19.lnrpc.ChannelCloseUpdateH\0R\nchan_closeB\x08\n\
    \x06update\"G\n\rPendingUpdate\x12\x12\n\x04txid\x18\x01\x20\x01(\x0cR\
    \x04txid\x12\"\n\x0coutput_index\x18\x02\x20\x01(\rR\x0coutput_index\"\
    \xb1\x03\n\x12OpenChannelRequest\x12\x20\n\x0bnode_pubkey\x18\x02\x20\
    \x01(\x0cR\x0bnode_pubkey\x12.\n\x12node_pubkey_string\x18\x03\x20\x01(\
    \tR\x12node_pubkey_string\x122\n\x14local_funding_amount\x18\x04\x20\x01\
    (\x03R\x14local_funding_amount\x12\x1a\n\x08push_sat\x18\x05\x20\x01(\
    \x03R\x08push_sat\x12\x1f\n\x0btarget_conf\x18\x06\x20\x01(\x05R\ntarget\
    Conf\x12\x20\n\x0csat_per_byte\x18\x07\x20\x01(\x03R\nsatPerByte\x12\x18\
    \n\x07private\x18\x08\x20\x01(\x08R\x07private\x12$\n\rmin_htlc_msat\x18\
    \t\x20\x01(\x03R\rmin_htlc_msat\x12*\n\x10remote_csv_delay\x18\n\x20\x01\
    (\rR\x10remote_csv_delay\x12\x1c\n\tmin_confs\x18\x0b\x20\x01(\x05R\tmin\
    _confs\x12,\n\x11spend_unconfirmed\x18\x0c\x20\x01(\x08R\x11spend_unconf\
    irmed\"\xd3\x01\n\x10OpenStatusUpdate\x12:\n\x0cchan_pending\x18\x01\x20\
    \x01(\x0b2\x14.lnrpc.PendingUpdateH\0R\x0cchan_pending\x12?\n\x0cconfirm\
    ation\x18\x02\x20\x01(\x0b2\x19.lnrpc.ConfirmationUpdateH\0R\x0cconfirma\
    tion\x128\n\tchan_open\x18\x03\x20\x01(\x0b2\x18.lnrpc.ChannelOpenUpdate\
    H\0R\tchan_openB\x08\n\x06update\"\xcf\x01\n\x0bPendingHTLC\x12\x1a\n\
    \x08incoming\x18\x01\x20\x01(\x08R\x08incoming\x12\x16\n\x06amount\x18\
    \x02\x20\x01(\x03R\x06amount\x12\x1a\n\x08outpoint\x18\x03\x20\x01(\tR\
    \x08outpoint\x12(\n\x0fmaturity_height\x18\x04\x20\x01(\rR\x0fmaturity_h\
    eight\x120\n\x13blocks_til_maturity\x18\x05\x20\x01(\x05R\x13blocks_til_\
    maturity\x12\x14\n\x05stage\x18\x06\x20\x01(\rR\x05stage\"\x18\n\x16Pend\
    ingChannelsRequest\"\xbd\x0c\n\x17PendingChannelsResponse\x120\n\x13tota\
    l_limbo_balance\x18\x01\x20\x01(\x03R\x13total_limbo_balance\x12g\n\x15p\
    ending_open_channels\x18\x02\x20\x03(\x0b21.lnrpc.PendingChannelsRespons\
    e.PendingOpenChannelR\x15pending_open_channels\x12h\n\x18pending_closing\
    _channels\x18\x03\x20\x03(\x0b2,.lnrpc.PendingChannelsResponse.ClosedCha\
    nnelR\x18pending_closing_channels\x12y\n\x1epending_force_closing_channe\
    ls\x18\x04\x20\x03(\x0b21.lnrpc.PendingChannelsResponse.ForceClosedChann\
    elR\x1epending_force_closing_channels\x12j\n\x16waiting_close_channels\
    \x18\x05\x20\x03(\x0b22.lnrpc.PendingChannelsResponse.WaitingCloseChanne\
    lR\x16waiting_close_channels\x1a\xca\x01\n\x0ePendingChannel\x12(\n\x0fr\
    emote_node_pub\x18\x01\x20\x01(\tR\x0fremote_node_pub\x12$\n\rchannel_po\
    int\x18\x02\x20\x01(\tR\rchannel_point\x12\x1a\n\x08capacity\x18\x03\x20\
    \x01(\x03R\x08capacity\x12$\n\rlocal_balance\x18\x04\x20\x01(\x03R\rloca\
    l_balance\x12&\n\x0eremote_balance\x18\x05\x20\x01(\x03R\x0eremote_balan\
    ce\x1a\xf5\x01\n\x12PendingOpenChannel\x12G\n\x07channel\x18\x01\x20\x01\
    (\x0b2-.lnrpc.PendingChannelsResponse.PendingChannelR\x07channel\x120\n\
    \x13confirmation_height\x18\x02\x20\x01(\rR\x13confirmation_height\x12\
    \x1e\n\ncommit_fee\x18\x04\x20\x01(\x03R\ncommit_fee\x12$\n\rcommit_weig\
    ht\x18\x05\x20\x01(\x03R\rcommit_weight\x12\x1e\n\nfee_per_kw\x18\x06\
    \x20\x01(\x03R\nfee_per_kw\x1a\x84\x01\n\x13WaitingCloseChannel\x12G\n\
    \x07channel\x18\x01\x20\x01(\x0b2-.lnrpc.PendingChannelsResponse.Pending\
    ChannelR\x07channel\x12$\n\rlimbo_balance\x18\x02\x20\x01(\x03R\rlimbo_b\
    alance\x1a|\n\rClosedChannel\x12G\n\x07channel\x18\x01\x20\x01(\x0b2-.ln\
    rpc.PendingChannelsResponse.PendingChannelR\x07channel\x12\"\n\x0cclosin\
    g_txid\x18\x02\x20\x01(\tR\x0cclosing_txid\x1a\xeb\x02\n\x12ForceClosedC\
    hannel\x12G\n\x07channel\x18\x01\x20\x01(\x0b2-.lnrpc.PendingChannelsRes\
    ponse.PendingChannelR\x07channel\x12\"\n\x0cclosing_txid\x18\x02\x20\x01\
    (\tR\x0cclosing_txid\x12$\n\rlimbo_balance\x18\x03\x20\x01(\x03R\rlimbo_\
    balance\x12(\n\x0fmaturity_height\x18\x04\x20\x01(\rR\x0fmaturity_height\
    \x120\n\x13blocks_til_maturity\x18\x05\x20\x01(\x05R\x13blocks_til_matur\
    ity\x12,\n\x11recovered_balance\x18\x06\x20\x01(\x03R\x11recovered_balan\
    ce\x128\n\rpending_htlcs\x18\x08\x20\x03(\x0b2\x12.lnrpc.PendingHTLCR\rp\
    ending_htlcs\"\x16\n\x14WalletBalanceRequest\"\x9d\x01\n\x15WalletBalanc\
    eResponse\x12$\n\rtotal_balance\x18\x01\x20\x01(\x03R\rtotal_balance\x12\
    ,\n\x11confirmed_balance\x18\x02\x20\x01(\x03R\x11confirmed_balance\x120\
    \n\x13unconfirmed_balance\x18\x03\x20\x01(\x03R\x13unconfirmed_balance\"\
    \x17\n\x15ChannelBalanceRequest\"f\n\x16ChannelBalanceResponse\x12\x18\n\
    \x07balance\x18\x01\x20\x01(\x03R\x07balance\x122\n\x14pending_open_bala\
    nce\x18\x02\x20\x01(\x03R\x14pending_open_balance\"\xb6\x01\n\x12QueryRo\
    utesRequest\x12\x17\n\x07pub_key\x18\x01\x20\x01(\tR\x06pubKey\x12\x10\n\
    \x03amt\x18\x02\x20\x01(\x03R\x03amt\x12\x1d\n\nnum_routes\x18\x03\x20\
    \x01(\x05R\tnumRoutes\x12(\n\x10final_cltv_delta\x18\x04\x20\x01(\x05R\
    \x0efinalCltvDelta\x12,\n\tfee_limit\x18\x05\x20\x01(\x0b2\x0f.lnrpc.Fee\
    LimitR\x08feeLimit\";\n\x13QueryRoutesResponse\x12$\n\x06routes\x18\x01\
    \x20\x03(\x0b2\x0c.lnrpc.RouteR\x06routes\"\x87\x02\n\x03Hop\x12\x18\n\
    \x07chan_id\x18\x01\x20\x01(\x04R\x07chan_id\x12$\n\rchan_capacity\x18\
    \x02\x20\x01(\x03R\rchan_capacity\x12*\n\x0eamt_to_forward\x18\x03\x20\
    \x01(\x03R\x0eamt_to_forwardB\x02\x18\x01\x12\x14\n\x03fee\x18\x04\x20\
    \x01(\x03R\x03feeB\x02\x18\x01\x12\x16\n\x06expiry\x18\x05\x20\x01(\rR\
    \x06expiry\x120\n\x13amt_to_forward_msat\x18\x06\x20\x01(\x03R\x13amt_to\
    _forward_msat\x12\x1a\n\x08fee_msat\x18\x07\x20\x01(\x03R\x08fee_msat\
    \x12\x18\n\x07pub_key\x18\x08\x20\x01(\tR\x07pub_key\"\xe9\x01\n\x05Rout\
    e\x12(\n\x0ftotal_time_lock\x18\x01\x20\x01(\rR\x0ftotal_time_lock\x12\"\
    \n\ntotal_fees\x18\x02\x20\x01(\x03R\ntotal_feesB\x02\x18\x01\x12\x20\n\
    \ttotal_amt\x18\x03\x20\x01(\x03R\ttotal_amtB\x02\x18\x01\x12\x1e\n\x04h\
    ops\x18\x04\x20\x03(\x0b2\n.lnrpc.HopR\x04hops\x12(\n\x0ftotal_fees_msat\
    \x18\x05\x20\x01(\x03R\x0ftotal_fees_msat\x12&\n\x0etotal_amt_msat\x18\
    \x06\x20\x01(\x03R\x0etotal_amt_msat\"*\n\x0fNodeInfoRequest\x12\x17\n\
    \x07pub_key\x18\x01\x20\x01(\tR\x06pubKey\"\x80\x01\n\x08NodeInfo\x12(\n\
    \x04node\x18\x01\x20\x01(\x0b2\x14.lnrpc.LightningNodeR\x04node\x12\"\n\
    \x0cnum_channels\x18\x02\x20\x01(\rR\x0cnum_channels\x12&\n\x0etotal_cap\
    acity\x18\x03\x20\x01(\x03R\x0etotal_capacity\"\xa9\x01\n\rLightningNode\
    \x12\x20\n\x0blast_update\x18\x01\x20\x01(\rR\x0blast_update\x12\x18\n\
    \x07pub_key\x18\x02\x20\x01(\tR\x07pub_key\x12\x14\n\x05alias\x18\x03\
    \x20\x01(\tR\x05alias\x120\n\taddresses\x18\x04\x20\x03(\x0b2\x12.lnrpc.\
    NodeAddressR\taddresses\x12\x14\n\x05color\x18\x05\x20\x01(\tR\x05color\
    \";\n\x0bNodeAddress\x12\x18\n\x07network\x18\x01\x20\x01(\tR\x07network\
    \x12\x12\n\x04addr\x18\x02\x20\x01(\tR\x04addr\"\xc9\x01\n\rRoutingPolic\
    y\x12(\n\x0ftime_lock_delta\x18\x01\x20\x01(\rR\x0ftime_lock_delta\x12\
    \x1a\n\x08min_htlc\x18\x02\x20\x01(\x03R\x08min_htlc\x12$\n\rfee_base_ms\
    at\x18\x03\x20\x01(\x03R\rfee_base_msat\x120\n\x13fee_rate_milli_msat\
    \x18\x04\x20\x01(\x03R\x13fee_rate_milli_msat\x12\x1a\n\x08disabled\x18\
    \x05\x20\x01(\x08R\x08disabled\"\xbb\x02\n\x0bChannelEdge\x12\x1e\n\ncha\
    nnel_id\x18\x01\x20\x01(\x04R\nchannel_id\x12\x1e\n\nchan_point\x18\x02\
    \x20\x01(\tR\nchan_point\x12\x20\n\x0blast_update\x18\x03\x20\x01(\rR\
    \x0blast_update\x12\x1c\n\tnode1_pub\x18\x04\x20\x01(\tR\tnode1_pub\x12\
    \x1c\n\tnode2_pub\x18\x05\x20\x01(\tR\tnode2_pub\x12\x1a\n\x08capacity\
    \x18\x06\x20\x01(\x03R\x08capacity\x128\n\x0cnode1_policy\x18\x07\x20\
    \x01(\x0b2\x14.lnrpc.RoutingPolicyR\x0cnode1_policy\x128\n\x0cnode2_poli\
    cy\x18\x08\x20\x01(\x0b2\x14.lnrpc.RoutingPolicyR\x0cnode2_policy\"G\n\
    \x13ChannelGraphRequest\x120\n\x13include_unannounced\x18\x01\x20\x01(\
    \x08R\x13include_unannounced\"d\n\x0cChannelGraph\x12*\n\x05nodes\x18\
    \x01\x20\x03(\x0b2\x14.lnrpc.LightningNodeR\x05nodes\x12(\n\x05edges\x18\
    \x02\x20\x03(\x0b2\x12.lnrpc.ChannelEdgeR\x05edges\"*\n\x0fChanInfoReque\
    st\x12\x17\n\x07chan_id\x18\x01\x20\x01(\x04R\x06chanId\"\x14\n\x12Netwo\
    rkInfoRequest\"\x83\x03\n\x0bNetworkInfo\x12&\n\x0egraph_diameter\x18\
    \x01\x20\x01(\rR\x0egraph_diameter\x12&\n\x0eavg_out_degree\x18\x02\x20\
    \x01(\x01R\x0eavg_out_degree\x12&\n\x0emax_out_degree\x18\x03\x20\x01(\r\
    R\x0emax_out_degree\x12\x1c\n\tnum_nodes\x18\x04\x20\x01(\rR\tnum_nodes\
    \x12\"\n\x0cnum_channels\x18\x05\x20\x01(\rR\x0cnum_channels\x126\n\x16t\
    otal_network_capacity\x18\x06\x20\x01(\x03R\x16total_network_capacity\
    \x12*\n\x10avg_channel_size\x18\x07\x20\x01(\x01R\x10avg_channel_size\
    \x12*\n\x10min_channel_size\x18\x08\x20\x01(\x03R\x10min_channel_size\
    \x12*\n\x10max_channel_size\x18\t\x20\x01(\x03R\x10max_channel_size\"\r\
    \n\x0bStopRequest\"\x0e\n\x0cStopResponse\"\x1b\n\x19GraphTopologySubscr\
    iption\"\xcd\x01\n\x13GraphTopologyUpdate\x124\n\x0cnode_updates\x18\x01\
    \x20\x03(\x0b2\x11.lnrpc.NodeUpdateR\x0bnodeUpdates\x12A\n\x0fchannel_up\
    dates\x18\x02\x20\x03(\x0b2\x18.lnrpc.ChannelEdgeUpdateR\x0echannelUpdat\
    es\x12=\n\x0cclosed_chans\x18\x03\x20\x03(\x0b2\x1a.lnrpc.ClosedChannelU\
    pdateR\x0bclosedChans\"\x8c\x01\n\nNodeUpdate\x12\x1c\n\taddresses\x18\
    \x01\x20\x03(\tR\taddresses\x12!\n\x0cidentity_key\x18\x02\x20\x01(\tR\
    \x0bidentityKey\x12'\n\x0fglobal_features\x18\x03\x20\x01(\x0cR\x0egloba\
    lFeatures\x12\x14\n\x05alias\x18\x04\x20\x01(\tR\x05alias\"\x8d\x02\n\
    \x11ChannelEdgeUpdate\x12\x17\n\x07chan_id\x18\x01\x20\x01(\x04R\x06chan\
    Id\x122\n\nchan_point\x18\x02\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\tcha\
    nPoint\x12\x1a\n\x08capacity\x18\x03\x20\x01(\x03R\x08capacity\x12;\n\
    \x0erouting_policy\x18\x04\x20\x01(\x0b2\x14.lnrpc.RoutingPolicyR\rrouti\
    ngPolicy\x12)\n\x10advertising_node\x18\x05\x20\x01(\tR\x0fadvertisingNo\
    de\x12'\n\x0fconnecting_node\x18\x06\x20\x01(\tR\x0econnectingNode\"\xa3\
    \x01\n\x13ClosedChannelUpdate\x12\x17\n\x07chan_id\x18\x01\x20\x01(\x04R\
    \x06chanId\x12\x1a\n\x08capacity\x18\x02\x20\x01(\x03R\x08capacity\x12#\
    \n\rclosed_height\x18\x03\x20\x01(\rR\x0cclosedHeight\x122\n\nchan_point\
    \x18\x04\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\tchanPoint\"\xd3\x01\n\
    \x07HopHint\x12\x18\n\x07node_id\x18\x01\x20\x01(\tR\x07node_id\x12\x18\
    \n\x07chan_id\x18\x02\x20\x01(\x04R\x07chan_id\x12$\n\rfee_base_msat\x18\
    \x03\x20\x01(\rR\rfee_base_msat\x12@\n\x1bfee_proportional_millionths\
    \x18\x04\x20\x01(\rR\x1bfee_proportional_millionths\x12,\n\x11cltv_expir\
    y_delta\x18\x05\x20\x01(\rR\x11cltv_expiry_delta\"9\n\tRouteHint\x12,\n\
    \thop_hints\x18\x01\x20\x03(\x0b2\x0e.lnrpc.HopHintR\thop_hints\"\x97\
    \x05\n\x07Invoice\x12\x12\n\x04memo\x18\x01\x20\x01(\tR\x04memo\x12\x18\
    \n\x07receipt\x18\x02\x20\x01(\x0cR\x07receipt\x12\x1e\n\nr_preimage\x18\
    \x03\x20\x01(\x0cR\nr_preimage\x12\x16\n\x06r_hash\x18\x04\x20\x01(\x0cR\
    \x06r_hash\x12\x14\n\x05value\x18\x05\x20\x01(\x03R\x05value\x12\x18\n\
    \x07settled\x18\x06\x20\x01(\x08R\x07settled\x12$\n\rcreation_date\x18\
    \x07\x20\x01(\x03R\rcreation_date\x12\x20\n\x0bsettle_date\x18\x08\x20\
    \x01(\x03R\x0bsettle_date\x12(\n\x0fpayment_request\x18\t\x20\x01(\tR\
    \x0fpayment_request\x12*\n\x10description_hash\x18\n\x20\x01(\x0cR\x10de\
    scription_hash\x12\x16\n\x06expiry\x18\x0b\x20\x01(\x03R\x06expiry\x12$\
    \n\rfallback_addr\x18\x0c\x20\x01(\tR\rfallback_addr\x12\x20\n\x0bcltv_e\
    xpiry\x18\r\x20\x01(\x04R\x0bcltv_expiry\x122\n\x0broute_hints\x18\x0e\
    \x20\x03(\x0b2\x10.lnrpc.RouteHintR\x0broute_hints\x12\x18\n\x07private\
    \x18\x0f\x20\x01(\x08R\x07private\x12\x1c\n\tadd_index\x18\x10\x20\x01(\
    \x04R\tadd_index\x12\"\n\x0csettle_index\x18\x11\x20\x01(\x04R\x0csettle\
    _index\x12\x1e\n\x08amt_paid\x18\x12\x20\x01(\x03R\x08amt_paidB\x02\x18\
    \x01\x12\"\n\x0camt_paid_sat\x18\x13\x20\x01(\x03R\x0camt_paid_sat\x12$\
    \n\ramt_paid_msat\x18\x14\x20\x01(\x03R\ramt_paid_msat\"t\n\x12AddInvoic\
    eResponse\x12\x16\n\x06r_hash\x18\x01\x20\x01(\x0cR\x06r_hash\x12(\n\x0f\
    payment_request\x18\x02\x20\x01(\tR\x0fpayment_request\x12\x1c\n\tadd_in\
    dex\x18\x10\x20\x01(\x04R\tadd_index\"E\n\x0bPaymentHash\x12\x1e\n\nr_ha\
    sh_str\x18\x01\x20\x01(\tR\nr_hash_str\x12\x16\n\x06r_hash\x18\x02\x20\
    \x01(\x0cR\x06r_hash\"\xa4\x01\n\x12ListInvoiceRequest\x12\"\n\x0cpendin\
    g_only\x18\x01\x20\x01(\x08R\x0cpending_only\x12\"\n\x0cindex_offset\x18\
    \x04\x20\x01(\x04R\x0cindex_offset\x12*\n\x10num_max_invoices\x18\x05\
    \x20\x01(\x04R\x10num_max_invoices\x12\x1a\n\x08reversed\x18\x06\x20\x01\
    (\x08R\x08reversed\"\x9f\x01\n\x13ListInvoiceResponse\x12*\n\x08invoices\
    \x18\x01\x20\x03(\x0b2\x0e.lnrpc.InvoiceR\x08invoices\x12,\n\x11last_ind\
    ex_offset\x18\x02\x20\x01(\x04R\x11last_index_offset\x12.\n\x12first_ind\
    ex_offset\x18\x03\x20\x01(\x04R\x12first_index_offset\"W\n\x13InvoiceSub\
    scription\x12\x1c\n\tadd_index\x18\x01\x20\x01(\x04R\tadd_index\x12\"\n\
    \x0csettle_index\x18\x02\x20\x01(\x04R\x0csettle_index\"\xfd\x01\n\x07Pa\
    yment\x12\"\n\x0cpayment_hash\x18\x01\x20\x01(\tR\x0cpayment_hash\x12\
    \x18\n\x05value\x18\x02\x20\x01(\x03R\x05valueB\x02\x18\x01\x12$\n\rcrea\
    tion_date\x18\x03\x20\x01(\x03R\rcreation_date\x12\x12\n\x04path\x18\x04\
    \x20\x03(\tR\x04path\x12\x10\n\x03fee\x18\x05\x20\x01(\x03R\x03fee\x12*\
    \n\x10payment_preimage\x18\x06\x20\x01(\tR\x10payment_preimage\x12\x1c\n\
    \tvalue_sat\x18\x07\x20\x01(\x03R\tvalue_sat\x12\x1e\n\nvalue_msat\x18\
    \x08\x20\x01(\x03R\nvalue_msat\"\x15\n\x13ListPaymentsRequest\"B\n\x14Li\
    stPaymentsResponse\x12*\n\x08payments\x18\x01\x20\x03(\x0b2\x0e.lnrpc.Pa\
    ymentR\x08payments\"\x1a\n\x18DeleteAllPaymentsRequest\"\x1b\n\x19Delete\
    AllPaymentsResponse\"Q\n\x15AbandonChannelRequest\x128\n\rchannel_point\
    \x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\x0cchannelPoint\"\x18\n\
    \x16AbandonChannelResponse\"F\n\x11DebugLevelRequest\x12\x12\n\x04show\
    \x18\x01\x20\x01(\x08R\x04show\x12\x1d\n\nlevel_spec\x18\x02\x20\x01(\tR\
    \tlevelSpec\"6\n\x12DebugLevelResponse\x12\x20\n\x0bsub_systems\x18\x01\
    \x20\x01(\tR\x0bsub_systems\"'\n\x0cPayReqString\x12\x17\n\x07pay_req\
    \x18\x01\x20\x01(\tR\x06payReq\"\xf2\x02\n\x06PayReq\x12\x20\n\x0bdestin\
    ation\x18\x01\x20\x01(\tR\x0bdestination\x12\"\n\x0cpayment_hash\x18\x02\
    \x20\x01(\tR\x0cpayment_hash\x12\"\n\x0cnum_satoshis\x18\x03\x20\x01(\
    \x03R\x0cnum_satoshis\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\x03R\ttimest\
    amp\x12\x16\n\x06expiry\x18\x05\x20\x01(\x03R\x06expiry\x12\x20\n\x0bdes\
    cription\x18\x06\x20\x01(\tR\x0bdescription\x12*\n\x10description_hash\
    \x18\x07\x20\x01(\tR\x10description_hash\x12$\n\rfallback_addr\x18\x08\
    \x20\x01(\tR\rfallback_addr\x12\x20\n\x0bcltv_expiry\x18\t\x20\x01(\x03R\
    \x0bcltv_expiry\x122\n\x0broute_hints\x18\n\x20\x03(\x0b2\x10.lnrpc.Rout\
    eHintR\x0broute_hints\"\x12\n\x10FeeReportRequest\"\x99\x01\n\x10Channel\
    FeeReport\x12!\n\nchan_point\x18\x01\x20\x01(\tR\rchannel_point\x12$\n\r\
    base_fee_msat\x18\x02\x20\x01(\x03R\rbase_fee_msat\x12\x20\n\x0bfee_per_\
    mil\x18\x03\x20\x01(\x03R\x0bfee_per_mil\x12\x1a\n\x08fee_rate\x18\x04\
    \x20\x01(\x01R\x08fee_rate\"\xbc\x01\n\x11FeeReportResponse\x12;\n\x0cch\
    annel_fees\x18\x01\x20\x03(\x0b2\x17.lnrpc.ChannelFeeReportR\x0cchannel_\
    fees\x12\x20\n\x0bday_fee_sum\x18\x02\x20\x01(\x04R\x0bday_fee_sum\x12\"\
    \n\x0cweek_fee_sum\x18\x03\x20\x01(\x04R\x0cweek_fee_sum\x12$\n\rmonth_f\
    ee_sum\x18\x04\x20\x01(\x04R\rmonth_fee_sum\"\xdb\x01\n\x13PolicyUpdateR\
    equest\x12\x18\n\x06global\x18\x01\x20\x01(\x08H\0R\x06global\x125\n\nch\
    an_point\x18\x02\x20\x01(\x0b2\x13.lnrpc.ChannelPointH\0R\nchan_point\
    \x12$\n\rbase_fee_msat\x18\x03\x20\x01(\x03R\rbase_fee_msat\x12\x1a\n\
    \x08fee_rate\x18\x04\x20\x01(\x01R\x08fee_rate\x12(\n\x0ftime_lock_delta\
    \x18\x05\x20\x01(\rR\x0ftime_lock_deltaB\x07\n\x05scope\"\x16\n\x14Polic\
    yUpdateResponse\"\xa2\x01\n\x18ForwardingHistoryRequest\x12\x1e\n\nstart\
    _time\x18\x01\x20\x01(\x04R\nstart_time\x12\x1a\n\x08end_time\x18\x02\
    \x20\x01(\x04R\x08end_time\x12\"\n\x0cindex_offset\x18\x03\x20\x01(\rR\
    \x0cindex_offset\x12&\n\x0enum_max_events\x18\x04\x20\x01(\rR\x0enum_max\
    _events\"\xb5\x01\n\x0fForwardingEvent\x12\x1c\n\ttimestamp\x18\x01\x20\
    \x01(\x04R\ttimestamp\x12\x1e\n\nchan_id_in\x18\x02\x20\x01(\x04R\nchan_\
    id_in\x12\x20\n\x0bchan_id_out\x18\x04\x20\x01(\x04R\x0bchan_id_out\x12\
    \x16\n\x06amt_in\x18\x05\x20\x01(\x04R\x06amt_in\x12\x18\n\x07amt_out\
    \x18\x06\x20\x01(\x04R\x07amt_out\x12\x10\n\x03fee\x18\x07\x20\x01(\x04R\
    \x03fee\"\x8f\x01\n\x19ForwardingHistoryResponse\x12D\n\x11forwarding_ev\
    ents\x18\x01\x20\x03(\x0b2\x16.lnrpc.ForwardingEventR\x11forwarding_even\
    ts\x12,\n\x11last_offset_index\x18\x02\x20\x01(\rR\x11last_offset_index2\
    \x91\x03\n\x0eWalletUnlocker\x12M\n\x07GenSeed\x12\x15.lnrpc.GenSeedRequ\
    est\x1a\x16.lnrpc.GenSeedResponse\"\x13\x82\xd3\xe4\x93\x02\r\x12\x0b/v1\
    /genseed\x12\\\n\nInitWallet\x12\x18.lnrpc.InitWalletRequest\x1a\x19.lnr\
    pc.InitWalletResponse\"\x19\x82\xd3\xe4\x93\x02\x13\"\x0e/v1/initwallet:\
    \x01*\x12d\n\x0cUnlockWallet\x12\x1a.lnrpc.UnlockWalletRequest\x1a\x1b.l\
    nrpc.UnlockWalletResponse\"\x1b\x82\xd3\xe4\x93\x02\x15\"\x10/v1/unlockw\
    allet:\x01*\x12l\n\x0eChangePassword\x12\x1c.lnrpc.ChangePasswordRequest\
    \x1a\x1d.lnrpc.ChangePasswordResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\"\
    \x12/v1/changepassword:\x01*2\xdb\x1e\n\tLightning\x12j\n\rWalletBalance\
    \x12\x1b.lnrpc.WalletBalanceRequest\x1a\x1c.lnrpc.WalletBalanceResponse\
    \"\x1e\x82\xd3\xe4\x93\x02\x18\x12\x16/v1/balance/blockchain\x12k\n\x0eC\
    hannelBalance\x12\x1c.lnrpc.ChannelBalanceRequest\x1a\x1d.lnrpc.ChannelB\
    alanceResponse\"\x1c\x82\xd3\xe4\x93\x02\x16\x12\x14/v1/balance/channels\
    \x12e\n\x0fGetTransactions\x12\x1d.lnrpc.GetTransactionsRequest\x1a\x19.\
    lnrpc.TransactionDetails\"\x18\x82\xd3\xe4\x93\x02\x12\x12\x10/v1/transa\
    ctions\x12[\n\tSendCoins\x12\x17.lnrpc.SendCoinsRequest\x1a\x18.lnrpc.Se\
    ndCoinsResponse\"\x1b\x82\xd3\xe4\x93\x02\x15\"\x10/v1/transactions:\x01\
    *\x12L\n\x15SubscribeTransactions\x12\x1d.lnrpc.GetTransactionsRequest\
    \x1a\x12.lnrpc.Transaction0\x01\x12;\n\x08SendMany\x12\x16.lnrpc.SendMan\
    yRequest\x1a\x17.lnrpc.SendManyResponse\x12Y\n\nNewAddress\x12\x18.lnrpc\
    .NewAddressRequest\x1a\x19.lnrpc.NewAddressResponse\"\x16\x82\xd3\xe4\
    \x93\x02\x10\x12\x0e/v1/newaddress\x12D\n\x0bSignMessage\x12\x19.lnrpc.S\
    ignMessageRequest\x1a\x1a.lnrpc.SignMessageResponse\x12J\n\rVerifyMessag\
    e\x12\x1b.lnrpc.VerifyMessageRequest\x1a\x1c.lnrpc.VerifyMessageResponse\
    \x12Z\n\x0bConnectPeer\x12\x19.lnrpc.ConnectPeerRequest\x1a\x1a.lnrpc.Co\
    nnectPeerResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\"\t/v1/peers:\x01*\x12j\
    \n\x0eDisconnectPeer\x12\x1c.lnrpc.DisconnectPeerRequest\x1a\x1d.lnrpc.D\
    isconnectPeerResponse\"\x1b\x82\xd3\xe4\x93\x02\x15*\x13/v1/peers/{pub_k\
    ey}\x12Q\n\tListPeers\x12\x17.lnrpc.ListPeersRequest\x1a\x18.lnrpc.ListP\
    eersResponse\"\x11\x82\xd3\xe4\x93\x02\x0b\x12\t/v1/peers\x12M\n\x07GetI\
    nfo\x12\x15.lnrpc.GetInfoRequest\x1a\x16.lnrpc.GetInfoResponse\"\x13\x82\
    \xd3\xe4\x93\x02\r\x12\x0b/v1/getinfo\x12n\n\x0fPendingChannels\x12\x1d.\
    lnrpc.PendingChannelsRequest\x1a\x1e.lnrpc.PendingChannelsResponse\"\x1c\
    \x82\xd3\xe4\x93\x02\x16\x12\x14/v1/channels/pending\x12]\n\x0cListChann\
    els\x12\x1a.lnrpc.ListChannelsRequest\x1a\x1b.lnrpc.ListChannelsResponse\
    \"\x14\x82\xd3\xe4\x93\x02\x0e\x12\x0c/v1/channels\x12j\n\x0eClosedChann\
    els\x12\x1c.lnrpc.ClosedChannelsRequest\x1a\x1d.lnrpc.ClosedChannelsResp\
    onse\"\x1b\x82\xd3\xe4\x93\x02\x15\x12\x13/v1/channels/closed\x12Z\n\x0f\
    OpenChannelSync\x12\x19.lnrpc.OpenChannelRequest\x1a\x13.lnrpc.ChannelPo\
    int\"\x17\x82\xd3\xe4\x93\x02\x11\"\x0c/v1/channels:\x01*\x12C\n\x0bOpen\
    Channel\x12\x19.lnrpc.OpenChannelRequest\x1a\x17.lnrpc.OpenStatusUpdate0\
    \x01\x12\x9a\x01\n\x0cCloseChannel\x12\x1a.lnrpc.CloseChannelRequest\x1a\
    \x18.lnrpc.CloseStatusUpdate\"R\x82\xd3\xe4\x93\x02L*J/v1/channels/{chan\
    nel_point.funding_txid_str}/{channel_point.output_index}0\x01\x12\xa9\
    \x01\n\x0eAbandonChannel\x12\x1c.lnrpc.AbandonChannelRequest\x1a\x1d.lnr\
    pc.AbandonChannelResponse\"Z\x82\xd3\xe4\x93\x02T*R/v1/channels/abandon/\
    {channel_point.funding_txid_str}/{channel_point.output_index}\x12:\n\x0b\
    SendPayment\x12\x12.lnrpc.SendRequest\x1a\x13.lnrpc.SendResponse(\x010\
    \x01\x12`\n\x0fSendPaymentSync\x12\x12.lnrpc.SendRequest\x1a\x13.lnrpc.S\
    endResponse\"$\x82\xd3\xe4\x93\x02\x1e\"\x19/v1/channels/transactions:\
    \x01*\x12A\n\x0bSendToRoute\x12\x19.lnrpc.SendToRouteRequest\x1a\x13.lnr\
    pc.SendResponse(\x010\x01\x12m\n\x0fSendToRouteSync\x12\x19.lnrpc.SendTo\
    RouteRequest\x1a\x13.lnrpc.SendResponse\"*\x82\xd3\xe4\x93\x02$\"\x1f/v1\
    /channels/transactions/route:\x01*\x12P\n\nAddInvoice\x12\x0e.lnrpc.Invo\
    ice\x1a\x19.lnrpc.AddInvoiceResponse\"\x17\x82\xd3\xe4\x93\x02\x11\"\x0c\
    /v1/invoices:\x01*\x12[\n\x0cListInvoices\x12\x19.lnrpc.ListInvoiceReque\
    st\x1a\x1a.lnrpc.ListInvoiceResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\x12\
    \x0c/v1/invoices\x12U\n\rLookupInvoice\x12\x12.lnrpc.PaymentHash\x1a\x0e\
    .lnrpc.Invoice\"\x20\x82\xd3\xe4\x93\x02\x1a\x12\x18/v1/invoice/{r_hash_\
    str}\x12a\n\x11SubscribeInvoices\x12\x1a.lnrpc.InvoiceSubscription\x1a\
    \x0e.lnrpc.Invoice\"\x1e\x82\xd3\xe4\x93\x02\x18\x12\x16/v1/invoices/sub\
    scribe0\x01\x12P\n\x0cDecodePayReq\x12\x13.lnrpc.PayReqString\x1a\r.lnrp\
    c.PayReq\"\x1c\x82\xd3\xe4\x93\x02\x16\x12\x14/v1/payreq/{pay_req}\x12]\
    \n\x0cListPayments\x12\x1a.lnrpc.ListPaymentsRequest\x1a\x1b.lnrpc.ListP\
    aymentsResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\x12\x0c/v1/payments\x12l\n\
    \x11DeleteAllPayments\x12\x1f.lnrpc.DeleteAllPaymentsRequest\x1a\x20.lnr\
    pc.DeleteAllPaymentsResponse\"\x14\x82\xd3\xe4\x93\x02\x0e*\x0c/v1/payme\
    nts\x12S\n\rDescribeGraph\x12\x1a.lnrpc.ChannelGraphRequest\x1a\x13.lnrp\
    c.ChannelGraph\"\x11\x82\xd3\xe4\x93\x02\x0b\x12\t/v1/graph\x12[\n\x0bGe\
    tChanInfo\x12\x16.lnrpc.ChanInfoRequest\x1a\x12.lnrpc.ChannelEdge\"\x20\
    \x82\xd3\xe4\x93\x02\x1a\x12\x18/v1/graph/edge/{chan_id}\x12X\n\x0bGetNo\
    deInfo\x12\x16.lnrpc.NodeInfoRequest\x1a\x0f.lnrpc.NodeInfo\"\x20\x82\
    \xd3\xe4\x93\x02\x1a\x12\x18/v1/graph/node/{pub_key}\x12n\n\x0bQueryRout\
    es\x12\x19.lnrpc.QueryRoutesRequest\x1a\x1a.lnrpc.QueryRoutesResponse\"(\
    \x82\xd3\xe4\x93\x02\"\x12\x20/v1/graph/routes/{pub_key}/{amt}\x12W\n\
    \x0eGetNetworkInfo\x12\x19.lnrpc.NetworkInfoRequest\x1a\x12.lnrpc.Networ\
    kInfo\"\x16\x82\xd3\xe4\x93\x02\x10\x12\x0e/v1/graph/info\x125\n\nStopDa\
    emon\x12\x12.lnrpc.StopRequest\x1a\x13.lnrpc.StopResponse\x12W\n\x15Subs\
    cribeChannelGraph\x12\x20.lnrpc.GraphTopologySubscription\x1a\x1a.lnrpc.\
    GraphTopologyUpdate0\x01\x12A\n\nDebugLevel\x12\x18.lnrpc.DebugLevelRequ\
    est\x1a\x19.lnrpc.DebugLevelResponse\x12P\n\tFeeReport\x12\x17.lnrpc.Fee\
    ReportRequest\x1a\x18.lnrpc.FeeReportResponse\"\x10\x82\xd3\xe4\x93\x02\
    \n\x12\x08/v1/fees\x12i\n\x13UpdateChannelPolicy\x12\x1a.lnrpc.PolicyUpd\
    ateRequest\x1a\x1b.lnrpc.PolicyUpdateResponse\"\x19\x82\xd3\xe4\x93\x02\
    \x13\"\x0e/v1/chanpolicy:\x01*\x12m\n\x11ForwardingHistory\x12\x1f.lnrpc\
    .ForwardingHistoryRequest\x1a\x20.lnrpc.ForwardingHistoryResponse\"\x15\
    \x82\xd3\xe4\x93\x02\x0f\"\n/v1/switch:\x01*b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
