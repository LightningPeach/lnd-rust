// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `rpc.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct GenSeedRequest {
    // message fields
    pub aezeed_passphrase: ::std::vec::Vec<u8>,
    pub seed_entropy: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenSeedRequest {
    fn default() -> &'a GenSeedRequest {
        <GenSeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl GenSeedRequest {
    pub fn new() -> GenSeedRequest {
        ::std::default::Default::default()
    }

    // bytes aezeed_passphrase = 1;


    pub fn get_aezeed_passphrase(&self) -> &[u8] {
        &self.aezeed_passphrase
    }
    pub fn clear_aezeed_passphrase(&mut self) {
        self.aezeed_passphrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_aezeed_passphrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.aezeed_passphrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aezeed_passphrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.aezeed_passphrase
    }

    // Take field
    pub fn take_aezeed_passphrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.aezeed_passphrase, ::std::vec::Vec::new())
    }

    // bytes seed_entropy = 2;


    pub fn get_seed_entropy(&self) -> &[u8] {
        &self.seed_entropy
    }
    pub fn clear_seed_entropy(&mut self) {
        self.seed_entropy.clear();
    }

    // Param is passed by value, moved
    pub fn set_seed_entropy(&mut self, v: ::std::vec::Vec<u8>) {
        self.seed_entropy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed_entropy(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.seed_entropy
    }

    // Take field
    pub fn take_seed_entropy(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.seed_entropy, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GenSeedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.aezeed_passphrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.seed_entropy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.aezeed_passphrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.aezeed_passphrase);
        }
        if !self.seed_entropy.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.seed_entropy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.aezeed_passphrase.is_empty() {
            os.write_bytes(1, &self.aezeed_passphrase)?;
        }
        if !self.seed_entropy.is_empty() {
            os.write_bytes(2, &self.seed_entropy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenSeedRequest {
        GenSeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "aezeed_passphrase",
                    |m: &GenSeedRequest| { &m.aezeed_passphrase },
                    |m: &mut GenSeedRequest| { &mut m.aezeed_passphrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "seed_entropy",
                    |m: &GenSeedRequest| { &m.seed_entropy },
                    |m: &mut GenSeedRequest| { &mut m.seed_entropy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenSeedRequest>(
                    "GenSeedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenSeedRequest {
        static mut instance: ::protobuf::lazy::Lazy<GenSeedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenSeedRequest,
        };
        unsafe {
            instance.get(GenSeedRequest::new)
        }
    }
}

impl ::protobuf::Clear for GenSeedRequest {
    fn clear(&mut self) {
        self.aezeed_passphrase.clear();
        self.seed_entropy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenSeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenSeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenSeedResponse {
    // message fields
    pub cipher_seed_mnemonic: ::protobuf::RepeatedField<::std::string::String>,
    pub enciphered_seed: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GenSeedResponse {
    fn default() -> &'a GenSeedResponse {
        <GenSeedResponse as ::protobuf::Message>::default_instance()
    }
}

impl GenSeedResponse {
    pub fn new() -> GenSeedResponse {
        ::std::default::Default::default()
    }

    // repeated string cipher_seed_mnemonic = 1;


    pub fn get_cipher_seed_mnemonic(&self) -> &[::std::string::String] {
        &self.cipher_seed_mnemonic
    }
    pub fn clear_cipher_seed_mnemonic(&mut self) {
        self.cipher_seed_mnemonic.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipher_seed_mnemonic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cipher_seed_mnemonic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipher_seed_mnemonic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cipher_seed_mnemonic
    }

    // Take field
    pub fn take_cipher_seed_mnemonic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cipher_seed_mnemonic, ::protobuf::RepeatedField::new())
    }

    // bytes enciphered_seed = 2;


    pub fn get_enciphered_seed(&self) -> &[u8] {
        &self.enciphered_seed
    }
    pub fn clear_enciphered_seed(&mut self) {
        self.enciphered_seed.clear();
    }

    // Param is passed by value, moved
    pub fn set_enciphered_seed(&mut self, v: ::std::vec::Vec<u8>) {
        self.enciphered_seed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enciphered_seed(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.enciphered_seed
    }

    // Take field
    pub fn take_enciphered_seed(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.enciphered_seed, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GenSeedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cipher_seed_mnemonic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.enciphered_seed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cipher_seed_mnemonic {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.enciphered_seed.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.enciphered_seed);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cipher_seed_mnemonic {
            os.write_string(1, &v)?;
        };
        if !self.enciphered_seed.is_empty() {
            os.write_bytes(2, &self.enciphered_seed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenSeedResponse {
        GenSeedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cipher_seed_mnemonic",
                    |m: &GenSeedResponse| { &m.cipher_seed_mnemonic },
                    |m: &mut GenSeedResponse| { &mut m.cipher_seed_mnemonic },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "enciphered_seed",
                    |m: &GenSeedResponse| { &m.enciphered_seed },
                    |m: &mut GenSeedResponse| { &mut m.enciphered_seed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenSeedResponse>(
                    "GenSeedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenSeedResponse {
        static mut instance: ::protobuf::lazy::Lazy<GenSeedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenSeedResponse,
        };
        unsafe {
            instance.get(GenSeedResponse::new)
        }
    }
}

impl ::protobuf::Clear for GenSeedResponse {
    fn clear(&mut self) {
        self.cipher_seed_mnemonic.clear();
        self.enciphered_seed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenSeedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenSeedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InitWalletRequest {
    // message fields
    pub wallet_password: ::std::vec::Vec<u8>,
    pub cipher_seed_mnemonic: ::protobuf::RepeatedField<::std::string::String>,
    pub aezeed_passphrase: ::std::vec::Vec<u8>,
    pub recovery_window: i32,
    pub channel_backups: ::protobuf::SingularPtrField<ChanBackupSnapshot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InitWalletRequest {
    fn default() -> &'a InitWalletRequest {
        <InitWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl InitWalletRequest {
    pub fn new() -> InitWalletRequest {
        ::std::default::Default::default()
    }

    // bytes wallet_password = 1;


    pub fn get_wallet_password(&self) -> &[u8] {
        &self.wallet_password
    }
    pub fn clear_wallet_password(&mut self) {
        self.wallet_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_wallet_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.wallet_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wallet_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.wallet_password
    }

    // Take field
    pub fn take_wallet_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.wallet_password, ::std::vec::Vec::new())
    }

    // repeated string cipher_seed_mnemonic = 2;


    pub fn get_cipher_seed_mnemonic(&self) -> &[::std::string::String] {
        &self.cipher_seed_mnemonic
    }
    pub fn clear_cipher_seed_mnemonic(&mut self) {
        self.cipher_seed_mnemonic.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipher_seed_mnemonic(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.cipher_seed_mnemonic = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipher_seed_mnemonic(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.cipher_seed_mnemonic
    }

    // Take field
    pub fn take_cipher_seed_mnemonic(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.cipher_seed_mnemonic, ::protobuf::RepeatedField::new())
    }

    // bytes aezeed_passphrase = 3;


    pub fn get_aezeed_passphrase(&self) -> &[u8] {
        &self.aezeed_passphrase
    }
    pub fn clear_aezeed_passphrase(&mut self) {
        self.aezeed_passphrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_aezeed_passphrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.aezeed_passphrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aezeed_passphrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.aezeed_passphrase
    }

    // Take field
    pub fn take_aezeed_passphrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.aezeed_passphrase, ::std::vec::Vec::new())
    }

    // int32 recovery_window = 4;


    pub fn get_recovery_window(&self) -> i32 {
        self.recovery_window
    }
    pub fn clear_recovery_window(&mut self) {
        self.recovery_window = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovery_window(&mut self, v: i32) {
        self.recovery_window = v;
    }

    // .lnrpc.ChanBackupSnapshot channel_backups = 5;


    pub fn get_channel_backups(&self) -> &ChanBackupSnapshot {
        self.channel_backups.as_ref().unwrap_or_else(|| ChanBackupSnapshot::default_instance())
    }
    pub fn clear_channel_backups(&mut self) {
        self.channel_backups.clear();
    }

    pub fn has_channel_backups(&self) -> bool {
        self.channel_backups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_backups(&mut self, v: ChanBackupSnapshot) {
        self.channel_backups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_backups(&mut self) -> &mut ChanBackupSnapshot {
        if self.channel_backups.is_none() {
            self.channel_backups.set_default();
        }
        self.channel_backups.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_backups(&mut self) -> ChanBackupSnapshot {
        self.channel_backups.take().unwrap_or_else(|| ChanBackupSnapshot::new())
    }
}

impl ::protobuf::Message for InitWalletRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.wallet_password)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cipher_seed_mnemonic)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.aezeed_passphrase)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recovery_window = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_backups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.wallet_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_password);
        }
        for value in &self.cipher_seed_mnemonic {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.aezeed_passphrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.aezeed_passphrase);
        }
        if self.recovery_window != 0 {
            my_size += ::protobuf::rt::value_size(4, self.recovery_window, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.wallet_password.is_empty() {
            os.write_bytes(1, &self.wallet_password)?;
        }
        for v in &self.cipher_seed_mnemonic {
            os.write_string(2, &v)?;
        };
        if !self.aezeed_passphrase.is_empty() {
            os.write_bytes(3, &self.aezeed_passphrase)?;
        }
        if self.recovery_window != 0 {
            os.write_int32(4, self.recovery_window)?;
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitWalletRequest {
        InitWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "wallet_password",
                    |m: &InitWalletRequest| { &m.wallet_password },
                    |m: &mut InitWalletRequest| { &mut m.wallet_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cipher_seed_mnemonic",
                    |m: &InitWalletRequest| { &m.cipher_seed_mnemonic },
                    |m: &mut InitWalletRequest| { &mut m.cipher_seed_mnemonic },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "aezeed_passphrase",
                    |m: &InitWalletRequest| { &m.aezeed_passphrase },
                    |m: &mut InitWalletRequest| { &mut m.aezeed_passphrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "recovery_window",
                    |m: &InitWalletRequest| { &m.recovery_window },
                    |m: &mut InitWalletRequest| { &mut m.recovery_window },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChanBackupSnapshot>>(
                    "channel_backups",
                    |m: &InitWalletRequest| { &m.channel_backups },
                    |m: &mut InitWalletRequest| { &mut m.channel_backups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InitWalletRequest>(
                    "InitWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InitWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<InitWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InitWalletRequest,
        };
        unsafe {
            instance.get(InitWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for InitWalletRequest {
    fn clear(&mut self) {
        self.wallet_password.clear();
        self.cipher_seed_mnemonic.clear();
        self.aezeed_passphrase.clear();
        self.recovery_window = 0;
        self.channel_backups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InitWalletResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InitWalletResponse {
    fn default() -> &'a InitWalletResponse {
        <InitWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl InitWalletResponse {
    pub fn new() -> InitWalletResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InitWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitWalletResponse {
        InitWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<InitWalletResponse>(
                    "InitWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InitWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<InitWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InitWalletResponse,
        };
        unsafe {
            instance.get(InitWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for InitWalletResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlockWalletRequest {
    // message fields
    pub wallet_password: ::std::vec::Vec<u8>,
    pub recovery_window: i32,
    pub channel_backups: ::protobuf::SingularPtrField<ChanBackupSnapshot>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnlockWalletRequest {
    fn default() -> &'a UnlockWalletRequest {
        <UnlockWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnlockWalletRequest {
    pub fn new() -> UnlockWalletRequest {
        ::std::default::Default::default()
    }

    // bytes wallet_password = 1;


    pub fn get_wallet_password(&self) -> &[u8] {
        &self.wallet_password
    }
    pub fn clear_wallet_password(&mut self) {
        self.wallet_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_wallet_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.wallet_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wallet_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.wallet_password
    }

    // Take field
    pub fn take_wallet_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.wallet_password, ::std::vec::Vec::new())
    }

    // int32 recovery_window = 2;


    pub fn get_recovery_window(&self) -> i32 {
        self.recovery_window
    }
    pub fn clear_recovery_window(&mut self) {
        self.recovery_window = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovery_window(&mut self, v: i32) {
        self.recovery_window = v;
    }

    // .lnrpc.ChanBackupSnapshot channel_backups = 3;


    pub fn get_channel_backups(&self) -> &ChanBackupSnapshot {
        self.channel_backups.as_ref().unwrap_or_else(|| ChanBackupSnapshot::default_instance())
    }
    pub fn clear_channel_backups(&mut self) {
        self.channel_backups.clear();
    }

    pub fn has_channel_backups(&self) -> bool {
        self.channel_backups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_backups(&mut self, v: ChanBackupSnapshot) {
        self.channel_backups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_backups(&mut self) -> &mut ChanBackupSnapshot {
        if self.channel_backups.is_none() {
            self.channel_backups.set_default();
        }
        self.channel_backups.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_backups(&mut self) -> ChanBackupSnapshot {
        self.channel_backups.take().unwrap_or_else(|| ChanBackupSnapshot::new())
    }
}

impl ::protobuf::Message for UnlockWalletRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.wallet_password)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.recovery_window = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_backups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.wallet_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_password);
        }
        if self.recovery_window != 0 {
            my_size += ::protobuf::rt::value_size(2, self.recovery_window, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.wallet_password.is_empty() {
            os.write_bytes(1, &self.wallet_password)?;
        }
        if self.recovery_window != 0 {
            os.write_int32(2, self.recovery_window)?;
        }
        if let Some(ref v) = self.channel_backups.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlockWalletRequest {
        UnlockWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "wallet_password",
                    |m: &UnlockWalletRequest| { &m.wallet_password },
                    |m: &mut UnlockWalletRequest| { &mut m.wallet_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "recovery_window",
                    |m: &UnlockWalletRequest| { &m.recovery_window },
                    |m: &mut UnlockWalletRequest| { &mut m.recovery_window },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChanBackupSnapshot>>(
                    "channel_backups",
                    |m: &UnlockWalletRequest| { &m.channel_backups },
                    |m: &mut UnlockWalletRequest| { &mut m.channel_backups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnlockWalletRequest>(
                    "UnlockWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnlockWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<UnlockWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnlockWalletRequest,
        };
        unsafe {
            instance.get(UnlockWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for UnlockWalletRequest {
    fn clear(&mut self) {
        self.wallet_password.clear();
        self.recovery_window = 0;
        self.channel_backups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlockWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnlockWalletResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnlockWalletResponse {
    fn default() -> &'a UnlockWalletResponse {
        <UnlockWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnlockWalletResponse {
    pub fn new() -> UnlockWalletResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnlockWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnlockWalletResponse {
        UnlockWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UnlockWalletResponse>(
                    "UnlockWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnlockWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<UnlockWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnlockWalletResponse,
        };
        unsafe {
            instance.get(UnlockWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for UnlockWalletResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnlockWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnlockWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangePasswordRequest {
    // message fields
    pub current_password: ::std::vec::Vec<u8>,
    pub new_password: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangePasswordRequest {
    fn default() -> &'a ChangePasswordRequest {
        <ChangePasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChangePasswordRequest {
    pub fn new() -> ChangePasswordRequest {
        ::std::default::Default::default()
    }

    // bytes current_password = 1;


    pub fn get_current_password(&self) -> &[u8] {
        &self.current_password
    }
    pub fn clear_current_password(&mut self) {
        self.current_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.current_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.current_password
    }

    // Take field
    pub fn take_current_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.current_password, ::std::vec::Vec::new())
    }

    // bytes new_password = 2;


    pub fn get_new_password(&self) -> &[u8] {
        &self.new_password
    }
    pub fn clear_new_password(&mut self) {
        self.new_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.new_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.new_password
    }

    // Take field
    pub fn take_new_password(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.new_password, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChangePasswordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.current_password)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.new_password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.current_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.current_password);
        }
        if !self.new_password.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.new_password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.current_password.is_empty() {
            os.write_bytes(1, &self.current_password)?;
        }
        if !self.new_password.is_empty() {
            os.write_bytes(2, &self.new_password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePasswordRequest {
        ChangePasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "current_password",
                    |m: &ChangePasswordRequest| { &m.current_password },
                    |m: &mut ChangePasswordRequest| { &mut m.current_password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "new_password",
                    |m: &ChangePasswordRequest| { &m.new_password },
                    |m: &mut ChangePasswordRequest| { &mut m.new_password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChangePasswordRequest>(
                    "ChangePasswordRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangePasswordRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChangePasswordRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangePasswordRequest,
        };
        unsafe {
            instance.get(ChangePasswordRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChangePasswordRequest {
    fn clear(&mut self) {
        self.current_password.clear();
        self.new_password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChangePasswordResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChangePasswordResponse {
    fn default() -> &'a ChangePasswordResponse {
        <ChangePasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChangePasswordResponse {
    pub fn new() -> ChangePasswordResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChangePasswordResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChangePasswordResponse {
        ChangePasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ChangePasswordResponse>(
                    "ChangePasswordResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChangePasswordResponse {
        static mut instance: ::protobuf::lazy::Lazy<ChangePasswordResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChangePasswordResponse,
        };
        unsafe {
            instance.get(ChangePasswordResponse::new)
        }
    }
}

impl ::protobuf::Clear for ChangePasswordResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChangePasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChangePasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Utxo {
    // message fields
    pub field_type: AddressType,
    pub address: ::std::string::String,
    pub amount_sat: i64,
    pub pk_script: ::std::string::String,
    pub outpoint: ::protobuf::SingularPtrField<OutPoint>,
    pub confirmations: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Utxo {
    fn default() -> &'a Utxo {
        <Utxo as ::protobuf::Message>::default_instance()
    }
}

impl Utxo {
    pub fn new() -> Utxo {
        ::std::default::Default::default()
    }

    // .lnrpc.AddressType type = 1;


    pub fn get_field_type(&self) -> AddressType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AddressType::WITNESS_PUBKEY_HASH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AddressType) {
        self.field_type = v;
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // int64 amount_sat = 3;


    pub fn get_amount_sat(&self) -> i64 {
        self.amount_sat
    }
    pub fn clear_amount_sat(&mut self) {
        self.amount_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount_sat(&mut self, v: i64) {
        self.amount_sat = v;
    }

    // string pk_script = 4;


    pub fn get_pk_script(&self) -> &str {
        &self.pk_script
    }
    pub fn clear_pk_script(&mut self) {
        self.pk_script.clear();
    }

    // Param is passed by value, moved
    pub fn set_pk_script(&mut self, v: ::std::string::String) {
        self.pk_script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pk_script(&mut self) -> &mut ::std::string::String {
        &mut self.pk_script
    }

    // Take field
    pub fn take_pk_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pk_script, ::std::string::String::new())
    }

    // .lnrpc.OutPoint outpoint = 5;


    pub fn get_outpoint(&self) -> &OutPoint {
        self.outpoint.as_ref().unwrap_or_else(|| OutPoint::default_instance())
    }
    pub fn clear_outpoint(&mut self) {
        self.outpoint.clear();
    }

    pub fn has_outpoint(&self) -> bool {
        self.outpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outpoint(&mut self, v: OutPoint) {
        self.outpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outpoint(&mut self) -> &mut OutPoint {
        if self.outpoint.is_none() {
            self.outpoint.set_default();
        }
        self.outpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_outpoint(&mut self) -> OutPoint {
        self.outpoint.take().unwrap_or_else(|| OutPoint::new())
    }

    // int64 confirmations = 6;


    pub fn get_confirmations(&self) -> i64 {
        self.confirmations
    }
    pub fn clear_confirmations(&mut self) {
        self.confirmations = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmations(&mut self, v: i64) {
        self.confirmations = v;
    }
}

impl ::protobuf::Message for Utxo {
    fn is_initialized(&self) -> bool {
        for v in &self.outpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount_sat = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pk_script)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outpoint)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.confirmations = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != AddressType::WITNESS_PUBKEY_HASH {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        if self.amount_sat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pk_script.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.pk_script);
        }
        if let Some(ref v) = self.outpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.confirmations != 0 {
            my_size += ::protobuf::rt::value_size(6, self.confirmations, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != AddressType::WITNESS_PUBKEY_HASH {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        if self.amount_sat != 0 {
            os.write_int64(3, self.amount_sat)?;
        }
        if !self.pk_script.is_empty() {
            os.write_string(4, &self.pk_script)?;
        }
        if let Some(ref v) = self.outpoint.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.confirmations != 0 {
            os.write_int64(6, self.confirmations)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Utxo {
        Utxo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressType>>(
                    "type",
                    |m: &Utxo| { &m.field_type },
                    |m: &mut Utxo| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &Utxo| { &m.address },
                    |m: &mut Utxo| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount_sat",
                    |m: &Utxo| { &m.amount_sat },
                    |m: &mut Utxo| { &mut m.amount_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pk_script",
                    |m: &Utxo| { &m.pk_script },
                    |m: &mut Utxo| { &mut m.pk_script },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutPoint>>(
                    "outpoint",
                    |m: &Utxo| { &m.outpoint },
                    |m: &mut Utxo| { &mut m.outpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "confirmations",
                    |m: &Utxo| { &m.confirmations },
                    |m: &mut Utxo| { &mut m.confirmations },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Utxo>(
                    "Utxo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Utxo {
        static mut instance: ::protobuf::lazy::Lazy<Utxo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Utxo,
        };
        unsafe {
            instance.get(Utxo::new)
        }
    }
}

impl ::protobuf::Clear for Utxo {
    fn clear(&mut self) {
        self.field_type = AddressType::WITNESS_PUBKEY_HASH;
        self.address.clear();
        self.amount_sat = 0;
        self.pk_script.clear();
        self.outpoint.clear();
        self.confirmations = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Utxo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Utxo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub tx_hash: ::std::string::String,
    pub amount: i64,
    pub num_confirmations: i32,
    pub block_hash: ::std::string::String,
    pub block_height: i32,
    pub time_stamp: i64,
    pub total_fees: i64,
    pub dest_addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub raw_tx_hex: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // string tx_hash = 1;


    pub fn get_tx_hash(&self) -> &str {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::string::String) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tx_hash, ::std::string::String::new())
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // int32 num_confirmations = 3;


    pub fn get_num_confirmations(&self) -> i32 {
        self.num_confirmations
    }
    pub fn clear_num_confirmations(&mut self) {
        self.num_confirmations = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_confirmations(&mut self, v: i32) {
        self.num_confirmations = v;
    }

    // string block_hash = 4;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // int32 block_height = 5;


    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    // int64 time_stamp = 6;


    pub fn get_time_stamp(&self) -> i64 {
        self.time_stamp
    }
    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: i64) {
        self.time_stamp = v;
    }

    // int64 total_fees = 7;


    pub fn get_total_fees(&self) -> i64 {
        self.total_fees
    }
    pub fn clear_total_fees(&mut self) {
        self.total_fees = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees(&mut self, v: i64) {
        self.total_fees = v;
    }

    // repeated string dest_addresses = 8;


    pub fn get_dest_addresses(&self) -> &[::std::string::String] {
        &self.dest_addresses
    }
    pub fn clear_dest_addresses(&mut self) {
        self.dest_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dest_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dest_addresses
    }

    // Take field
    pub fn take_dest_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dest_addresses, ::protobuf::RepeatedField::new())
    }

    // string raw_tx_hex = 9;


    pub fn get_raw_tx_hex(&self) -> &str {
        &self.raw_tx_hex
    }
    pub fn clear_raw_tx_hex(&mut self) {
        self.raw_tx_hex.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_tx_hex(&mut self, v: ::std::string::String) {
        self.raw_tx_hex = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_tx_hex(&mut self) -> &mut ::std::string::String {
        &mut self.raw_tx_hex
    }

    // Take field
    pub fn take_raw_tx_hex(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.raw_tx_hex, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tx_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_confirmations = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_stamp = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dest_addresses)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.raw_tx_hex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tx_hash);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_confirmations != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_confirmations, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block_hash);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_stamp != 0 {
            my_size += ::protobuf::rt::value_size(6, self.time_stamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_fees != 0 {
            my_size += ::protobuf::rt::value_size(7, self.total_fees, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dest_addresses {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if !self.raw_tx_hex.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.raw_tx_hex);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tx_hash.is_empty() {
            os.write_string(1, &self.tx_hash)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if self.num_confirmations != 0 {
            os.write_int32(3, self.num_confirmations)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(4, &self.block_hash)?;
        }
        if self.block_height != 0 {
            os.write_int32(5, self.block_height)?;
        }
        if self.time_stamp != 0 {
            os.write_int64(6, self.time_stamp)?;
        }
        if self.total_fees != 0 {
            os.write_int64(7, self.total_fees)?;
        }
        for v in &self.dest_addresses {
            os.write_string(8, &v)?;
        };
        if !self.raw_tx_hex.is_empty() {
            os.write_string(9, &self.raw_tx_hex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx_hash",
                    |m: &Transaction| { &m.tx_hash },
                    |m: &mut Transaction| { &mut m.tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &Transaction| { &m.amount },
                    |m: &mut Transaction| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_confirmations",
                    |m: &Transaction| { &m.num_confirmations },
                    |m: &mut Transaction| { &mut m.num_confirmations },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block_hash",
                    |m: &Transaction| { &m.block_hash },
                    |m: &mut Transaction| { &mut m.block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "block_height",
                    |m: &Transaction| { &m.block_height },
                    |m: &mut Transaction| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "time_stamp",
                    |m: &Transaction| { &m.time_stamp },
                    |m: &mut Transaction| { &mut m.time_stamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_fees",
                    |m: &Transaction| { &m.total_fees },
                    |m: &mut Transaction| { &mut m.total_fees },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dest_addresses",
                    |m: &Transaction| { &m.dest_addresses },
                    |m: &mut Transaction| { &mut m.dest_addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "raw_tx_hex",
                    |m: &Transaction| { &m.raw_tx_hex },
                    |m: &mut Transaction| { &mut m.raw_tx_hex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction,
        };
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.tx_hash.clear();
        self.amount = 0;
        self.num_confirmations = 0;
        self.block_hash.clear();
        self.block_height = 0;
        self.time_stamp = 0;
        self.total_fees = 0;
        self.dest_addresses.clear();
        self.raw_tx_hex.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTransactionsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTransactionsRequest {
    fn default() -> &'a GetTransactionsRequest {
        <GetTransactionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTransactionsRequest {
    pub fn new() -> GetTransactionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTransactionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTransactionsRequest {
        GetTransactionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetTransactionsRequest>(
                    "GetTransactionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetTransactionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetTransactionsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetTransactionsRequest,
        };
        unsafe {
            instance.get(GetTransactionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetTransactionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTransactionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTransactionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionDetails {
    // message fields
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionDetails {
    fn default() -> &'a TransactionDetails {
        <TransactionDetails as ::protobuf::Message>::default_instance()
    }
}

impl TransactionDetails {
    pub fn new() -> TransactionDetails {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Transaction transactions = 1;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionDetails {
        TransactionDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "transactions",
                    |m: &TransactionDetails| { &m.transactions },
                    |m: &mut TransactionDetails| { &mut m.transactions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionDetails>(
                    "TransactionDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionDetails {
        static mut instance: ::protobuf::lazy::Lazy<TransactionDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionDetails,
        };
        unsafe {
            instance.get(TransactionDetails::new)
        }
    }
}

impl ::protobuf::Clear for TransactionDetails {
    fn clear(&mut self) {
        self.transactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeLimit {
    // message oneof groups
    pub limit: ::std::option::Option<FeeLimit_oneof_limit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeLimit {
    fn default() -> &'a FeeLimit {
        <FeeLimit as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum FeeLimit_oneof_limit {
    fixed(i64),
    percent(i64),
}

impl FeeLimit {
    pub fn new() -> FeeLimit {
        ::std::default::Default::default()
    }

    // int64 fixed = 1;


    pub fn get_fixed(&self) -> i64 {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_fixed(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_fixed(&self) -> bool {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fixed(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(v))
    }

    // int64 percent = 2;


    pub fn get_percent(&self) -> i64 {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::percent(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_percent(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_percent(&self) -> bool {
        match self.limit {
            ::std::option::Option::Some(FeeLimit_oneof_limit::percent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_percent(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::percent(v))
    }
}

impl ::protobuf::Message for FeeLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::fixed(is.read_int64()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.limit = ::std::option::Option::Some(FeeLimit_oneof_limit::percent(is.read_int64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.limit {
            match v {
                &FeeLimit_oneof_limit::fixed(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &FeeLimit_oneof_limit::percent(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.limit {
            match v {
                &FeeLimit_oneof_limit::fixed(v) => {
                    os.write_int64(1, v)?;
                },
                &FeeLimit_oneof_limit::percent(v) => {
                    os.write_int64(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeLimit {
        FeeLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "fixed",
                    FeeLimit::has_fixed,
                    FeeLimit::get_fixed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                    "percent",
                    FeeLimit::has_percent,
                    FeeLimit::get_percent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeeLimit>(
                    "FeeLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeLimit {
        static mut instance: ::protobuf::lazy::Lazy<FeeLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeLimit,
        };
        unsafe {
            instance.get(FeeLimit::new)
        }
    }
}

impl ::protobuf::Clear for FeeLimit {
    fn clear(&mut self) {
        self.limit = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendRequest {
    // message fields
    pub dest: ::std::vec::Vec<u8>,
    pub dest_string: ::std::string::String,
    pub amt: i64,
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_hash_string: ::std::string::String,
    pub payment_request: ::std::string::String,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<FeeLimit>,
    pub outgoing_chan_id: u64,
    pub cltv_limit: u32,
    pub dest_tlv: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendRequest {
    fn default() -> &'a SendRequest {
        <SendRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendRequest {
    pub fn new() -> SendRequest {
        ::std::default::Default::default()
    }

    // bytes dest = 1;


    pub fn get_dest(&self) -> &[u8] {
        &self.dest
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.dest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.dest
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.dest, ::std::vec::Vec::new())
    }

    // string dest_string = 2;


    pub fn get_dest_string(&self) -> &str {
        &self.dest_string
    }
    pub fn clear_dest_string(&mut self) {
        self.dest_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_string(&mut self, v: ::std::string::String) {
        self.dest_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_string(&mut self) -> &mut ::std::string::String {
        &mut self.dest_string
    }

    // Take field
    pub fn take_dest_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dest_string, ::std::string::String::new())
    }

    // int64 amt = 3;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // bytes payment_hash = 4;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // string payment_hash_string = 5;


    pub fn get_payment_hash_string(&self) -> &str {
        &self.payment_hash_string
    }
    pub fn clear_payment_hash_string(&mut self) {
        self.payment_hash_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash_string(&mut self, v: ::std::string::String) {
        self.payment_hash_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash_string(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash_string
    }

    // Take field
    pub fn take_payment_hash_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash_string, ::std::string::String::new())
    }

    // string payment_request = 6;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // int32 final_cltv_delta = 7;


    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }
    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    // .lnrpc.FeeLimit fee_limit = 8;


    pub fn get_fee_limit(&self) -> &FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| FeeLimit::default_instance())
    }
    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| FeeLimit::new())
    }

    // uint64 outgoing_chan_id = 9;


    pub fn get_outgoing_chan_id(&self) -> u64 {
        self.outgoing_chan_id
    }
    pub fn clear_outgoing_chan_id(&mut self) {
        self.outgoing_chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_outgoing_chan_id(&mut self, v: u64) {
        self.outgoing_chan_id = v;
    }

    // uint32 cltv_limit = 10;


    pub fn get_cltv_limit(&self) -> u32 {
        self.cltv_limit
    }
    pub fn clear_cltv_limit(&mut self) {
        self.cltv_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_limit(&mut self, v: u32) {
        self.cltv_limit = v;
    }

    // repeated .lnrpc.SendRequest.DestTlvEntry dest_tlv = 11;


    pub fn get_dest_tlv(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.dest_tlv
    }
    pub fn clear_dest_tlv(&mut self) {
        self.dest_tlv.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_tlv(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.dest_tlv = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_tlv(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.dest_tlv
    }

    // Take field
    pub fn take_dest_tlv(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.dest_tlv, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SendRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dest_string)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash_string)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.outgoing_chan_id = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_limit = tmp;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.dest_tlv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.dest);
        }
        if !self.dest_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dest_string);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payment_hash);
        }
        if !self.payment_hash_string.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.payment_hash_string);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_request);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(7, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.outgoing_chan_id != 0 {
            my_size += ::protobuf::rt::value_size(9, self.outgoing_chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cltv_limit != 0 {
            my_size += ::protobuf::rt::value_size(10, self.cltv_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_tlv);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dest.is_empty() {
            os.write_bytes(1, &self.dest)?;
        }
        if !self.dest_string.is_empty() {
            os.write_string(2, &self.dest_string)?;
        }
        if self.amt != 0 {
            os.write_int64(3, self.amt)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(4, &self.payment_hash)?;
        }
        if !self.payment_hash_string.is_empty() {
            os.write_string(5, &self.payment_hash_string)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(6, &self.payment_request)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(7, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.outgoing_chan_id != 0 {
            os.write_uint64(9, self.outgoing_chan_id)?;
        }
        if self.cltv_limit != 0 {
            os.write_uint32(10, self.cltv_limit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_tlv, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendRequest {
        SendRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dest",
                    |m: &SendRequest| { &m.dest },
                    |m: &mut SendRequest| { &mut m.dest },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dest_string",
                    |m: &SendRequest| { &m.dest_string },
                    |m: &mut SendRequest| { &mut m.dest_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt",
                    |m: &SendRequest| { &m.amt },
                    |m: &mut SendRequest| { &mut m.amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_hash",
                    |m: &SendRequest| { &m.payment_hash },
                    |m: &mut SendRequest| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash_string",
                    |m: &SendRequest| { &m.payment_hash_string },
                    |m: &mut SendRequest| { &mut m.payment_hash_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &SendRequest| { &m.payment_request },
                    |m: &mut SendRequest| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_cltv_delta",
                    |m: &SendRequest| { &m.final_cltv_delta },
                    |m: &mut SendRequest| { &mut m.final_cltv_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeLimit>>(
                    "fee_limit",
                    |m: &SendRequest| { &m.fee_limit },
                    |m: &mut SendRequest| { &mut m.fee_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "outgoing_chan_id",
                    |m: &SendRequest| { &m.outgoing_chan_id },
                    |m: &mut SendRequest| { &mut m.outgoing_chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cltv_limit",
                    |m: &SendRequest| { &m.cltv_limit },
                    |m: &mut SendRequest| { &mut m.cltv_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                    "dest_tlv",
                    |m: &SendRequest| { &m.dest_tlv },
                    |m: &mut SendRequest| { &mut m.dest_tlv },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendRequest>(
                    "SendRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendRequest,
        };
        unsafe {
            instance.get(SendRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendRequest {
    fn clear(&mut self) {
        self.dest.clear();
        self.dest_string.clear();
        self.amt = 0;
        self.payment_hash.clear();
        self.payment_hash_string.clear();
        self.payment_request.clear();
        self.final_cltv_delta = 0;
        self.fee_limit.clear();
        self.outgoing_chan_id = 0;
        self.cltv_limit = 0;
        self.dest_tlv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendResponse {
    // message fields
    pub payment_error: ::std::string::String,
    pub payment_preimage: ::std::vec::Vec<u8>,
    pub payment_route: ::protobuf::SingularPtrField<Route>,
    pub payment_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendResponse {
    fn default() -> &'a SendResponse {
        <SendResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendResponse {
    pub fn new() -> SendResponse {
        ::std::default::Default::default()
    }

    // string payment_error = 1;


    pub fn get_payment_error(&self) -> &str {
        &self.payment_error
    }
    pub fn clear_payment_error(&mut self) {
        self.payment_error.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_error(&mut self, v: ::std::string::String) {
        self.payment_error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_error(&mut self) -> &mut ::std::string::String {
        &mut self.payment_error
    }

    // Take field
    pub fn take_payment_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_error, ::std::string::String::new())
    }

    // bytes payment_preimage = 2;


    pub fn get_payment_preimage(&self) -> &[u8] {
        &self.payment_preimage
    }
    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_preimage, ::std::vec::Vec::new())
    }

    // .lnrpc.Route payment_route = 3;


    pub fn get_payment_route(&self) -> &Route {
        self.payment_route.as_ref().unwrap_or_else(|| Route::default_instance())
    }
    pub fn clear_payment_route(&mut self) {
        self.payment_route.clear();
    }

    pub fn has_payment_route(&self) -> bool {
        self.payment_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_route(&mut self, v: Route) {
        self.payment_route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_route(&mut self) -> &mut Route {
        if self.payment_route.is_none() {
            self.payment_route.set_default();
        }
        self.payment_route.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_route(&mut self) -> Route {
        self.payment_route.take().unwrap_or_else(|| Route::new())
    }

    // bytes payment_hash = 4;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SendResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payment_route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_preimage)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payment_route)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_error);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payment_preimage);
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.payment_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_error.is_empty() {
            os.write_string(1, &self.payment_error)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_bytes(2, &self.payment_preimage)?;
        }
        if let Some(ref v) = self.payment_route.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_bytes(4, &self.payment_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendResponse {
        SendResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_error",
                    |m: &SendResponse| { &m.payment_error },
                    |m: &mut SendResponse| { &mut m.payment_error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_preimage",
                    |m: &SendResponse| { &m.payment_preimage },
                    |m: &mut SendResponse| { &mut m.payment_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                    "payment_route",
                    |m: &SendResponse| { &m.payment_route },
                    |m: &mut SendResponse| { &mut m.payment_route },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_hash",
                    |m: &SendResponse| { &m.payment_hash },
                    |m: &mut SendResponse| { &mut m.payment_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendResponse>(
                    "SendResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendResponse,
        };
        unsafe {
            instance.get(SendResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendResponse {
    fn clear(&mut self) {
        self.payment_error.clear();
        self.payment_preimage.clear();
        self.payment_route.clear();
        self.payment_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendToRouteRequest {
    // message fields
    pub payment_hash: ::std::vec::Vec<u8>,
    pub payment_hash_string: ::std::string::String,
    pub route: ::protobuf::SingularPtrField<Route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToRouteRequest {
    fn default() -> &'a SendToRouteRequest {
        <SendToRouteRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendToRouteRequest {
    pub fn new() -> SendToRouteRequest {
        ::std::default::Default::default()
    }

    // bytes payment_hash = 1;


    pub fn get_payment_hash(&self) -> &[u8] {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payment_hash, ::std::vec::Vec::new())
    }

    // string payment_hash_string = 2;


    pub fn get_payment_hash_string(&self) -> &str {
        &self.payment_hash_string
    }
    pub fn clear_payment_hash_string(&mut self) {
        self.payment_hash_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash_string(&mut self, v: ::std::string::String) {
        self.payment_hash_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash_string(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash_string
    }

    // Take field
    pub fn take_payment_hash_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash_string, ::std::string::String::new())
    }

    // .lnrpc.Route route = 4;


    pub fn get_route(&self) -> &Route {
        self.route.as_ref().unwrap_or_else(|| Route::default_instance())
    }
    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    pub fn has_route(&self) -> bool {
        self.route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: Route) {
        self.route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route(&mut self) -> &mut Route {
        if self.route.is_none() {
            self.route.set_default();
        }
        self.route.as_mut().unwrap()
    }

    // Take field
    pub fn take_route(&mut self) -> Route {
        self.route.take().unwrap_or_else(|| Route::new())
    }
}

impl ::protobuf::Message for SendToRouteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash_string)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.payment_hash);
        }
        if !self.payment_hash_string.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_hash_string);
        }
        if let Some(ref v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_bytes(1, &self.payment_hash)?;
        }
        if !self.payment_hash_string.is_empty() {
            os.write_string(2, &self.payment_hash_string)?;
        }
        if let Some(ref v) = self.route.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToRouteRequest {
        SendToRouteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_hash",
                    |m: &SendToRouteRequest| { &m.payment_hash },
                    |m: &mut SendToRouteRequest| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash_string",
                    |m: &SendToRouteRequest| { &m.payment_hash_string },
                    |m: &mut SendToRouteRequest| { &mut m.payment_hash_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                    "route",
                    |m: &SendToRouteRequest| { &m.route },
                    |m: &mut SendToRouteRequest| { &mut m.route },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendToRouteRequest>(
                    "SendToRouteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendToRouteRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendToRouteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendToRouteRequest,
        };
        unsafe {
            instance.get(SendToRouteRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendToRouteRequest {
    fn clear(&mut self) {
        self.payment_hash.clear();
        self.payment_hash_string.clear();
        self.route.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToRouteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToRouteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelPoint {
    // message fields
    pub output_index: u32,
    // message oneof groups
    pub funding_txid: ::std::option::Option<ChannelPoint_oneof_funding_txid>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelPoint {
    fn default() -> &'a ChannelPoint {
        <ChannelPoint as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChannelPoint_oneof_funding_txid {
    funding_txid_bytes(::std::vec::Vec<u8>),
    funding_txid_str(::std::string::String),
}

impl ChannelPoint {
    pub fn new() -> ChannelPoint {
        ::std::default::Default::default()
    }

    // bytes funding_txid_bytes = 1;


    pub fn get_funding_txid_bytes(&self) -> &[u8] {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_funding_txid_bytes(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_bytes(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(::std::vec::Vec::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_bytes(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_funding_txid_bytes() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // string funding_txid_str = 2;


    pub fn get_funding_txid_str(&self) -> &str {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_funding_txid_str(&mut self) {
        self.funding_txid = ::std::option::Option::None;
    }

    pub fn has_funding_txid_str(&self) -> bool {
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_funding_txid_str(&mut self, v: ::std::string::String) {
        self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_funding_txid_str(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(_)) = self.funding_txid {
        } else {
            self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(::std::string::String::new()));
        }
        match self.funding_txid {
            ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_funding_txid_str(&mut self) -> ::std::string::String {
        if self.has_funding_txid_str() {
            match self.funding_txid.take() {
                ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 output_index = 3;


    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }
}

impl ::protobuf::Message for ChannelPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_bytes(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.funding_txid = ::std::option::Option::Some(ChannelPoint_oneof_funding_txid::funding_txid_str(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.output_index != 0 {
            os.write_uint32(3, self.output_index)?;
        }
        if let ::std::option::Option::Some(ref v) = self.funding_txid {
            match v {
                &ChannelPoint_oneof_funding_txid::funding_txid_bytes(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &ChannelPoint_oneof_funding_txid::funding_txid_str(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelPoint {
        ChannelPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "funding_txid_bytes",
                    ChannelPoint::has_funding_txid_bytes,
                    ChannelPoint::get_funding_txid_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "funding_txid_str",
                    ChannelPoint::has_funding_txid_str,
                    ChannelPoint::get_funding_txid_str,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &ChannelPoint| { &m.output_index },
                    |m: &mut ChannelPoint| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelPoint>(
                    "ChannelPoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelPoint {
        static mut instance: ::protobuf::lazy::Lazy<ChannelPoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelPoint,
        };
        unsafe {
            instance.get(ChannelPoint::new)
        }
    }
}

impl ::protobuf::Clear for ChannelPoint {
    fn clear(&mut self) {
        self.funding_txid = ::std::option::Option::None;
        self.funding_txid = ::std::option::Option::None;
        self.output_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutPoint {
    // message fields
    pub txid_bytes: ::std::vec::Vec<u8>,
    pub txid_str: ::std::string::String,
    pub output_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutPoint {
    fn default() -> &'a OutPoint {
        <OutPoint as ::protobuf::Message>::default_instance()
    }
}

impl OutPoint {
    pub fn new() -> OutPoint {
        ::std::default::Default::default()
    }

    // bytes txid_bytes = 1;


    pub fn get_txid_bytes(&self) -> &[u8] {
        &self.txid_bytes
    }
    pub fn clear_txid_bytes(&mut self) {
        self.txid_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid_bytes
    }

    // Take field
    pub fn take_txid_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid_bytes, ::std::vec::Vec::new())
    }

    // string txid_str = 2;


    pub fn get_txid_str(&self) -> &str {
        &self.txid_str
    }
    pub fn clear_txid_str(&mut self) {
        self.txid_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid_str(&mut self, v: ::std::string::String) {
        self.txid_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid_str(&mut self) -> &mut ::std::string::String {
        &mut self.txid_str
    }

    // Take field
    pub fn take_txid_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid_str, ::std::string::String::new())
    }

    // uint32 output_index = 3;


    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }
}

impl ::protobuf::Message for OutPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid_bytes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid_str)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid_bytes);
        }
        if !self.txid_str.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.txid_str);
        }
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid_bytes.is_empty() {
            os.write_bytes(1, &self.txid_bytes)?;
        }
        if !self.txid_str.is_empty() {
            os.write_string(2, &self.txid_str)?;
        }
        if self.output_index != 0 {
            os.write_uint32(3, self.output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutPoint {
        OutPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid_bytes",
                    |m: &OutPoint| { &m.txid_bytes },
                    |m: &mut OutPoint| { &mut m.txid_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid_str",
                    |m: &OutPoint| { &m.txid_str },
                    |m: &mut OutPoint| { &mut m.txid_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &OutPoint| { &m.output_index },
                    |m: &mut OutPoint| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OutPoint>(
                    "OutPoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OutPoint {
        static mut instance: ::protobuf::lazy::Lazy<OutPoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OutPoint,
        };
        unsafe {
            instance.get(OutPoint::new)
        }
    }
}

impl ::protobuf::Clear for OutPoint {
    fn clear(&mut self) {
        self.txid_bytes.clear();
        self.txid_str.clear();
        self.output_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightningAddress {
    // message fields
    pub pubkey: ::std::string::String,
    pub host: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightningAddress {
    fn default() -> &'a LightningAddress {
        <LightningAddress as ::protobuf::Message>::default_instance()
    }
}

impl LightningAddress {
    pub fn new() -> LightningAddress {
        ::std::default::Default::default()
    }

    // string pubkey = 1;


    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }

    // string host = 2;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightningAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pubkey);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pubkey.is_empty() {
            os.write_string(1, &self.pubkey)?;
        }
        if !self.host.is_empty() {
            os.write_string(2, &self.host)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningAddress {
        LightningAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pubkey",
                    |m: &LightningAddress| { &m.pubkey },
                    |m: &mut LightningAddress| { &mut m.pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    |m: &LightningAddress| { &m.host },
                    |m: &mut LightningAddress| { &mut m.host },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LightningAddress>(
                    "LightningAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LightningAddress {
        static mut instance: ::protobuf::lazy::Lazy<LightningAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LightningAddress,
        };
        unsafe {
            instance.get(LightningAddress::new)
        }
    }
}

impl ::protobuf::Clear for LightningAddress {
    fn clear(&mut self) {
        self.pubkey.clear();
        self.host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EstimateFeeRequest {
    // message fields
    pub AddrToAmount: ::std::collections::HashMap<::std::string::String, i64>,
    pub target_conf: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EstimateFeeRequest {
    fn default() -> &'a EstimateFeeRequest {
        <EstimateFeeRequest as ::protobuf::Message>::default_instance()
    }
}

impl EstimateFeeRequest {
    pub fn new() -> EstimateFeeRequest {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.EstimateFeeRequest.AddrToAmountEntry AddrToAmount = 1;


    pub fn get_AddrToAmount(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.AddrToAmount
    }
    pub fn clear_AddrToAmount(&mut self) {
        self.AddrToAmount.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddrToAmount(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.AddrToAmount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddrToAmount(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.AddrToAmount
    }

    // Take field
    pub fn take_AddrToAmount(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.AddrToAmount, ::std::collections::HashMap::new())
    }

    // int32 target_conf = 2;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }
}

impl ::protobuf::Message for EstimateFeeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.AddrToAmount)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount);
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(2, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount, os)?;
        if self.target_conf != 0 {
            os.write_int32(2, self.target_conf)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EstimateFeeRequest {
        EstimateFeeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "AddrToAmount",
                    |m: &EstimateFeeRequest| { &m.AddrToAmount },
                    |m: &mut EstimateFeeRequest| { &mut m.AddrToAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &EstimateFeeRequest| { &m.target_conf },
                    |m: &mut EstimateFeeRequest| { &mut m.target_conf },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EstimateFeeRequest>(
                    "EstimateFeeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EstimateFeeRequest {
        static mut instance: ::protobuf::lazy::Lazy<EstimateFeeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EstimateFeeRequest,
        };
        unsafe {
            instance.get(EstimateFeeRequest::new)
        }
    }
}

impl ::protobuf::Clear for EstimateFeeRequest {
    fn clear(&mut self) {
        self.AddrToAmount.clear();
        self.target_conf = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EstimateFeeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EstimateFeeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EstimateFeeResponse {
    // message fields
    pub fee_sat: i64,
    pub feerate_sat_per_byte: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EstimateFeeResponse {
    fn default() -> &'a EstimateFeeResponse {
        <EstimateFeeResponse as ::protobuf::Message>::default_instance()
    }
}

impl EstimateFeeResponse {
    pub fn new() -> EstimateFeeResponse {
        ::std::default::Default::default()
    }

    // int64 fee_sat = 1;


    pub fn get_fee_sat(&self) -> i64 {
        self.fee_sat
    }
    pub fn clear_fee_sat(&mut self) {
        self.fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_sat(&mut self, v: i64) {
        self.fee_sat = v;
    }

    // int64 feerate_sat_per_byte = 2;


    pub fn get_feerate_sat_per_byte(&self) -> i64 {
        self.feerate_sat_per_byte
    }
    pub fn clear_feerate_sat_per_byte(&mut self) {
        self.feerate_sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_feerate_sat_per_byte(&mut self, v: i64) {
        self.feerate_sat_per_byte = v;
    }
}

impl ::protobuf::Message for EstimateFeeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_sat = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.feerate_sat_per_byte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.feerate_sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(2, self.feerate_sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fee_sat != 0 {
            os.write_int64(1, self.fee_sat)?;
        }
        if self.feerate_sat_per_byte != 0 {
            os.write_int64(2, self.feerate_sat_per_byte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EstimateFeeResponse {
        EstimateFeeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_sat",
                    |m: &EstimateFeeResponse| { &m.fee_sat },
                    |m: &mut EstimateFeeResponse| { &mut m.fee_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "feerate_sat_per_byte",
                    |m: &EstimateFeeResponse| { &m.feerate_sat_per_byte },
                    |m: &mut EstimateFeeResponse| { &mut m.feerate_sat_per_byte },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EstimateFeeResponse>(
                    "EstimateFeeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EstimateFeeResponse {
        static mut instance: ::protobuf::lazy::Lazy<EstimateFeeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EstimateFeeResponse,
        };
        unsafe {
            instance.get(EstimateFeeResponse::new)
        }
    }
}

impl ::protobuf::Clear for EstimateFeeResponse {
    fn clear(&mut self) {
        self.fee_sat = 0;
        self.feerate_sat_per_byte = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EstimateFeeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EstimateFeeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendManyRequest {
    // message fields
    pub AddrToAmount: ::std::collections::HashMap<::std::string::String, i64>,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendManyRequest {
    fn default() -> &'a SendManyRequest {
        <SendManyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendManyRequest {
    pub fn new() -> SendManyRequest {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.SendManyRequest.AddrToAmountEntry AddrToAmount = 1;


    pub fn get_AddrToAmount(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.AddrToAmount
    }
    pub fn clear_AddrToAmount(&mut self) {
        self.AddrToAmount.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddrToAmount(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.AddrToAmount = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddrToAmount(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.AddrToAmount
    }

    // Take field
    pub fn take_AddrToAmount(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.AddrToAmount, ::std::collections::HashMap::new())
    }

    // int32 target_conf = 3;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // int64 sat_per_byte = 5;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }
}

impl ::protobuf::Message for SendManyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.AddrToAmount)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount);
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(5, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(1, &self.AddrToAmount, os)?;
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(5, self.sat_per_byte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyRequest {
        SendManyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                    "AddrToAmount",
                    |m: &SendManyRequest| { &m.AddrToAmount },
                    |m: &mut SendManyRequest| { &mut m.AddrToAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &SendManyRequest| { &m.target_conf },
                    |m: &mut SendManyRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &SendManyRequest| { &m.sat_per_byte },
                    |m: &mut SendManyRequest| { &mut m.sat_per_byte },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendManyRequest>(
                    "SendManyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendManyRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendManyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendManyRequest,
        };
        unsafe {
            instance.get(SendManyRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendManyRequest {
    fn clear(&mut self) {
        self.AddrToAmount.clear();
        self.target_conf = 0;
        self.sat_per_byte = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendManyResponse {
    // message fields
    pub txid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendManyResponse {
    fn default() -> &'a SendManyResponse {
        <SendManyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendManyResponse {
    pub fn new() -> SendManyResponse {
        ::std::default::Default::default()
    }

    // string txid = 1;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendManyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_string(1, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyResponse {
        SendManyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &SendManyResponse| { &m.txid },
                    |m: &mut SendManyResponse| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendManyResponse>(
                    "SendManyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendManyResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendManyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendManyResponse,
        };
        unsafe {
            instance.get(SendManyResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendManyResponse {
    fn clear(&mut self) {
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendCoinsRequest {
    // message fields
    pub addr: ::std::string::String,
    pub amount: i64,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    pub send_all: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendCoinsRequest {
    fn default() -> &'a SendCoinsRequest {
        <SendCoinsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendCoinsRequest {
    pub fn new() -> SendCoinsRequest {
        ::std::default::Default::default()
    }

    // string addr = 1;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // int32 target_conf = 3;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // int64 sat_per_byte = 5;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    // bool send_all = 6;


    pub fn get_send_all(&self) -> bool {
        self.send_all
    }
    pub fn clear_send_all(&mut self) {
        self.send_all = false;
    }

    // Param is passed by value, moved
    pub fn set_send_all(&mut self, v: bool) {
        self.send_all = v;
    }
}

impl ::protobuf::Message for SendCoinsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_all = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.addr);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(5, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.send_all != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.addr.is_empty() {
            os.write_string(1, &self.addr)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(5, self.sat_per_byte)?;
        }
        if self.send_all != false {
            os.write_bool(6, self.send_all)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCoinsRequest {
        SendCoinsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addr",
                    |m: &SendCoinsRequest| { &m.addr },
                    |m: &mut SendCoinsRequest| { &mut m.addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &SendCoinsRequest| { &m.amount },
                    |m: &mut SendCoinsRequest| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &SendCoinsRequest| { &m.target_conf },
                    |m: &mut SendCoinsRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &SendCoinsRequest| { &m.sat_per_byte },
                    |m: &mut SendCoinsRequest| { &mut m.sat_per_byte },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "send_all",
                    |m: &SendCoinsRequest| { &m.send_all },
                    |m: &mut SendCoinsRequest| { &mut m.send_all },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendCoinsRequest>(
                    "SendCoinsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendCoinsRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendCoinsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendCoinsRequest,
        };
        unsafe {
            instance.get(SendCoinsRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendCoinsRequest {
    fn clear(&mut self) {
        self.addr.clear();
        self.amount = 0;
        self.target_conf = 0;
        self.sat_per_byte = 0;
        self.send_all = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCoinsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCoinsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendCoinsResponse {
    // message fields
    pub txid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendCoinsResponse {
    fn default() -> &'a SendCoinsResponse {
        <SendCoinsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendCoinsResponse {
    pub fn new() -> SendCoinsResponse {
        ::std::default::Default::default()
    }

    // string txid = 1;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendCoinsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_string(1, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendCoinsResponse {
        SendCoinsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &SendCoinsResponse| { &m.txid },
                    |m: &mut SendCoinsResponse| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendCoinsResponse>(
                    "SendCoinsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendCoinsResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendCoinsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendCoinsResponse,
        };
        unsafe {
            instance.get(SendCoinsResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendCoinsResponse {
    fn clear(&mut self) {
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendCoinsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendCoinsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUnspentRequest {
    // message fields
    pub min_confs: i32,
    pub max_confs: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUnspentRequest {
    fn default() -> &'a ListUnspentRequest {
        <ListUnspentRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUnspentRequest {
    pub fn new() -> ListUnspentRequest {
        ::std::default::Default::default()
    }

    // int32 min_confs = 1;


    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }
    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    // int32 max_confs = 2;


    pub fn get_max_confs(&self) -> i32 {
        self.max_confs
    }
    pub fn clear_max_confs(&mut self) {
        self.max_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_confs(&mut self, v: i32) {
        self.max_confs = v;
    }
}

impl ::protobuf::Message for ListUnspentRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_confs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(1, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_confs != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min_confs != 0 {
            os.write_int32(1, self.min_confs)?;
        }
        if self.max_confs != 0 {
            os.write_int32(2, self.max_confs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUnspentRequest {
        ListUnspentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "min_confs",
                    |m: &ListUnspentRequest| { &m.min_confs },
                    |m: &mut ListUnspentRequest| { &mut m.min_confs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_confs",
                    |m: &ListUnspentRequest| { &m.max_confs },
                    |m: &mut ListUnspentRequest| { &mut m.max_confs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListUnspentRequest>(
                    "ListUnspentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListUnspentRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListUnspentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListUnspentRequest,
        };
        unsafe {
            instance.get(ListUnspentRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListUnspentRequest {
    fn clear(&mut self) {
        self.min_confs = 0;
        self.max_confs = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUnspentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUnspentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUnspentResponse {
    // message fields
    pub utxos: ::protobuf::RepeatedField<Utxo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUnspentResponse {
    fn default() -> &'a ListUnspentResponse {
        <ListUnspentResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListUnspentResponse {
    pub fn new() -> ListUnspentResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Utxo utxos = 1;


    pub fn get_utxos(&self) -> &[Utxo] {
        &self.utxos
    }
    pub fn clear_utxos(&mut self) {
        self.utxos.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxos(&mut self, v: ::protobuf::RepeatedField<Utxo>) {
        self.utxos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_utxos(&mut self) -> &mut ::protobuf::RepeatedField<Utxo> {
        &mut self.utxos
    }

    // Take field
    pub fn take_utxos(&mut self) -> ::protobuf::RepeatedField<Utxo> {
        ::std::mem::replace(&mut self.utxos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListUnspentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.utxos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.utxos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.utxos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.utxos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUnspentResponse {
        ListUnspentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Utxo>>(
                    "utxos",
                    |m: &ListUnspentResponse| { &m.utxos },
                    |m: &mut ListUnspentResponse| { &mut m.utxos },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListUnspentResponse>(
                    "ListUnspentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListUnspentResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListUnspentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListUnspentResponse,
        };
        unsafe {
            instance.get(ListUnspentResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListUnspentResponse {
    fn clear(&mut self) {
        self.utxos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUnspentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUnspentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewAddressRequest {
    // message fields
    pub field_type: AddressType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewAddressRequest {
    fn default() -> &'a NewAddressRequest {
        <NewAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl NewAddressRequest {
    pub fn new() -> NewAddressRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.AddressType type = 1;


    pub fn get_field_type(&self) -> AddressType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AddressType::WITNESS_PUBKEY_HASH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AddressType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for NewAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != AddressType::WITNESS_PUBKEY_HASH {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != AddressType::WITNESS_PUBKEY_HASH {
            os.write_enum(1, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewAddressRequest {
        NewAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressType>>(
                    "type",
                    |m: &NewAddressRequest| { &m.field_type },
                    |m: &mut NewAddressRequest| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NewAddressRequest>(
                    "NewAddressRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NewAddressRequest {
        static mut instance: ::protobuf::lazy::Lazy<NewAddressRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NewAddressRequest,
        };
        unsafe {
            instance.get(NewAddressRequest::new)
        }
    }
}

impl ::protobuf::Clear for NewAddressRequest {
    fn clear(&mut self) {
        self.field_type = AddressType::WITNESS_PUBKEY_HASH;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NewAddressResponse {
    // message fields
    pub address: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NewAddressResponse {
    fn default() -> &'a NewAddressResponse {
        <NewAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl NewAddressResponse {
    pub fn new() -> NewAddressResponse {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NewAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NewAddressResponse {
        NewAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &NewAddressResponse| { &m.address },
                    |m: &mut NewAddressResponse| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NewAddressResponse>(
                    "NewAddressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NewAddressResponse {
        static mut instance: ::protobuf::lazy::Lazy<NewAddressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NewAddressResponse,
        };
        unsafe {
            instance.get(NewAddressResponse::new)
        }
    }
}

impl ::protobuf::Clear for NewAddressResponse {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NewAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NewAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageRequest {
    // message fields
    pub msg: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageRequest {
    fn default() -> &'a SignMessageRequest {
        <SignMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageRequest {
    pub fn new() -> SignMessageRequest {
        ::std::default::Default::default()
    }

    // bytes msg = 1;


    pub fn get_msg(&self) -> &[u8] {
        &self.msg
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.msg
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.msg, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.msg.is_empty() {
            os.write_bytes(1, &self.msg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageRequest {
        SignMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "msg",
                    |m: &SignMessageRequest| { &m.msg },
                    |m: &mut SignMessageRequest| { &mut m.msg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageRequest>(
                    "SignMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageRequest,
        };
        unsafe {
            instance.get(SignMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageRequest {
    fn clear(&mut self) {
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageResponse {
    // message fields
    pub signature: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageResponse {
    fn default() -> &'a SignMessageResponse {
        <SignMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageResponse {
    pub fn new() -> SignMessageResponse {
        ::std::default::Default::default()
    }

    // string signature = 1;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_string(1, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageResponse {
        SignMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &SignMessageResponse| { &m.signature },
                    |m: &mut SignMessageResponse| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageResponse>(
                    "SignMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageResponse,
        };
        unsafe {
            instance.get(SignMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageResponse {
    fn clear(&mut self) {
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyMessageRequest {
    // message fields
    pub msg: ::std::vec::Vec<u8>,
    pub signature: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyMessageRequest {
    fn default() -> &'a VerifyMessageRequest {
        <VerifyMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyMessageRequest {
    pub fn new() -> VerifyMessageRequest {
        ::std::default::Default::default()
    }

    // bytes msg = 1;


    pub fn get_msg(&self) -> &[u8] {
        &self.msg
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.msg
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.msg, ::std::vec::Vec::new())
    }

    // string signature = 2;


    pub fn get_signature(&self) -> &str {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signature, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyMessageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.msg)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.msg);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.msg.is_empty() {
            os.write_bytes(1, &self.msg)?;
        }
        if !self.signature.is_empty() {
            os.write_string(2, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageRequest {
        VerifyMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "msg",
                    |m: &VerifyMessageRequest| { &m.msg },
                    |m: &mut VerifyMessageRequest| { &mut m.msg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &VerifyMessageRequest| { &m.signature },
                    |m: &mut VerifyMessageRequest| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerifyMessageRequest>(
                    "VerifyMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<VerifyMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerifyMessageRequest,
        };
        unsafe {
            instance.get(VerifyMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for VerifyMessageRequest {
    fn clear(&mut self) {
        self.msg.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyMessageResponse {
    // message fields
    pub valid: bool,
    pub pubkey: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyMessageResponse {
    fn default() -> &'a VerifyMessageResponse {
        <VerifyMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyMessageResponse {
    pub fn new() -> VerifyMessageResponse {
        ::std::default::Default::default()
    }

    // bool valid = 1;


    pub fn get_valid(&self) -> bool {
        self.valid
    }
    pub fn clear_valid(&mut self) {
        self.valid = false;
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = v;
    }

    // string pubkey = 2;


    pub fn get_pubkey(&self) -> &str {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::string::String) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pubkey, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.valid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pubkey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valid != false {
            my_size += 2;
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pubkey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.valid != false {
            os.write_bool(1, self.valid)?;
        }
        if !self.pubkey.is_empty() {
            os.write_string(2, &self.pubkey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageResponse {
        VerifyMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "valid",
                    |m: &VerifyMessageResponse| { &m.valid },
                    |m: &mut VerifyMessageResponse| { &mut m.valid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pubkey",
                    |m: &VerifyMessageResponse| { &m.pubkey },
                    |m: &mut VerifyMessageResponse| { &mut m.pubkey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerifyMessageResponse>(
                    "VerifyMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<VerifyMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerifyMessageResponse,
        };
        unsafe {
            instance.get(VerifyMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for VerifyMessageResponse {
    fn clear(&mut self) {
        self.valid = false;
        self.pubkey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectPeerRequest {
    // message fields
    pub addr: ::protobuf::SingularPtrField<LightningAddress>,
    pub perm: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectPeerRequest {
    fn default() -> &'a ConnectPeerRequest {
        <ConnectPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectPeerRequest {
    pub fn new() -> ConnectPeerRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.LightningAddress addr = 1;


    pub fn get_addr(&self) -> &LightningAddress {
        self.addr.as_ref().unwrap_or_else(|| LightningAddress::default_instance())
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: LightningAddress) {
        self.addr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut LightningAddress {
        if self.addr.is_none() {
            self.addr.set_default();
        }
        self.addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_addr(&mut self) -> LightningAddress {
        self.addr.take().unwrap_or_else(|| LightningAddress::new())
    }

    // bool perm = 2;


    pub fn get_perm(&self) -> bool {
        self.perm
    }
    pub fn clear_perm(&mut self) {
        self.perm = false;
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: bool) {
        self.perm = v;
    }
}

impl ::protobuf::Message for ConnectPeerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.addr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addr)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.perm = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.perm != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.perm != false {
            os.write_bool(2, self.perm)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectPeerRequest {
        ConnectPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningAddress>>(
                    "addr",
                    |m: &ConnectPeerRequest| { &m.addr },
                    |m: &mut ConnectPeerRequest| { &mut m.addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "perm",
                    |m: &ConnectPeerRequest| { &m.perm },
                    |m: &mut ConnectPeerRequest| { &mut m.perm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectPeerRequest>(
                    "ConnectPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConnectPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectPeerRequest,
        };
        unsafe {
            instance.get(ConnectPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConnectPeerRequest {
    fn clear(&mut self) {
        self.addr.clear();
        self.perm = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectPeerResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectPeerResponse {
    fn default() -> &'a ConnectPeerResponse {
        <ConnectPeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectPeerResponse {
    pub fn new() -> ConnectPeerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConnectPeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectPeerResponse {
        ConnectPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConnectPeerResponse>(
                    "ConnectPeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectPeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<ConnectPeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectPeerResponse,
        };
        unsafe {
            instance.get(ConnectPeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for ConnectPeerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectPeerRequest {
    // message fields
    pub pub_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectPeerRequest {
    fn default() -> &'a DisconnectPeerRequest {
        <DisconnectPeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectPeerRequest {
    pub fn new() -> DisconnectPeerRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DisconnectPeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectPeerRequest {
        DisconnectPeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &DisconnectPeerRequest| { &m.pub_key },
                    |m: &mut DisconnectPeerRequest| { &mut m.pub_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisconnectPeerRequest>(
                    "DisconnectPeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisconnectPeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<DisconnectPeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisconnectPeerRequest,
        };
        unsafe {
            instance.get(DisconnectPeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for DisconnectPeerRequest {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectPeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectPeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectPeerResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectPeerResponse {
    fn default() -> &'a DisconnectPeerResponse {
        <DisconnectPeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectPeerResponse {
    pub fn new() -> DisconnectPeerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisconnectPeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectPeerResponse {
        DisconnectPeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DisconnectPeerResponse>(
                    "DisconnectPeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisconnectPeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<DisconnectPeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisconnectPeerResponse,
        };
        unsafe {
            instance.get(DisconnectPeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for DisconnectPeerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectPeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectPeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTLC {
    // message fields
    pub incoming: bool,
    pub amount: i64,
    pub hash_lock: ::std::vec::Vec<u8>,
    pub expiration_height: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTLC {
    fn default() -> &'a HTLC {
        <HTLC as ::protobuf::Message>::default_instance()
    }
}

impl HTLC {
    pub fn new() -> HTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;


    pub fn get_incoming(&self) -> bool {
        self.incoming
    }
    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // bytes hash_lock = 3;


    pub fn get_hash_lock(&self) -> &[u8] {
        &self.hash_lock
    }
    pub fn clear_hash_lock(&mut self) {
        self.hash_lock.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_lock(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash_lock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash_lock(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash_lock
    }

    // Take field
    pub fn take_hash_lock(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash_lock, ::std::vec::Vec::new())
    }

    // uint32 expiration_height = 4;


    pub fn get_expiration_height(&self) -> u32 {
        self.expiration_height
    }
    pub fn clear_expiration_height(&mut self) {
        self.expiration_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_height(&mut self, v: u32) {
        self.expiration_height = v;
    }
}

impl ::protobuf::Message for HTLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash_lock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash_lock.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.hash_lock);
        }
        if self.expiration_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.expiration_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if !self.hash_lock.is_empty() {
            os.write_bytes(3, &self.hash_lock)?;
        }
        if self.expiration_height != 0 {
            os.write_uint32(4, self.expiration_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTLC {
        HTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "incoming",
                    |m: &HTLC| { &m.incoming },
                    |m: &mut HTLC| { &mut m.incoming },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &HTLC| { &m.amount },
                    |m: &mut HTLC| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash_lock",
                    |m: &HTLC| { &m.hash_lock },
                    |m: &mut HTLC| { &mut m.hash_lock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expiration_height",
                    |m: &HTLC| { &m.expiration_height },
                    |m: &mut HTLC| { &mut m.expiration_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTLC>(
                    "HTLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTLC {
        static mut instance: ::protobuf::lazy::Lazy<HTLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTLC,
        };
        unsafe {
            instance.get(HTLC::new)
        }
    }
}

impl ::protobuf::Clear for HTLC {
    fn clear(&mut self) {
        self.incoming = false;
        self.amount = 0;
        self.hash_lock.clear();
        self.expiration_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel {
    // message fields
    pub active: bool,
    pub remote_pubkey: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub chan_id: u64,
    pub capacity: i64,
    pub local_balance: i64,
    pub remote_balance: i64,
    pub commit_fee: i64,
    pub commit_weight: i64,
    pub fee_per_kw: i64,
    pub unsettled_balance: i64,
    pub total_satoshis_sent: i64,
    pub total_satoshis_received: i64,
    pub num_updates: u64,
    pub pending_htlcs: ::protobuf::RepeatedField<HTLC>,
    pub csv_delay: u32,
    pub private: bool,
    pub initiator: bool,
    pub chan_status_flags: ::std::string::String,
    pub local_chan_reserve_sat: i64,
    pub remote_chan_reserve_sat: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Channel {
    fn default() -> &'a Channel {
        <Channel as ::protobuf::Message>::default_instance()
    }
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // bool active = 1;


    pub fn get_active(&self) -> bool {
        self.active
    }
    pub fn clear_active(&mut self) {
        self.active = false;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = v;
    }

    // string remote_pubkey = 2;


    pub fn get_remote_pubkey(&self) -> &str {
        &self.remote_pubkey
    }
    pub fn clear_remote_pubkey(&mut self) {
        self.remote_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pubkey(&mut self, v: ::std::string::String) {
        self.remote_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pubkey
    }

    // Take field
    pub fn take_remote_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pubkey, ::std::string::String::new())
    }

    // string channel_point = 3;


    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    // uint64 chan_id = 4;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // int64 capacity = 5;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // int64 local_balance = 6;


    pub fn get_local_balance(&self) -> i64 {
        self.local_balance
    }
    pub fn clear_local_balance(&mut self) {
        self.local_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: i64) {
        self.local_balance = v;
    }

    // int64 remote_balance = 7;


    pub fn get_remote_balance(&self) -> i64 {
        self.remote_balance
    }
    pub fn clear_remote_balance(&mut self) {
        self.remote_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: i64) {
        self.remote_balance = v;
    }

    // int64 commit_fee = 8;


    pub fn get_commit_fee(&self) -> i64 {
        self.commit_fee
    }
    pub fn clear_commit_fee(&mut self) {
        self.commit_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: i64) {
        self.commit_fee = v;
    }

    // int64 commit_weight = 9;


    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }
    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    // int64 fee_per_kw = 10;


    pub fn get_fee_per_kw(&self) -> i64 {
        self.fee_per_kw
    }
    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: i64) {
        self.fee_per_kw = v;
    }

    // int64 unsettled_balance = 11;


    pub fn get_unsettled_balance(&self) -> i64 {
        self.unsettled_balance
    }
    pub fn clear_unsettled_balance(&mut self) {
        self.unsettled_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_unsettled_balance(&mut self, v: i64) {
        self.unsettled_balance = v;
    }

    // int64 total_satoshis_sent = 12;


    pub fn get_total_satoshis_sent(&self) -> i64 {
        self.total_satoshis_sent
    }
    pub fn clear_total_satoshis_sent(&mut self) {
        self.total_satoshis_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_satoshis_sent(&mut self, v: i64) {
        self.total_satoshis_sent = v;
    }

    // int64 total_satoshis_received = 13;


    pub fn get_total_satoshis_received(&self) -> i64 {
        self.total_satoshis_received
    }
    pub fn clear_total_satoshis_received(&mut self) {
        self.total_satoshis_received = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_satoshis_received(&mut self, v: i64) {
        self.total_satoshis_received = v;
    }

    // uint64 num_updates = 14;


    pub fn get_num_updates(&self) -> u64 {
        self.num_updates
    }
    pub fn clear_num_updates(&mut self) {
        self.num_updates = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_updates(&mut self, v: u64) {
        self.num_updates = v;
    }

    // repeated .lnrpc.HTLC pending_htlcs = 15;


    pub fn get_pending_htlcs(&self) -> &[HTLC] {
        &self.pending_htlcs
    }
    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<HTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<HTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<HTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }

    // uint32 csv_delay = 16;


    pub fn get_csv_delay(&self) -> u32 {
        self.csv_delay
    }
    pub fn clear_csv_delay(&mut self) {
        self.csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_csv_delay(&mut self, v: u32) {
        self.csv_delay = v;
    }

    // bool private = 17;


    pub fn get_private(&self) -> bool {
        self.private
    }
    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    // bool initiator = 18;


    pub fn get_initiator(&self) -> bool {
        self.initiator
    }
    pub fn clear_initiator(&mut self) {
        self.initiator = false;
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: bool) {
        self.initiator = v;
    }

    // string chan_status_flags = 19;


    pub fn get_chan_status_flags(&self) -> &str {
        &self.chan_status_flags
    }
    pub fn clear_chan_status_flags(&mut self) {
        self.chan_status_flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_status_flags(&mut self, v: ::std::string::String) {
        self.chan_status_flags = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_status_flags(&mut self) -> &mut ::std::string::String {
        &mut self.chan_status_flags
    }

    // Take field
    pub fn take_chan_status_flags(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_status_flags, ::std::string::String::new())
    }

    // int64 local_chan_reserve_sat = 20;


    pub fn get_local_chan_reserve_sat(&self) -> i64 {
        self.local_chan_reserve_sat
    }
    pub fn clear_local_chan_reserve_sat(&mut self) {
        self.local_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_chan_reserve_sat(&mut self, v: i64) {
        self.local_chan_reserve_sat = v;
    }

    // int64 remote_chan_reserve_sat = 21;


    pub fn get_remote_chan_reserve_sat(&self) -> i64 {
        self.remote_chan_reserve_sat
    }
    pub fn clear_remote_chan_reserve_sat(&mut self) {
        self.remote_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_chan_reserve_sat(&mut self, v: i64) {
        self.remote_chan_reserve_sat = v;
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_balance = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_balance = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_fee = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_kw = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unsettled_balance = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_satoshis_sent = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_satoshis_received = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_updates = tmp;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.csv_delay = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.initiator = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_status_flags)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_chan_reserve_sat = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_chan_reserve_sat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active != false {
            my_size += 2;
        }
        if !self.remote_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.remote_pubkey);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.channel_point);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_balance != 0 {
            my_size += ::protobuf::rt::value_size(6, self.local_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_balance != 0 {
            my_size += ::protobuf::rt::value_size(7, self.remote_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_fee != 0 {
            my_size += ::protobuf::rt::value_size(8, self.commit_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(9, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(10, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unsettled_balance != 0 {
            my_size += ::protobuf::rt::value_size(11, self.unsettled_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_satoshis_sent != 0 {
            my_size += ::protobuf::rt::value_size(12, self.total_satoshis_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_satoshis_received != 0 {
            my_size += ::protobuf::rt::value_size(13, self.total_satoshis_received, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_updates != 0 {
            my_size += ::protobuf::rt::value_size(14, self.num_updates, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(16, self.csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.private != false {
            my_size += 3;
        }
        if self.initiator != false {
            my_size += 3;
        }
        if !self.chan_status_flags.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.chan_status_flags);
        }
        if self.local_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(20, self.local_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(21, self.remote_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.active != false {
            os.write_bool(1, self.active)?;
        }
        if !self.remote_pubkey.is_empty() {
            os.write_string(2, &self.remote_pubkey)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(3, &self.channel_point)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(4, self.chan_id)?;
        }
        if self.capacity != 0 {
            os.write_int64(5, self.capacity)?;
        }
        if self.local_balance != 0 {
            os.write_int64(6, self.local_balance)?;
        }
        if self.remote_balance != 0 {
            os.write_int64(7, self.remote_balance)?;
        }
        if self.commit_fee != 0 {
            os.write_int64(8, self.commit_fee)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(9, self.commit_weight)?;
        }
        if self.fee_per_kw != 0 {
            os.write_int64(10, self.fee_per_kw)?;
        }
        if self.unsettled_balance != 0 {
            os.write_int64(11, self.unsettled_balance)?;
        }
        if self.total_satoshis_sent != 0 {
            os.write_int64(12, self.total_satoshis_sent)?;
        }
        if self.total_satoshis_received != 0 {
            os.write_int64(13, self.total_satoshis_received)?;
        }
        if self.num_updates != 0 {
            os.write_uint64(14, self.num_updates)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.csv_delay != 0 {
            os.write_uint32(16, self.csv_delay)?;
        }
        if self.private != false {
            os.write_bool(17, self.private)?;
        }
        if self.initiator != false {
            os.write_bool(18, self.initiator)?;
        }
        if !self.chan_status_flags.is_empty() {
            os.write_string(19, &self.chan_status_flags)?;
        }
        if self.local_chan_reserve_sat != 0 {
            os.write_int64(20, self.local_chan_reserve_sat)?;
        }
        if self.remote_chan_reserve_sat != 0 {
            os.write_int64(21, self.remote_chan_reserve_sat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active",
                    |m: &Channel| { &m.active },
                    |m: &mut Channel| { &mut m.active },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_pubkey",
                    |m: &Channel| { &m.remote_pubkey },
                    |m: &mut Channel| { &mut m.remote_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &Channel| { &m.channel_point },
                    |m: &mut Channel| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &Channel| { &m.chan_id },
                    |m: &mut Channel| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &Channel| { &m.capacity },
                    |m: &mut Channel| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_balance",
                    |m: &Channel| { &m.local_balance },
                    |m: &mut Channel| { &mut m.local_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remote_balance",
                    |m: &Channel| { &m.remote_balance },
                    |m: &mut Channel| { &mut m.remote_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_fee",
                    |m: &Channel| { &m.commit_fee },
                    |m: &mut Channel| { &mut m.commit_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_weight",
                    |m: &Channel| { &m.commit_weight },
                    |m: &mut Channel| { &mut m.commit_weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_per_kw",
                    |m: &Channel| { &m.fee_per_kw },
                    |m: &mut Channel| { &mut m.fee_per_kw },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unsettled_balance",
                    |m: &Channel| { &m.unsettled_balance },
                    |m: &mut Channel| { &mut m.unsettled_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_satoshis_sent",
                    |m: &Channel| { &m.total_satoshis_sent },
                    |m: &mut Channel| { &mut m.total_satoshis_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_satoshis_received",
                    |m: &Channel| { &m.total_satoshis_received },
                    |m: &mut Channel| { &mut m.total_satoshis_received },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_updates",
                    |m: &Channel| { &m.num_updates },
                    |m: &mut Channel| { &mut m.num_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTLC>>(
                    "pending_htlcs",
                    |m: &Channel| { &m.pending_htlcs },
                    |m: &mut Channel| { &mut m.pending_htlcs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "csv_delay",
                    |m: &Channel| { &m.csv_delay },
                    |m: &mut Channel| { &mut m.csv_delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &Channel| { &m.private },
                    |m: &mut Channel| { &mut m.private },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "initiator",
                    |m: &Channel| { &m.initiator },
                    |m: &mut Channel| { &mut m.initiator },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chan_status_flags",
                    |m: &Channel| { &m.chan_status_flags },
                    |m: &mut Channel| { &mut m.chan_status_flags },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_chan_reserve_sat",
                    |m: &Channel| { &m.local_chan_reserve_sat },
                    |m: &mut Channel| { &mut m.local_chan_reserve_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remote_chan_reserve_sat",
                    |m: &Channel| { &m.remote_chan_reserve_sat },
                    |m: &mut Channel| { &mut m.remote_chan_reserve_sat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Channel>(
                    "Channel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Channel {
        static mut instance: ::protobuf::lazy::Lazy<Channel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Channel,
        };
        unsafe {
            instance.get(Channel::new)
        }
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.active = false;
        self.remote_pubkey.clear();
        self.channel_point.clear();
        self.chan_id = 0;
        self.capacity = 0;
        self.local_balance = 0;
        self.remote_balance = 0;
        self.commit_fee = 0;
        self.commit_weight = 0;
        self.fee_per_kw = 0;
        self.unsettled_balance = 0;
        self.total_satoshis_sent = 0;
        self.total_satoshis_received = 0;
        self.num_updates = 0;
        self.pending_htlcs.clear();
        self.csv_delay = 0;
        self.private = false;
        self.initiator = false;
        self.chan_status_flags.clear();
        self.local_chan_reserve_sat = 0;
        self.remote_chan_reserve_sat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelsRequest {
    // message fields
    pub active_only: bool,
    pub inactive_only: bool,
    pub public_only: bool,
    pub private_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChannelsRequest {
    fn default() -> &'a ListChannelsRequest {
        <ListChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListChannelsRequest {
    pub fn new() -> ListChannelsRequest {
        ::std::default::Default::default()
    }

    // bool active_only = 1;


    pub fn get_active_only(&self) -> bool {
        self.active_only
    }
    pub fn clear_active_only(&mut self) {
        self.active_only = false;
    }

    // Param is passed by value, moved
    pub fn set_active_only(&mut self, v: bool) {
        self.active_only = v;
    }

    // bool inactive_only = 2;


    pub fn get_inactive_only(&self) -> bool {
        self.inactive_only
    }
    pub fn clear_inactive_only(&mut self) {
        self.inactive_only = false;
    }

    // Param is passed by value, moved
    pub fn set_inactive_only(&mut self, v: bool) {
        self.inactive_only = v;
    }

    // bool public_only = 3;


    pub fn get_public_only(&self) -> bool {
        self.public_only
    }
    pub fn clear_public_only(&mut self) {
        self.public_only = false;
    }

    // Param is passed by value, moved
    pub fn set_public_only(&mut self, v: bool) {
        self.public_only = v;
    }

    // bool private_only = 4;


    pub fn get_private_only(&self) -> bool {
        self.private_only
    }
    pub fn clear_private_only(&mut self) {
        self.private_only = false;
    }

    // Param is passed by value, moved
    pub fn set_private_only(&mut self, v: bool) {
        self.private_only = v;
    }
}

impl ::protobuf::Message for ListChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active_only = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inactive_only = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.public_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active_only != false {
            my_size += 2;
        }
        if self.inactive_only != false {
            my_size += 2;
        }
        if self.public_only != false {
            my_size += 2;
        }
        if self.private_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.active_only != false {
            os.write_bool(1, self.active_only)?;
        }
        if self.inactive_only != false {
            os.write_bool(2, self.inactive_only)?;
        }
        if self.public_only != false {
            os.write_bool(3, self.public_only)?;
        }
        if self.private_only != false {
            os.write_bool(4, self.private_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsRequest {
        ListChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "active_only",
                    |m: &ListChannelsRequest| { &m.active_only },
                    |m: &mut ListChannelsRequest| { &mut m.active_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inactive_only",
                    |m: &ListChannelsRequest| { &m.inactive_only },
                    |m: &mut ListChannelsRequest| { &mut m.inactive_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "public_only",
                    |m: &ListChannelsRequest| { &m.public_only },
                    |m: &mut ListChannelsRequest| { &mut m.public_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private_only",
                    |m: &ListChannelsRequest| { &m.private_only },
                    |m: &mut ListChannelsRequest| { &mut m.private_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListChannelsRequest>(
                    "ListChannelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListChannelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListChannelsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListChannelsRequest,
        };
        unsafe {
            instance.get(ListChannelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListChannelsRequest {
    fn clear(&mut self) {
        self.active_only = false;
        self.inactive_only = false;
        self.public_only = false;
        self.private_only = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListChannelsResponse {
    // message fields
    pub channels: ::protobuf::RepeatedField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListChannelsResponse {
    fn default() -> &'a ListChannelsResponse {
        <ListChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListChannelsResponse {
    pub fn new() -> ListChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Channel channels = 11;


    pub fn get_channels(&self) -> &[Channel] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListChannelsResponse {
        ListChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                    "channels",
                    |m: &ListChannelsResponse| { &m.channels },
                    |m: &mut ListChannelsResponse| { &mut m.channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListChannelsResponse>(
                    "ListChannelsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListChannelsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListChannelsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListChannelsResponse,
        };
        unsafe {
            instance.get(ListChannelsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListChannelsResponse {
    fn clear(&mut self) {
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelCloseSummary {
    // message fields
    pub channel_point: ::std::string::String,
    pub chan_id: u64,
    pub chain_hash: ::std::string::String,
    pub closing_tx_hash: ::std::string::String,
    pub remote_pubkey: ::std::string::String,
    pub capacity: i64,
    pub close_height: u32,
    pub settled_balance: i64,
    pub time_locked_balance: i64,
    pub close_type: ChannelCloseSummary_ClosureType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelCloseSummary {
    fn default() -> &'a ChannelCloseSummary {
        <ChannelCloseSummary as ::protobuf::Message>::default_instance()
    }
}

impl ChannelCloseSummary {
    pub fn new() -> ChannelCloseSummary {
        ::std::default::Default::default()
    }

    // string channel_point = 1;


    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    // uint64 chan_id = 2;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // string chain_hash = 3;


    pub fn get_chain_hash(&self) -> &str {
        &self.chain_hash
    }
    pub fn clear_chain_hash(&mut self) {
        self.chain_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain_hash(&mut self, v: ::std::string::String) {
        self.chain_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_hash(&mut self) -> &mut ::std::string::String {
        &mut self.chain_hash
    }

    // Take field
    pub fn take_chain_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain_hash, ::std::string::String::new())
    }

    // string closing_tx_hash = 4;


    pub fn get_closing_tx_hash(&self) -> &str {
        &self.closing_tx_hash
    }
    pub fn clear_closing_tx_hash(&mut self) {
        self.closing_tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_tx_hash(&mut self, v: ::std::string::String) {
        self.closing_tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_tx_hash(&mut self) -> &mut ::std::string::String {
        &mut self.closing_tx_hash
    }

    // Take field
    pub fn take_closing_tx_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_tx_hash, ::std::string::String::new())
    }

    // string remote_pubkey = 5;


    pub fn get_remote_pubkey(&self) -> &str {
        &self.remote_pubkey
    }
    pub fn clear_remote_pubkey(&mut self) {
        self.remote_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_pubkey(&mut self, v: ::std::string::String) {
        self.remote_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.remote_pubkey
    }

    // Take field
    pub fn take_remote_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_pubkey, ::std::string::String::new())
    }

    // int64 capacity = 6;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // uint32 close_height = 7;


    pub fn get_close_height(&self) -> u32 {
        self.close_height
    }
    pub fn clear_close_height(&mut self) {
        self.close_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_close_height(&mut self, v: u32) {
        self.close_height = v;
    }

    // int64 settled_balance = 8;


    pub fn get_settled_balance(&self) -> i64 {
        self.settled_balance
    }
    pub fn clear_settled_balance(&mut self) {
        self.settled_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_settled_balance(&mut self, v: i64) {
        self.settled_balance = v;
    }

    // int64 time_locked_balance = 9;


    pub fn get_time_locked_balance(&self) -> i64 {
        self.time_locked_balance
    }
    pub fn clear_time_locked_balance(&mut self) {
        self.time_locked_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_locked_balance(&mut self, v: i64) {
        self.time_locked_balance = v;
    }

    // .lnrpc.ChannelCloseSummary.ClosureType close_type = 10;


    pub fn get_close_type(&self) -> ChannelCloseSummary_ClosureType {
        self.close_type
    }
    pub fn clear_close_type(&mut self) {
        self.close_type = ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE;
    }

    // Param is passed by value, moved
    pub fn set_close_type(&mut self, v: ChannelCloseSummary_ClosureType) {
        self.close_type = v;
    }
}

impl ::protobuf::Message for ChannelCloseSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_tx_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_pubkey)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.close_height = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settled_balance = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.time_locked_balance = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.close_type, 10, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_point);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chain_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.chain_hash);
        }
        if !self.closing_tx_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.closing_tx_hash);
        }
        if !self.remote_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.remote_pubkey);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.close_height != 0 {
            my_size += ::protobuf::rt::value_size(7, self.close_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settled_balance != 0 {
            my_size += ::protobuf::rt::value_size(8, self.settled_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_locked_balance != 0 {
            my_size += ::protobuf::rt::value_size(9, self.time_locked_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.close_type != ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE {
            my_size += ::protobuf::rt::enum_size(10, self.close_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_point.is_empty() {
            os.write_string(1, &self.channel_point)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(2, self.chan_id)?;
        }
        if !self.chain_hash.is_empty() {
            os.write_string(3, &self.chain_hash)?;
        }
        if !self.closing_tx_hash.is_empty() {
            os.write_string(4, &self.closing_tx_hash)?;
        }
        if !self.remote_pubkey.is_empty() {
            os.write_string(5, &self.remote_pubkey)?;
        }
        if self.capacity != 0 {
            os.write_int64(6, self.capacity)?;
        }
        if self.close_height != 0 {
            os.write_uint32(7, self.close_height)?;
        }
        if self.settled_balance != 0 {
            os.write_int64(8, self.settled_balance)?;
        }
        if self.time_locked_balance != 0 {
            os.write_int64(9, self.time_locked_balance)?;
        }
        if self.close_type != ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE {
            os.write_enum(10, self.close_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCloseSummary {
        ChannelCloseSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &ChannelCloseSummary| { &m.channel_point },
                    |m: &mut ChannelCloseSummary| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ChannelCloseSummary| { &m.chan_id },
                    |m: &mut ChannelCloseSummary| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chain_hash",
                    |m: &ChannelCloseSummary| { &m.chain_hash },
                    |m: &mut ChannelCloseSummary| { &mut m.chain_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_tx_hash",
                    |m: &ChannelCloseSummary| { &m.closing_tx_hash },
                    |m: &mut ChannelCloseSummary| { &mut m.closing_tx_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_pubkey",
                    |m: &ChannelCloseSummary| { &m.remote_pubkey },
                    |m: &mut ChannelCloseSummary| { &mut m.remote_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ChannelCloseSummary| { &m.capacity },
                    |m: &mut ChannelCloseSummary| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "close_height",
                    |m: &ChannelCloseSummary| { &m.close_height },
                    |m: &mut ChannelCloseSummary| { &mut m.close_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "settled_balance",
                    |m: &ChannelCloseSummary| { &m.settled_balance },
                    |m: &mut ChannelCloseSummary| { &mut m.settled_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "time_locked_balance",
                    |m: &ChannelCloseSummary| { &m.time_locked_balance },
                    |m: &mut ChannelCloseSummary| { &mut m.time_locked_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelCloseSummary_ClosureType>>(
                    "close_type",
                    |m: &ChannelCloseSummary| { &m.close_type },
                    |m: &mut ChannelCloseSummary| { &mut m.close_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelCloseSummary>(
                    "ChannelCloseSummary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelCloseSummary {
        static mut instance: ::protobuf::lazy::Lazy<ChannelCloseSummary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelCloseSummary,
        };
        unsafe {
            instance.get(ChannelCloseSummary::new)
        }
    }
}

impl ::protobuf::Clear for ChannelCloseSummary {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.chan_id = 0;
        self.chain_hash.clear();
        self.closing_tx_hash.clear();
        self.remote_pubkey.clear();
        self.capacity = 0;
        self.close_height = 0;
        self.settled_balance = 0;
        self.time_locked_balance = 0;
        self.close_type = ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCloseSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChannelCloseSummary_ClosureType {
    COOPERATIVE_CLOSE = 0,
    LOCAL_FORCE_CLOSE = 1,
    REMOTE_FORCE_CLOSE = 2,
    BREACH_CLOSE = 3,
    FUNDING_CANCELED = 4,
    ABANDONED = 5,
}

impl ::protobuf::ProtobufEnum for ChannelCloseSummary_ClosureType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelCloseSummary_ClosureType> {
        match value {
            0 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE),
            1 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::LOCAL_FORCE_CLOSE),
            2 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::REMOTE_FORCE_CLOSE),
            3 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::BREACH_CLOSE),
            4 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::FUNDING_CANCELED),
            5 => ::std::option::Option::Some(ChannelCloseSummary_ClosureType::ABANDONED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelCloseSummary_ClosureType] = &[
            ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE,
            ChannelCloseSummary_ClosureType::LOCAL_FORCE_CLOSE,
            ChannelCloseSummary_ClosureType::REMOTE_FORCE_CLOSE,
            ChannelCloseSummary_ClosureType::BREACH_CLOSE,
            ChannelCloseSummary_ClosureType::FUNDING_CANCELED,
            ChannelCloseSummary_ClosureType::ABANDONED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChannelCloseSummary_ClosureType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChannelCloseSummary_ClosureType {
}

impl ::std::default::Default for ChannelCloseSummary_ClosureType {
    fn default() -> Self {
        ChannelCloseSummary_ClosureType::COOPERATIVE_CLOSE
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseSummary_ClosureType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClosedChannelsRequest {
    // message fields
    pub cooperative: bool,
    pub local_force: bool,
    pub remote_force: bool,
    pub breach: bool,
    pub funding_canceled: bool,
    pub abandoned: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClosedChannelsRequest {
    fn default() -> &'a ClosedChannelsRequest {
        <ClosedChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClosedChannelsRequest {
    pub fn new() -> ClosedChannelsRequest {
        ::std::default::Default::default()
    }

    // bool cooperative = 1;


    pub fn get_cooperative(&self) -> bool {
        self.cooperative
    }
    pub fn clear_cooperative(&mut self) {
        self.cooperative = false;
    }

    // Param is passed by value, moved
    pub fn set_cooperative(&mut self, v: bool) {
        self.cooperative = v;
    }

    // bool local_force = 2;


    pub fn get_local_force(&self) -> bool {
        self.local_force
    }
    pub fn clear_local_force(&mut self) {
        self.local_force = false;
    }

    // Param is passed by value, moved
    pub fn set_local_force(&mut self, v: bool) {
        self.local_force = v;
    }

    // bool remote_force = 3;


    pub fn get_remote_force(&self) -> bool {
        self.remote_force
    }
    pub fn clear_remote_force(&mut self) {
        self.remote_force = false;
    }

    // Param is passed by value, moved
    pub fn set_remote_force(&mut self, v: bool) {
        self.remote_force = v;
    }

    // bool breach = 4;


    pub fn get_breach(&self) -> bool {
        self.breach
    }
    pub fn clear_breach(&mut self) {
        self.breach = false;
    }

    // Param is passed by value, moved
    pub fn set_breach(&mut self, v: bool) {
        self.breach = v;
    }

    // bool funding_canceled = 5;


    pub fn get_funding_canceled(&self) -> bool {
        self.funding_canceled
    }
    pub fn clear_funding_canceled(&mut self) {
        self.funding_canceled = false;
    }

    // Param is passed by value, moved
    pub fn set_funding_canceled(&mut self, v: bool) {
        self.funding_canceled = v;
    }

    // bool abandoned = 6;


    pub fn get_abandoned(&self) -> bool {
        self.abandoned
    }
    pub fn clear_abandoned(&mut self) {
        self.abandoned = false;
    }

    // Param is passed by value, moved
    pub fn set_abandoned(&mut self, v: bool) {
        self.abandoned = v;
    }
}

impl ::protobuf::Message for ClosedChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cooperative = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local_force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remote_force = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.breach = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.funding_canceled = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.abandoned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cooperative != false {
            my_size += 2;
        }
        if self.local_force != false {
            my_size += 2;
        }
        if self.remote_force != false {
            my_size += 2;
        }
        if self.breach != false {
            my_size += 2;
        }
        if self.funding_canceled != false {
            my_size += 2;
        }
        if self.abandoned != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cooperative != false {
            os.write_bool(1, self.cooperative)?;
        }
        if self.local_force != false {
            os.write_bool(2, self.local_force)?;
        }
        if self.remote_force != false {
            os.write_bool(3, self.remote_force)?;
        }
        if self.breach != false {
            os.write_bool(4, self.breach)?;
        }
        if self.funding_canceled != false {
            os.write_bool(5, self.funding_canceled)?;
        }
        if self.abandoned != false {
            os.write_bool(6, self.abandoned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelsRequest {
        ClosedChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cooperative",
                    |m: &ClosedChannelsRequest| { &m.cooperative },
                    |m: &mut ClosedChannelsRequest| { &mut m.cooperative },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "local_force",
                    |m: &ClosedChannelsRequest| { &m.local_force },
                    |m: &mut ClosedChannelsRequest| { &mut m.local_force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "remote_force",
                    |m: &ClosedChannelsRequest| { &m.remote_force },
                    |m: &mut ClosedChannelsRequest| { &mut m.remote_force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "breach",
                    |m: &ClosedChannelsRequest| { &m.breach },
                    |m: &mut ClosedChannelsRequest| { &mut m.breach },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "funding_canceled",
                    |m: &ClosedChannelsRequest| { &m.funding_canceled },
                    |m: &mut ClosedChannelsRequest| { &mut m.funding_canceled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "abandoned",
                    |m: &ClosedChannelsRequest| { &m.abandoned },
                    |m: &mut ClosedChannelsRequest| { &mut m.abandoned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClosedChannelsRequest>(
                    "ClosedChannelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClosedChannelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ClosedChannelsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClosedChannelsRequest,
        };
        unsafe {
            instance.get(ClosedChannelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ClosedChannelsRequest {
    fn clear(&mut self) {
        self.cooperative = false;
        self.local_force = false;
        self.remote_force = false;
        self.breach = false;
        self.funding_canceled = false;
        self.abandoned = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClosedChannelsResponse {
    // message fields
    pub channels: ::protobuf::RepeatedField<ChannelCloseSummary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClosedChannelsResponse {
    fn default() -> &'a ClosedChannelsResponse {
        <ClosedChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClosedChannelsResponse {
    pub fn new() -> ClosedChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelCloseSummary channels = 1;


    pub fn get_channels(&self) -> &[ChannelCloseSummary] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<ChannelCloseSummary>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<ChannelCloseSummary> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<ChannelCloseSummary> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ClosedChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelsResponse {
        ClosedChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelCloseSummary>>(
                    "channels",
                    |m: &ClosedChannelsResponse| { &m.channels },
                    |m: &mut ClosedChannelsResponse| { &mut m.channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClosedChannelsResponse>(
                    "ClosedChannelsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClosedChannelsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ClosedChannelsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClosedChannelsResponse,
        };
        unsafe {
            instance.get(ClosedChannelsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ClosedChannelsResponse {
    fn clear(&mut self) {
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Peer {
    // message fields
    pub pub_key: ::std::string::String,
    pub address: ::std::string::String,
    pub bytes_sent: u64,
    pub bytes_recv: u64,
    pub sat_sent: i64,
    pub sat_recv: i64,
    pub inbound: bool,
    pub ping_time: i64,
    pub sync_type: Peer_SyncType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Peer {
    fn default() -> &'a Peer {
        <Peer as ::protobuf::Message>::default_instance()
    }
}

impl Peer {
    pub fn new() -> Peer {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // uint64 bytes_sent = 4;


    pub fn get_bytes_sent(&self) -> u64 {
        self.bytes_sent
    }
    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: u64) {
        self.bytes_sent = v;
    }

    // uint64 bytes_recv = 5;


    pub fn get_bytes_recv(&self) -> u64 {
        self.bytes_recv
    }
    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: u64) {
        self.bytes_recv = v;
    }

    // int64 sat_sent = 6;


    pub fn get_sat_sent(&self) -> i64 {
        self.sat_sent
    }
    pub fn clear_sat_sent(&mut self) {
        self.sat_sent = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_sent(&mut self, v: i64) {
        self.sat_sent = v;
    }

    // int64 sat_recv = 7;


    pub fn get_sat_recv(&self) -> i64 {
        self.sat_recv
    }
    pub fn clear_sat_recv(&mut self) {
        self.sat_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_recv(&mut self, v: i64) {
        self.sat_recv = v;
    }

    // bool inbound = 8;


    pub fn get_inbound(&self) -> bool {
        self.inbound
    }
    pub fn clear_inbound(&mut self) {
        self.inbound = false;
    }

    // Param is passed by value, moved
    pub fn set_inbound(&mut self, v: bool) {
        self.inbound = v;
    }

    // int64 ping_time = 9;


    pub fn get_ping_time(&self) -> i64 {
        self.ping_time
    }
    pub fn clear_ping_time(&mut self) {
        self.ping_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: i64) {
        self.ping_time = v;
    }

    // .lnrpc.Peer.SyncType sync_type = 10;


    pub fn get_sync_type(&self) -> Peer_SyncType {
        self.sync_type
    }
    pub fn clear_sync_type(&mut self) {
        self.sync_type = Peer_SyncType::UNKNOWN_SYNC;
    }

    // Param is passed by value, moved
    pub fn set_sync_type(&mut self, v: Peer_SyncType) {
        self.sync_type = v;
    }
}

impl ::protobuf::Message for Peer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_sent = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_recv = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_sent = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_recv = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inbound = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ping_time = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sync_type, 10, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.bytes_sent != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bytes_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes_recv != 0 {
            my_size += ::protobuf::rt::value_size(5, self.bytes_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_sent != 0 {
            my_size += ::protobuf::rt::value_size(6, self.sat_sent, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_recv != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sat_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inbound != false {
            my_size += 2;
        }
        if self.ping_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.ping_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sync_type != Peer_SyncType::UNKNOWN_SYNC {
            my_size += ::protobuf::rt::enum_size(10, self.sync_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.bytes_sent != 0 {
            os.write_uint64(4, self.bytes_sent)?;
        }
        if self.bytes_recv != 0 {
            os.write_uint64(5, self.bytes_recv)?;
        }
        if self.sat_sent != 0 {
            os.write_int64(6, self.sat_sent)?;
        }
        if self.sat_recv != 0 {
            os.write_int64(7, self.sat_recv)?;
        }
        if self.inbound != false {
            os.write_bool(8, self.inbound)?;
        }
        if self.ping_time != 0 {
            os.write_int64(9, self.ping_time)?;
        }
        if self.sync_type != Peer_SyncType::UNKNOWN_SYNC {
            os.write_enum(10, self.sync_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Peer {
        Peer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &Peer| { &m.pub_key },
                    |m: &mut Peer| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &Peer| { &m.address },
                    |m: &mut Peer| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_sent",
                    |m: &Peer| { &m.bytes_sent },
                    |m: &mut Peer| { &mut m.bytes_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_recv",
                    |m: &Peer| { &m.bytes_recv },
                    |m: &mut Peer| { &mut m.bytes_recv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_sent",
                    |m: &Peer| { &m.sat_sent },
                    |m: &mut Peer| { &mut m.sat_sent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_recv",
                    |m: &Peer| { &m.sat_recv },
                    |m: &mut Peer| { &mut m.sat_recv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "inbound",
                    |m: &Peer| { &m.inbound },
                    |m: &mut Peer| { &mut m.inbound },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ping_time",
                    |m: &Peer| { &m.ping_time },
                    |m: &mut Peer| { &mut m.ping_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Peer_SyncType>>(
                    "sync_type",
                    |m: &Peer| { &m.sync_type },
                    |m: &mut Peer| { &mut m.sync_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Peer>(
                    "Peer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Peer {
        static mut instance: ::protobuf::lazy::Lazy<Peer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Peer,
        };
        unsafe {
            instance.get(Peer::new)
        }
    }
}

impl ::protobuf::Clear for Peer {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.address.clear();
        self.bytes_sent = 0;
        self.bytes_recv = 0;
        self.sat_sent = 0;
        self.sat_recv = 0;
        self.inbound = false;
        self.ping_time = 0;
        self.sync_type = Peer_SyncType::UNKNOWN_SYNC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Peer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Peer_SyncType {
    UNKNOWN_SYNC = 0,
    ACTIVE_SYNC = 1,
    PASSIVE_SYNC = 2,
}

impl ::protobuf::ProtobufEnum for Peer_SyncType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Peer_SyncType> {
        match value {
            0 => ::std::option::Option::Some(Peer_SyncType::UNKNOWN_SYNC),
            1 => ::std::option::Option::Some(Peer_SyncType::ACTIVE_SYNC),
            2 => ::std::option::Option::Some(Peer_SyncType::PASSIVE_SYNC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Peer_SyncType] = &[
            Peer_SyncType::UNKNOWN_SYNC,
            Peer_SyncType::ACTIVE_SYNC,
            Peer_SyncType::PASSIVE_SYNC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Peer_SyncType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Peer_SyncType {
}

impl ::std::default::Default for Peer_SyncType {
    fn default() -> Self {
        Peer_SyncType::UNKNOWN_SYNC
    }
}

impl ::protobuf::reflect::ProtobufValue for Peer_SyncType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPeersRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPeersRequest {
    fn default() -> &'a ListPeersRequest {
        <ListPeersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPeersRequest {
    pub fn new() -> ListPeersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListPeersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeersRequest {
        ListPeersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ListPeersRequest>(
                    "ListPeersRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPeersRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPeersRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPeersRequest,
        };
        unsafe {
            instance.get(ListPeersRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPeersRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPeersResponse {
    // message fields
    pub peers: ::protobuf::RepeatedField<Peer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPeersResponse {
    fn default() -> &'a ListPeersResponse {
        <ListPeersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPeersResponse {
    pub fn new() -> ListPeersResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Peer peers = 1;


    pub fn get_peers(&self) -> &[Peer] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<Peer>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<Peer> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<Peer> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListPeersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPeersResponse {
        ListPeersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Peer>>(
                    "peers",
                    |m: &ListPeersResponse| { &m.peers },
                    |m: &mut ListPeersResponse| { &mut m.peers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPeersResponse>(
                    "ListPeersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPeersResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPeersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPeersResponse,
        };
        unsafe {
            instance.get(ListPeersResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPeersResponse {
    fn clear(&mut self) {
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPeersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPeersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoRequest {
    fn default() -> &'a GetInfoRequest {
        <GetInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoRequest {
    pub fn new() -> GetInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoRequest {
        GetInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoRequest>(
                    "GetInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoRequest,
        };
        unsafe {
            instance.get(GetInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoResponse {
    // message fields
    pub identity_pubkey: ::std::string::String,
    pub alias: ::std::string::String,
    pub num_pending_channels: u32,
    pub num_active_channels: u32,
    pub num_peers: u32,
    pub block_height: u32,
    pub block_hash: ::std::string::String,
    pub synced_to_chain: bool,
    pub testnet: bool,
    pub uris: ::protobuf::RepeatedField<::std::string::String>,
    pub best_header_timestamp: i64,
    pub version: ::std::string::String,
    pub num_inactive_channels: u32,
    pub chains: ::protobuf::RepeatedField<Chain>,
    pub color: ::std::string::String,
    pub synced_to_graph: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoResponse {
    fn default() -> &'a GetInfoResponse {
        <GetInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoResponse {
    pub fn new() -> GetInfoResponse {
        ::std::default::Default::default()
    }

    // string identity_pubkey = 1;


    pub fn get_identity_pubkey(&self) -> &str {
        &self.identity_pubkey
    }
    pub fn clear_identity_pubkey(&mut self) {
        self.identity_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_pubkey(&mut self, v: ::std::string::String) {
        self.identity_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.identity_pubkey
    }

    // Take field
    pub fn take_identity_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_pubkey, ::std::string::String::new())
    }

    // string alias = 2;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // uint32 num_pending_channels = 3;


    pub fn get_num_pending_channels(&self) -> u32 {
        self.num_pending_channels
    }
    pub fn clear_num_pending_channels(&mut self) {
        self.num_pending_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_pending_channels(&mut self, v: u32) {
        self.num_pending_channels = v;
    }

    // uint32 num_active_channels = 4;


    pub fn get_num_active_channels(&self) -> u32 {
        self.num_active_channels
    }
    pub fn clear_num_active_channels(&mut self) {
        self.num_active_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_active_channels(&mut self, v: u32) {
        self.num_active_channels = v;
    }

    // uint32 num_peers = 5;


    pub fn get_num_peers(&self) -> u32 {
        self.num_peers
    }
    pub fn clear_num_peers(&mut self) {
        self.num_peers = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_peers(&mut self, v: u32) {
        self.num_peers = v;
    }

    // uint32 block_height = 6;


    pub fn get_block_height(&self) -> u32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: u32) {
        self.block_height = v;
    }

    // string block_hash = 8;


    pub fn get_block_hash(&self) -> &str {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::string::String) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::string::String {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block_hash, ::std::string::String::new())
    }

    // bool synced_to_chain = 9;


    pub fn get_synced_to_chain(&self) -> bool {
        self.synced_to_chain
    }
    pub fn clear_synced_to_chain(&mut self) {
        self.synced_to_chain = false;
    }

    // Param is passed by value, moved
    pub fn set_synced_to_chain(&mut self, v: bool) {
        self.synced_to_chain = v;
    }

    // bool testnet = 10;


    pub fn get_testnet(&self) -> bool {
        self.testnet
    }
    pub fn clear_testnet(&mut self) {
        self.testnet = false;
    }

    // Param is passed by value, moved
    pub fn set_testnet(&mut self, v: bool) {
        self.testnet = v;
    }

    // repeated string uris = 12;


    pub fn get_uris(&self) -> &[::std::string::String] {
        &self.uris
    }
    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    // int64 best_header_timestamp = 13;


    pub fn get_best_header_timestamp(&self) -> i64 {
        self.best_header_timestamp
    }
    pub fn clear_best_header_timestamp(&mut self) {
        self.best_header_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_best_header_timestamp(&mut self, v: i64) {
        self.best_header_timestamp = v;
    }

    // string version = 14;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // uint32 num_inactive_channels = 15;


    pub fn get_num_inactive_channels(&self) -> u32 {
        self.num_inactive_channels
    }
    pub fn clear_num_inactive_channels(&mut self) {
        self.num_inactive_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_inactive_channels(&mut self, v: u32) {
        self.num_inactive_channels = v;
    }

    // repeated .lnrpc.Chain chains = 16;


    pub fn get_chains(&self) -> &[Chain] {
        &self.chains
    }
    pub fn clear_chains(&mut self) {
        self.chains.clear();
    }

    // Param is passed by value, moved
    pub fn set_chains(&mut self, v: ::protobuf::RepeatedField<Chain>) {
        self.chains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chains(&mut self) -> &mut ::protobuf::RepeatedField<Chain> {
        &mut self.chains
    }

    // Take field
    pub fn take_chains(&mut self) -> ::protobuf::RepeatedField<Chain> {
        ::std::mem::replace(&mut self.chains, ::protobuf::RepeatedField::new())
    }

    // string color = 17;


    pub fn get_color(&self) -> &str {
        &self.color
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }

    // bool synced_to_graph = 18;


    pub fn get_synced_to_graph(&self) -> bool {
        self.synced_to_graph
    }
    pub fn clear_synced_to_graph(&mut self) {
        self.synced_to_graph = false;
    }

    // Param is passed by value, moved
    pub fn set_synced_to_graph(&mut self, v: bool) {
        self.synced_to_graph = v;
    }
}

impl ::protobuf::Message for GetInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.chains {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_pubkey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_pending_channels = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_active_channels = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_peers = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_height = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block_hash)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.synced_to_chain = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.testnet = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.uris)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.best_header_timestamp = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_inactive_channels = tmp;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chains)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.synced_to_graph = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_pubkey);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.alias);
        }
        if self.num_pending_channels != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_pending_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_active_channels != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_active_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_peers != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_peers, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(6, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.block_hash);
        }
        if self.synced_to_chain != false {
            my_size += 2;
        }
        if self.testnet != false {
            my_size += 2;
        }
        for value in &self.uris {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        if self.best_header_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(13, self.best_header_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.version);
        }
        if self.num_inactive_channels != 0 {
            my_size += ::protobuf::rt::value_size(15, self.num_inactive_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.chains {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.color);
        }
        if self.synced_to_graph != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_pubkey.is_empty() {
            os.write_string(1, &self.identity_pubkey)?;
        }
        if !self.alias.is_empty() {
            os.write_string(2, &self.alias)?;
        }
        if self.num_pending_channels != 0 {
            os.write_uint32(3, self.num_pending_channels)?;
        }
        if self.num_active_channels != 0 {
            os.write_uint32(4, self.num_active_channels)?;
        }
        if self.num_peers != 0 {
            os.write_uint32(5, self.num_peers)?;
        }
        if self.block_height != 0 {
            os.write_uint32(6, self.block_height)?;
        }
        if !self.block_hash.is_empty() {
            os.write_string(8, &self.block_hash)?;
        }
        if self.synced_to_chain != false {
            os.write_bool(9, self.synced_to_chain)?;
        }
        if self.testnet != false {
            os.write_bool(10, self.testnet)?;
        }
        for v in &self.uris {
            os.write_string(12, &v)?;
        };
        if self.best_header_timestamp != 0 {
            os.write_int64(13, self.best_header_timestamp)?;
        }
        if !self.version.is_empty() {
            os.write_string(14, &self.version)?;
        }
        if self.num_inactive_channels != 0 {
            os.write_uint32(15, self.num_inactive_channels)?;
        }
        for v in &self.chains {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.color.is_empty() {
            os.write_string(17, &self.color)?;
        }
        if self.synced_to_graph != false {
            os.write_bool(18, self.synced_to_graph)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoResponse {
        GetInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity_pubkey",
                    |m: &GetInfoResponse| { &m.identity_pubkey },
                    |m: &mut GetInfoResponse| { &mut m.identity_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &GetInfoResponse| { &m.alias },
                    |m: &mut GetInfoResponse| { &mut m.alias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_pending_channels",
                    |m: &GetInfoResponse| { &m.num_pending_channels },
                    |m: &mut GetInfoResponse| { &mut m.num_pending_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_active_channels",
                    |m: &GetInfoResponse| { &m.num_active_channels },
                    |m: &mut GetInfoResponse| { &mut m.num_active_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_peers",
                    |m: &GetInfoResponse| { &m.num_peers },
                    |m: &mut GetInfoResponse| { &mut m.num_peers },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "block_height",
                    |m: &GetInfoResponse| { &m.block_height },
                    |m: &mut GetInfoResponse| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block_hash",
                    |m: &GetInfoResponse| { &m.block_hash },
                    |m: &mut GetInfoResponse| { &mut m.block_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "synced_to_chain",
                    |m: &GetInfoResponse| { &m.synced_to_chain },
                    |m: &mut GetInfoResponse| { &mut m.synced_to_chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "testnet",
                    |m: &GetInfoResponse| { &m.testnet },
                    |m: &mut GetInfoResponse| { &mut m.testnet },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uris",
                    |m: &GetInfoResponse| { &m.uris },
                    |m: &mut GetInfoResponse| { &mut m.uris },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "best_header_timestamp",
                    |m: &GetInfoResponse| { &m.best_header_timestamp },
                    |m: &mut GetInfoResponse| { &mut m.best_header_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &GetInfoResponse| { &m.version },
                    |m: &mut GetInfoResponse| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_inactive_channels",
                    |m: &GetInfoResponse| { &m.num_inactive_channels },
                    |m: &mut GetInfoResponse| { &mut m.num_inactive_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Chain>>(
                    "chains",
                    |m: &GetInfoResponse| { &m.chains },
                    |m: &mut GetInfoResponse| { &mut m.chains },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "color",
                    |m: &GetInfoResponse| { &m.color },
                    |m: &mut GetInfoResponse| { &mut m.color },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "synced_to_graph",
                    |m: &GetInfoResponse| { &m.synced_to_graph },
                    |m: &mut GetInfoResponse| { &mut m.synced_to_graph },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoResponse>(
                    "GetInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoResponse,
        };
        unsafe {
            instance.get(GetInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoResponse {
    fn clear(&mut self) {
        self.identity_pubkey.clear();
        self.alias.clear();
        self.num_pending_channels = 0;
        self.num_active_channels = 0;
        self.num_peers = 0;
        self.block_height = 0;
        self.block_hash.clear();
        self.synced_to_chain = false;
        self.testnet = false;
        self.uris.clear();
        self.best_header_timestamp = 0;
        self.version.clear();
        self.num_inactive_channels = 0;
        self.chains.clear();
        self.color.clear();
        self.synced_to_graph = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Chain {
    // message fields
    pub chain: ::std::string::String,
    pub network: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Chain {
    fn default() -> &'a Chain {
        <Chain as ::protobuf::Message>::default_instance()
    }
}

impl Chain {
    pub fn new() -> Chain {
        ::std::default::Default::default()
    }

    // string chain = 1;


    pub fn get_chain(&self) -> &str {
        &self.chain
    }
    pub fn clear_chain(&mut self) {
        self.chain.clear();
    }

    // Param is passed by value, moved
    pub fn set_chain(&mut self, v: ::std::string::String) {
        self.chain = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain(&mut self) -> &mut ::std::string::String {
        &mut self.chain
    }

    // Take field
    pub fn take_chain(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chain, ::std::string::String::new())
    }

    // string network = 2;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Chain {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chain)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.chain.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chain);
        }
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.network);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.chain.is_empty() {
            os.write_string(1, &self.chain)?;
        }
        if !self.network.is_empty() {
            os.write_string(2, &self.network)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Chain {
        Chain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chain",
                    |m: &Chain| { &m.chain },
                    |m: &mut Chain| { &mut m.chain },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "network",
                    |m: &Chain| { &m.network },
                    |m: &mut Chain| { &mut m.network },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Chain>(
                    "Chain",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Chain {
        static mut instance: ::protobuf::lazy::Lazy<Chain> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Chain,
        };
        unsafe {
            instance.get(Chain::new)
        }
    }
}

impl ::protobuf::Clear for Chain {
    fn clear(&mut self) {
        self.chain.clear();
        self.network.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Chain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chain {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfirmationUpdate {
    // message fields
    pub block_sha: ::std::vec::Vec<u8>,
    pub block_height: i32,
    pub num_confs_left: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfirmationUpdate {
    fn default() -> &'a ConfirmationUpdate {
        <ConfirmationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ConfirmationUpdate {
    pub fn new() -> ConfirmationUpdate {
        ::std::default::Default::default()
    }

    // bytes block_sha = 1;


    pub fn get_block_sha(&self) -> &[u8] {
        &self.block_sha
    }
    pub fn clear_block_sha(&mut self) {
        self.block_sha.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_sha = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_sha(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_sha
    }

    // Take field
    pub fn take_block_sha(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_sha, ::std::vec::Vec::new())
    }

    // int32 block_height = 2;


    pub fn get_block_height(&self) -> i32 {
        self.block_height
    }
    pub fn clear_block_height(&mut self) {
        self.block_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_height(&mut self, v: i32) {
        self.block_height = v;
    }

    // uint32 num_confs_left = 3;


    pub fn get_num_confs_left(&self) -> u32 {
        self.num_confs_left
    }
    pub fn clear_num_confs_left(&mut self) {
        self.num_confs_left = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_confs_left(&mut self, v: u32) {
        self.num_confs_left = v;
    }
}

impl ::protobuf::Message for ConfirmationUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_sha)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_confs_left = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.block_sha.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block_sha);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_confs_left != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_confs_left, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.block_sha.is_empty() {
            os.write_bytes(1, &self.block_sha)?;
        }
        if self.block_height != 0 {
            os.write_int32(2, self.block_height)?;
        }
        if self.num_confs_left != 0 {
            os.write_uint32(3, self.num_confs_left)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfirmationUpdate {
        ConfirmationUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "block_sha",
                    |m: &ConfirmationUpdate| { &m.block_sha },
                    |m: &mut ConfirmationUpdate| { &mut m.block_sha },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "block_height",
                    |m: &ConfirmationUpdate| { &m.block_height },
                    |m: &mut ConfirmationUpdate| { &mut m.block_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_confs_left",
                    |m: &ConfirmationUpdate| { &m.num_confs_left },
                    |m: &mut ConfirmationUpdate| { &mut m.num_confs_left },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfirmationUpdate>(
                    "ConfirmationUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConfirmationUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ConfirmationUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfirmationUpdate,
        };
        unsafe {
            instance.get(ConfirmationUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ConfirmationUpdate {
    fn clear(&mut self) {
        self.block_sha.clear();
        self.block_height = 0;
        self.num_confs_left = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfirmationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfirmationUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelOpenUpdate {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelOpenUpdate {
    fn default() -> &'a ChannelOpenUpdate {
        <ChannelOpenUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ChannelOpenUpdate {
    pub fn new() -> ChannelOpenUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;


    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }
}

impl ::protobuf::Message for ChannelOpenUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelOpenUpdate {
        ChannelOpenUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &ChannelOpenUpdate| { &m.channel_point },
                    |m: &mut ChannelOpenUpdate| { &mut m.channel_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelOpenUpdate>(
                    "ChannelOpenUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelOpenUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelOpenUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelOpenUpdate,
        };
        unsafe {
            instance.get(ChannelOpenUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelOpenUpdate {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelOpenUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelOpenUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelCloseUpdate {
    // message fields
    pub closing_txid: ::std::vec::Vec<u8>,
    pub success: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelCloseUpdate {
    fn default() -> &'a ChannelCloseUpdate {
        <ChannelCloseUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ChannelCloseUpdate {
    pub fn new() -> ChannelCloseUpdate {
        ::std::default::Default::default()
    }

    // bytes closing_txid = 1;


    pub fn get_closing_txid(&self) -> &[u8] {
        &self.closing_txid
    }
    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.closing_txid, ::std::vec::Vec::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }
}

impl ::protobuf::Message for ChannelCloseUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.closing_txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.closing_txid);
        }
        if self.success != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.closing_txid.is_empty() {
            os.write_bytes(1, &self.closing_txid)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCloseUpdate {
        ChannelCloseUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "closing_txid",
                    |m: &ChannelCloseUpdate| { &m.closing_txid },
                    |m: &mut ChannelCloseUpdate| { &mut m.closing_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &ChannelCloseUpdate| { &m.success },
                    |m: &mut ChannelCloseUpdate| { &mut m.success },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelCloseUpdate>(
                    "ChannelCloseUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelCloseUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelCloseUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelCloseUpdate,
        };
        unsafe {
            instance.get(ChannelCloseUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelCloseUpdate {
    fn clear(&mut self) {
        self.closing_txid.clear();
        self.success = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCloseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCloseUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseChannelRequest {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub force: bool,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseChannelRequest {
    fn default() -> &'a CloseChannelRequest {
        <CloseChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseChannelRequest {
    pub fn new() -> CloseChannelRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;


    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // bool force = 2;


    pub fn get_force(&self) -> bool {
        self.force
    }
    pub fn clear_force(&mut self) {
        self.force = false;
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = v;
    }

    // int32 target_conf = 3;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // int64 sat_per_byte = 4;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }
}

impl ::protobuf::Message for CloseChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.force != false {
            my_size += 2;
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(4, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.force != false {
            os.write_bool(2, self.force)?;
        }
        if self.target_conf != 0 {
            os.write_int32(3, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(4, self.sat_per_byte)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseChannelRequest {
        CloseChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &CloseChannelRequest| { &m.channel_point },
                    |m: &mut CloseChannelRequest| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "force",
                    |m: &CloseChannelRequest| { &m.force },
                    |m: &mut CloseChannelRequest| { &mut m.force },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &CloseChannelRequest| { &m.target_conf },
                    |m: &mut CloseChannelRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &CloseChannelRequest| { &m.sat_per_byte },
                    |m: &mut CloseChannelRequest| { &mut m.sat_per_byte },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseChannelRequest>(
                    "CloseChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<CloseChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseChannelRequest,
        };
        unsafe {
            instance.get(CloseChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for CloseChannelRequest {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.force = false;
        self.target_conf = 0;
        self.sat_per_byte = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseStatusUpdate {
    // message oneof groups
    pub update: ::std::option::Option<CloseStatusUpdate_oneof_update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseStatusUpdate {
    fn default() -> &'a CloseStatusUpdate {
        <CloseStatusUpdate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CloseStatusUpdate_oneof_update {
    close_pending(PendingUpdate),
    chan_close(ChannelCloseUpdate),
}

impl CloseStatusUpdate {
    pub fn new() -> CloseStatusUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingUpdate close_pending = 1;


    pub fn get_close_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) => v,
            _ => PendingUpdate::default_instance(),
        }
    }
    pub fn clear_close_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_close_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_pending(&mut self) -> PendingUpdate {
        if self.has_close_pending() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    // .lnrpc.ChannelCloseUpdate chan_close = 3;


    pub fn get_chan_close(&self) -> &ChannelCloseUpdate {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) => v,
            _ => ChannelCloseUpdate::default_instance(),
        }
    }
    pub fn clear_chan_close(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_close(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_close(&mut self, v: ChannelCloseUpdate) {
        self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_close(&mut self) -> &mut ChannelCloseUpdate {
        if let ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ChannelCloseUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_close(&mut self) -> ChannelCloseUpdate {
        if self.has_chan_close() {
            match self.update.take() {
                ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelCloseUpdate::new()
        }
    }
}

impl ::protobuf::Message for CloseStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(CloseStatusUpdate_oneof_update::close_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CloseStatusUpdate_oneof_update::chan_close(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::close_pending(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(CloseStatusUpdate_oneof_update::chan_close(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &CloseStatusUpdate_oneof_update::close_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CloseStatusUpdate_oneof_update::chan_close(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseStatusUpdate {
        CloseStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                    "close_pending",
                    CloseStatusUpdate::has_close_pending,
                    CloseStatusUpdate::get_close_pending,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelCloseUpdate>(
                    "chan_close",
                    CloseStatusUpdate::has_chan_close,
                    CloseStatusUpdate::get_chan_close,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CloseStatusUpdate>(
                    "CloseStatusUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CloseStatusUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CloseStatusUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CloseStatusUpdate,
        };
        unsafe {
            instance.get(CloseStatusUpdate::new)
        }
    }
}

impl ::protobuf::Clear for CloseStatusUpdate {
    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingUpdate {
    // message fields
    pub txid: ::std::vec::Vec<u8>,
    pub output_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingUpdate {
    fn default() -> &'a PendingUpdate {
        <PendingUpdate as ::protobuf::Message>::default_instance()
    }
}

impl PendingUpdate {
    pub fn new() -> PendingUpdate {
        ::std::default::Default::default()
    }

    // bytes txid = 1;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // uint32 output_index = 2;


    pub fn get_output_index(&self) -> u32 {
        self.output_index
    }
    pub fn clear_output_index(&mut self) {
        self.output_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_index(&mut self, v: u32) {
        self.output_index = v;
    }
}

impl ::protobuf::Message for PendingUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.output_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if self.output_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if self.output_index != 0 {
            os.write_uint32(2, self.output_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingUpdate {
        PendingUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &PendingUpdate| { &m.txid },
                    |m: &mut PendingUpdate| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "output_index",
                    |m: &PendingUpdate| { &m.output_index },
                    |m: &mut PendingUpdate| { &mut m.output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingUpdate>(
                    "PendingUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingUpdate {
        static mut instance: ::protobuf::lazy::Lazy<PendingUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingUpdate,
        };
        unsafe {
            instance.get(PendingUpdate::new)
        }
    }
}

impl ::protobuf::Clear for PendingUpdate {
    fn clear(&mut self) {
        self.txid.clear();
        self.output_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenChannelRequest {
    // message fields
    pub node_pubkey: ::std::vec::Vec<u8>,
    pub node_pubkey_string: ::std::string::String,
    pub local_funding_amount: i64,
    pub push_sat: i64,
    pub target_conf: i32,
    pub sat_per_byte: i64,
    pub private: bool,
    pub min_htlc_msat: i64,
    pub remote_csv_delay: u32,
    pub min_confs: i32,
    pub spend_unconfirmed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenChannelRequest {
    fn default() -> &'a OpenChannelRequest {
        <OpenChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl OpenChannelRequest {
    pub fn new() -> OpenChannelRequest {
        ::std::default::Default::default()
    }

    // bytes node_pubkey = 2;


    pub fn get_node_pubkey(&self) -> &[u8] {
        &self.node_pubkey
    }
    pub fn clear_node_pubkey(&mut self) {
        self.node_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.node_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.node_pubkey
    }

    // Take field
    pub fn take_node_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.node_pubkey, ::std::vec::Vec::new())
    }

    // string node_pubkey_string = 3;


    pub fn get_node_pubkey_string(&self) -> &str {
        &self.node_pubkey_string
    }
    pub fn clear_node_pubkey_string(&mut self) {
        self.node_pubkey_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pubkey_string(&mut self, v: ::std::string::String) {
        self.node_pubkey_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pubkey_string(&mut self) -> &mut ::std::string::String {
        &mut self.node_pubkey_string
    }

    // Take field
    pub fn take_node_pubkey_string(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pubkey_string, ::std::string::String::new())
    }

    // int64 local_funding_amount = 4;


    pub fn get_local_funding_amount(&self) -> i64 {
        self.local_funding_amount
    }
    pub fn clear_local_funding_amount(&mut self) {
        self.local_funding_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_funding_amount(&mut self, v: i64) {
        self.local_funding_amount = v;
    }

    // int64 push_sat = 5;


    pub fn get_push_sat(&self) -> i64 {
        self.push_sat
    }
    pub fn clear_push_sat(&mut self) {
        self.push_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_push_sat(&mut self, v: i64) {
        self.push_sat = v;
    }

    // int32 target_conf = 6;


    pub fn get_target_conf(&self) -> i32 {
        self.target_conf
    }
    pub fn clear_target_conf(&mut self) {
        self.target_conf = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_conf(&mut self, v: i32) {
        self.target_conf = v;
    }

    // int64 sat_per_byte = 7;


    pub fn get_sat_per_byte(&self) -> i64 {
        self.sat_per_byte
    }
    pub fn clear_sat_per_byte(&mut self) {
        self.sat_per_byte = 0;
    }

    // Param is passed by value, moved
    pub fn set_sat_per_byte(&mut self, v: i64) {
        self.sat_per_byte = v;
    }

    // bool private = 8;


    pub fn get_private(&self) -> bool {
        self.private
    }
    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    // int64 min_htlc_msat = 9;


    pub fn get_min_htlc_msat(&self) -> i64 {
        self.min_htlc_msat
    }
    pub fn clear_min_htlc_msat(&mut self) {
        self.min_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc_msat(&mut self, v: i64) {
        self.min_htlc_msat = v;
    }

    // uint32 remote_csv_delay = 10;


    pub fn get_remote_csv_delay(&self) -> u32 {
        self.remote_csv_delay
    }
    pub fn clear_remote_csv_delay(&mut self) {
        self.remote_csv_delay = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_csv_delay(&mut self, v: u32) {
        self.remote_csv_delay = v;
    }

    // int32 min_confs = 11;


    pub fn get_min_confs(&self) -> i32 {
        self.min_confs
    }
    pub fn clear_min_confs(&mut self) {
        self.min_confs = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_confs(&mut self, v: i32) {
        self.min_confs = v;
    }

    // bool spend_unconfirmed = 12;


    pub fn get_spend_unconfirmed(&self) -> bool {
        self.spend_unconfirmed
    }
    pub fn clear_spend_unconfirmed(&mut self) {
        self.spend_unconfirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_spend_unconfirmed(&mut self, v: bool) {
        self.spend_unconfirmed = v;
    }
}

impl ::protobuf::Message for OpenChannelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.node_pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pubkey_string)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_funding_amount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.push_sat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_conf = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sat_per_byte = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_htlc_msat = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_csv_delay = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_confs = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spend_unconfirmed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.node_pubkey);
        }
        if !self.node_pubkey_string.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.node_pubkey_string);
        }
        if self.local_funding_amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_funding_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.push_sat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.push_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_conf != 0 {
            my_size += ::protobuf::rt::value_size(6, self.target_conf, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sat_per_byte != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sat_per_byte, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.private != false {
            my_size += 2;
        }
        if self.min_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(9, self.min_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_csv_delay != 0 {
            my_size += ::protobuf::rt::value_size(10, self.remote_csv_delay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_confs != 0 {
            my_size += ::protobuf::rt::value_size(11, self.min_confs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.spend_unconfirmed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_pubkey.is_empty() {
            os.write_bytes(2, &self.node_pubkey)?;
        }
        if !self.node_pubkey_string.is_empty() {
            os.write_string(3, &self.node_pubkey_string)?;
        }
        if self.local_funding_amount != 0 {
            os.write_int64(4, self.local_funding_amount)?;
        }
        if self.push_sat != 0 {
            os.write_int64(5, self.push_sat)?;
        }
        if self.target_conf != 0 {
            os.write_int32(6, self.target_conf)?;
        }
        if self.sat_per_byte != 0 {
            os.write_int64(7, self.sat_per_byte)?;
        }
        if self.private != false {
            os.write_bool(8, self.private)?;
        }
        if self.min_htlc_msat != 0 {
            os.write_int64(9, self.min_htlc_msat)?;
        }
        if self.remote_csv_delay != 0 {
            os.write_uint32(10, self.remote_csv_delay)?;
        }
        if self.min_confs != 0 {
            os.write_int32(11, self.min_confs)?;
        }
        if self.spend_unconfirmed != false {
            os.write_bool(12, self.spend_unconfirmed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenChannelRequest {
        OpenChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "node_pubkey",
                    |m: &OpenChannelRequest| { &m.node_pubkey },
                    |m: &mut OpenChannelRequest| { &mut m.node_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node_pubkey_string",
                    |m: &OpenChannelRequest| { &m.node_pubkey_string },
                    |m: &mut OpenChannelRequest| { &mut m.node_pubkey_string },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_funding_amount",
                    |m: &OpenChannelRequest| { &m.local_funding_amount },
                    |m: &mut OpenChannelRequest| { &mut m.local_funding_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "push_sat",
                    |m: &OpenChannelRequest| { &m.push_sat },
                    |m: &mut OpenChannelRequest| { &mut m.push_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_conf",
                    |m: &OpenChannelRequest| { &m.target_conf },
                    |m: &mut OpenChannelRequest| { &mut m.target_conf },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sat_per_byte",
                    |m: &OpenChannelRequest| { &m.sat_per_byte },
                    |m: &mut OpenChannelRequest| { &mut m.sat_per_byte },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &OpenChannelRequest| { &m.private },
                    |m: &mut OpenChannelRequest| { &mut m.private },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_htlc_msat",
                    |m: &OpenChannelRequest| { &m.min_htlc_msat },
                    |m: &mut OpenChannelRequest| { &mut m.min_htlc_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remote_csv_delay",
                    |m: &OpenChannelRequest| { &m.remote_csv_delay },
                    |m: &mut OpenChannelRequest| { &mut m.remote_csv_delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "min_confs",
                    |m: &OpenChannelRequest| { &m.min_confs },
                    |m: &mut OpenChannelRequest| { &mut m.min_confs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "spend_unconfirmed",
                    |m: &OpenChannelRequest| { &m.spend_unconfirmed },
                    |m: &mut OpenChannelRequest| { &mut m.spend_unconfirmed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenChannelRequest>(
                    "OpenChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<OpenChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenChannelRequest,
        };
        unsafe {
            instance.get(OpenChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for OpenChannelRequest {
    fn clear(&mut self) {
        self.node_pubkey.clear();
        self.node_pubkey_string.clear();
        self.local_funding_amount = 0;
        self.push_sat = 0;
        self.target_conf = 0;
        self.sat_per_byte = 0;
        self.private = false;
        self.min_htlc_msat = 0;
        self.remote_csv_delay = 0;
        self.min_confs = 0;
        self.spend_unconfirmed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenStatusUpdate {
    // message oneof groups
    pub update: ::std::option::Option<OpenStatusUpdate_oneof_update>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenStatusUpdate {
    fn default() -> &'a OpenStatusUpdate {
        <OpenStatusUpdate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OpenStatusUpdate_oneof_update {
    chan_pending(PendingUpdate),
    chan_open(ChannelOpenUpdate),
}

impl OpenStatusUpdate {
    pub fn new() -> OpenStatusUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingUpdate chan_pending = 1;


    pub fn get_chan_pending(&self) -> &PendingUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) => v,
            _ => PendingUpdate::default_instance(),
        }
    }
    pub fn clear_chan_pending(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_pending(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_pending(&mut self, v: PendingUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_pending(&mut self) -> &mut PendingUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(PendingUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_pending(&mut self) -> PendingUpdate {
        if self.has_chan_pending() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(v)) => v,
                _ => panic!(),
            }
        } else {
            PendingUpdate::new()
        }
    }

    // .lnrpc.ChannelOpenUpdate chan_open = 3;


    pub fn get_chan_open(&self) -> &ChannelOpenUpdate {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) => v,
            _ => ChannelOpenUpdate::default_instance(),
        }
    }
    pub fn clear_chan_open(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_chan_open(&self) -> bool {
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_open(&mut self, v: ChannelOpenUpdate) {
        self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_open(&mut self) -> &mut ChannelOpenUpdate {
        if let ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(_)) = self.update {
        } else {
            self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ChannelOpenUpdate::new()));
        }
        match self.update {
            ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_open(&mut self) -> ChannelOpenUpdate {
        if self.has_chan_open() {
            match self.update.take() {
                ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelOpenUpdate::new()
        }
    }
}

impl ::protobuf::Message for OpenStatusUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(OpenStatusUpdate_oneof_update::chan_pending(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpenStatusUpdate_oneof_update::chan_open(ref v)) = self.update {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_pending(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.update = ::std::option::Option::Some(OpenStatusUpdate_oneof_update::chan_open(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.update {
            match v {
                &OpenStatusUpdate_oneof_update::chan_pending(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpenStatusUpdate_oneof_update::chan_open(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenStatusUpdate {
        OpenStatusUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PendingUpdate>(
                    "chan_pending",
                    OpenStatusUpdate::has_chan_pending,
                    OpenStatusUpdate::get_chan_pending,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelOpenUpdate>(
                    "chan_open",
                    OpenStatusUpdate::has_chan_open,
                    OpenStatusUpdate::get_chan_open,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpenStatusUpdate>(
                    "OpenStatusUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpenStatusUpdate {
        static mut instance: ::protobuf::lazy::Lazy<OpenStatusUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpenStatusUpdate,
        };
        unsafe {
            instance.get(OpenStatusUpdate::new)
        }
    }
}

impl ::protobuf::Clear for OpenStatusUpdate {
    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.update = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenStatusUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenStatusUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingHTLC {
    // message fields
    pub incoming: bool,
    pub amount: i64,
    pub outpoint: ::std::string::String,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub stage: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingHTLC {
    fn default() -> &'a PendingHTLC {
        <PendingHTLC as ::protobuf::Message>::default_instance()
    }
}

impl PendingHTLC {
    pub fn new() -> PendingHTLC {
        ::std::default::Default::default()
    }

    // bool incoming = 1;


    pub fn get_incoming(&self) -> bool {
        self.incoming
    }
    pub fn clear_incoming(&mut self) {
        self.incoming = false;
    }

    // Param is passed by value, moved
    pub fn set_incoming(&mut self, v: bool) {
        self.incoming = v;
    }

    // int64 amount = 2;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }

    // string outpoint = 3;


    pub fn get_outpoint(&self) -> &str {
        &self.outpoint
    }
    pub fn clear_outpoint(&mut self) {
        self.outpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_outpoint(&mut self, v: ::std::string::String) {
        self.outpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outpoint(&mut self) -> &mut ::std::string::String {
        &mut self.outpoint
    }

    // Take field
    pub fn take_outpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.outpoint, ::std::string::String::new())
    }

    // uint32 maturity_height = 4;


    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }
    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    // int32 blocks_til_maturity = 5;


    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }
    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    // uint32 stage = 6;


    pub fn get_stage(&self) -> u32 {
        self.stage
    }
    pub fn clear_stage(&mut self) {
        self.stage = 0;
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = v;
    }
}

impl ::protobuf::Message for PendingHTLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incoming = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.outpoint)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.incoming != false {
            my_size += 2;
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.outpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.outpoint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stage != 0 {
            my_size += ::protobuf::rt::value_size(6, self.stage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.incoming != false {
            os.write_bool(1, self.incoming)?;
        }
        if self.amount != 0 {
            os.write_int64(2, self.amount)?;
        }
        if !self.outpoint.is_empty() {
            os.write_string(3, &self.outpoint)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.stage != 0 {
            os.write_uint32(6, self.stage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingHTLC {
        PendingHTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "incoming",
                    |m: &PendingHTLC| { &m.incoming },
                    |m: &mut PendingHTLC| { &mut m.incoming },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amount",
                    |m: &PendingHTLC| { &m.amount },
                    |m: &mut PendingHTLC| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "outpoint",
                    |m: &PendingHTLC| { &m.outpoint },
                    |m: &mut PendingHTLC| { &mut m.outpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maturity_height",
                    |m: &PendingHTLC| { &m.maturity_height },
                    |m: &mut PendingHTLC| { &mut m.maturity_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "blocks_til_maturity",
                    |m: &PendingHTLC| { &m.blocks_til_maturity },
                    |m: &mut PendingHTLC| { &mut m.blocks_til_maturity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stage",
                    |m: &PendingHTLC| { &m.stage },
                    |m: &mut PendingHTLC| { &mut m.stage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingHTLC>(
                    "PendingHTLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingHTLC {
        static mut instance: ::protobuf::lazy::Lazy<PendingHTLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingHTLC,
        };
        unsafe {
            instance.get(PendingHTLC::new)
        }
    }
}

impl ::protobuf::Clear for PendingHTLC {
    fn clear(&mut self) {
        self.incoming = false;
        self.amount = 0;
        self.outpoint.clear();
        self.maturity_height = 0;
        self.blocks_til_maturity = 0;
        self.stage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingHTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingHTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsRequest {
    fn default() -> &'a PendingChannelsRequest {
        <PendingChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsRequest {
    pub fn new() -> PendingChannelsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PendingChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsRequest {
        PendingChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsRequest>(
                    "PendingChannelsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsRequest {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsRequest,
        };
        unsafe {
            instance.get(PendingChannelsRequest::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse {
    // message fields
    pub total_limbo_balance: i64,
    pub pending_open_channels: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>,
    pub pending_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>,
    pub pending_force_closing_channels: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>,
    pub waiting_close_channels: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse {
    fn default() -> &'a PendingChannelsResponse {
        <PendingChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse {
    pub fn new() -> PendingChannelsResponse {
        ::std::default::Default::default()
    }

    // int64 total_limbo_balance = 1;


    pub fn get_total_limbo_balance(&self) -> i64 {
        self.total_limbo_balance
    }
    pub fn clear_total_limbo_balance(&mut self) {
        self.total_limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_limbo_balance(&mut self, v: i64) {
        self.total_limbo_balance = v;
    }

    // repeated .lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;


    pub fn get_pending_open_channels(&self) -> &[PendingChannelsResponse_PendingOpenChannel] {
        &self.pending_open_channels
    }
    pub fn clear_pending_open_channels(&mut self) {
        self.pending_open_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_open_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel>) {
        self.pending_open_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_open_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        &mut self.pending_open_channels
    }

    // Take field
    pub fn take_pending_open_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_PendingOpenChannel> {
        ::std::mem::replace(&mut self.pending_open_channels, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3;


    pub fn get_pending_closing_channels(&self) -> &[PendingChannelsResponse_ClosedChannel] {
        &self.pending_closing_channels
    }
    pub fn clear_pending_closing_channels(&mut self) {
        self.pending_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel>) {
        self.pending_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        &mut self.pending_closing_channels
    }

    // Take field
    pub fn take_pending_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ClosedChannel> {
        ::std::mem::replace(&mut self.pending_closing_channels, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;


    pub fn get_pending_force_closing_channels(&self) -> &[PendingChannelsResponse_ForceClosedChannel] {
        &self.pending_force_closing_channels
    }
    pub fn clear_pending_force_closing_channels(&mut self) {
        self.pending_force_closing_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_force_closing_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel>) {
        self.pending_force_closing_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_force_closing_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        &mut self.pending_force_closing_channels
    }

    // Take field
    pub fn take_pending_force_closing_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_ForceClosedChannel> {
        ::std::mem::replace(&mut self.pending_force_closing_channels, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;


    pub fn get_waiting_close_channels(&self) -> &[PendingChannelsResponse_WaitingCloseChannel] {
        &self.waiting_close_channels
    }
    pub fn clear_waiting_close_channels(&mut self) {
        self.waiting_close_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_waiting_close_channels(&mut self, v: ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel>) {
        self.waiting_close_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_waiting_close_channels(&mut self) -> &mut ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        &mut self.waiting_close_channels
    }

    // Take field
    pub fn take_waiting_close_channels(&mut self) -> ::protobuf::RepeatedField<PendingChannelsResponse_WaitingCloseChannel> {
        ::std::mem::replace(&mut self.waiting_close_channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PendingChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.pending_open_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_force_closing_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.waiting_close_channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_limbo_balance = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_open_channels)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_closing_channels)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_force_closing_channels)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.waiting_close_channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_open_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.pending_force_closing_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.waiting_close_channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_limbo_balance != 0 {
            os.write_int64(1, self.total_limbo_balance)?;
        }
        for v in &self.pending_open_channels {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_closing_channels {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.pending_force_closing_channels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.waiting_close_channels {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse {
        PendingChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_limbo_balance",
                    |m: &PendingChannelsResponse| { &m.total_limbo_balance },
                    |m: &mut PendingChannelsResponse| { &mut m.total_limbo_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingOpenChannel>>(
                    "pending_open_channels",
                    |m: &PendingChannelsResponse| { &m.pending_open_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_open_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ClosedChannel>>(
                    "pending_closing_channels",
                    |m: &PendingChannelsResponse| { &m.pending_closing_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_closing_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_ForceClosedChannel>>(
                    "pending_force_closing_channels",
                    |m: &PendingChannelsResponse| { &m.pending_force_closing_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.pending_force_closing_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_WaitingCloseChannel>>(
                    "waiting_close_channels",
                    |m: &PendingChannelsResponse| { &m.waiting_close_channels },
                    |m: &mut PendingChannelsResponse| { &mut m.waiting_close_channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse>(
                    "PendingChannelsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse,
        };
        unsafe {
            instance.get(PendingChannelsResponse::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse {
    fn clear(&mut self) {
        self.total_limbo_balance = 0;
        self.pending_open_channels.clear();
        self.pending_closing_channels.clear();
        self.pending_force_closing_channels.clear();
        self.waiting_close_channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_PendingChannel {
    // message fields
    pub remote_node_pub: ::std::string::String,
    pub channel_point: ::std::string::String,
    pub capacity: i64,
    pub local_balance: i64,
    pub remote_balance: i64,
    pub local_chan_reserve_sat: i64,
    pub remote_chan_reserve_sat: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_PendingChannel {
    fn default() -> &'a PendingChannelsResponse_PendingChannel {
        <PendingChannelsResponse_PendingChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_PendingChannel {
    pub fn new() -> PendingChannelsResponse_PendingChannel {
        ::std::default::Default::default()
    }

    // string remote_node_pub = 1;


    pub fn get_remote_node_pub(&self) -> &str {
        &self.remote_node_pub
    }
    pub fn clear_remote_node_pub(&mut self) {
        self.remote_node_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_node_pub(&mut self, v: ::std::string::String) {
        self.remote_node_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_node_pub(&mut self) -> &mut ::std::string::String {
        &mut self.remote_node_pub
    }

    // Take field
    pub fn take_remote_node_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_node_pub, ::std::string::String::new())
    }

    // string channel_point = 2;


    pub fn get_channel_point(&self) -> &str {
        &self.channel_point
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ::std::string::String) {
        self.channel_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ::std::string::String {
        &mut self.channel_point
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_point, ::std::string::String::new())
    }

    // int64 capacity = 3;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // int64 local_balance = 4;


    pub fn get_local_balance(&self) -> i64 {
        self.local_balance
    }
    pub fn clear_local_balance(&mut self) {
        self.local_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_balance(&mut self, v: i64) {
        self.local_balance = v;
    }

    // int64 remote_balance = 5;


    pub fn get_remote_balance(&self) -> i64 {
        self.remote_balance
    }
    pub fn clear_remote_balance(&mut self) {
        self.remote_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_balance(&mut self, v: i64) {
        self.remote_balance = v;
    }

    // int64 local_chan_reserve_sat = 6;


    pub fn get_local_chan_reserve_sat(&self) -> i64 {
        self.local_chan_reserve_sat
    }
    pub fn clear_local_chan_reserve_sat(&mut self) {
        self.local_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_chan_reserve_sat(&mut self, v: i64) {
        self.local_chan_reserve_sat = v;
    }

    // int64 remote_chan_reserve_sat = 7;


    pub fn get_remote_chan_reserve_sat(&self) -> i64 {
        self.remote_chan_reserve_sat
    }
    pub fn clear_remote_chan_reserve_sat(&mut self) {
        self.remote_chan_reserve_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_chan_reserve_sat(&mut self, v: i64) {
        self.remote_chan_reserve_sat = v;
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingChannel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_node_pub)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_balance = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_balance = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.local_chan_reserve_sat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remote_chan_reserve_sat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.remote_node_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.remote_node_pub);
        }
        if !self.channel_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_point);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_balance != 0 {
            my_size += ::protobuf::rt::value_size(4, self.local_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_balance != 0 {
            my_size += ::protobuf::rt::value_size(5, self.remote_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.local_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.remote_chan_reserve_sat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.remote_chan_reserve_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.remote_node_pub.is_empty() {
            os.write_string(1, &self.remote_node_pub)?;
        }
        if !self.channel_point.is_empty() {
            os.write_string(2, &self.channel_point)?;
        }
        if self.capacity != 0 {
            os.write_int64(3, self.capacity)?;
        }
        if self.local_balance != 0 {
            os.write_int64(4, self.local_balance)?;
        }
        if self.remote_balance != 0 {
            os.write_int64(5, self.remote_balance)?;
        }
        if self.local_chan_reserve_sat != 0 {
            os.write_int64(6, self.local_chan_reserve_sat)?;
        }
        if self.remote_chan_reserve_sat != 0 {
            os.write_int64(7, self.remote_chan_reserve_sat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingChannel {
        PendingChannelsResponse_PendingChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_node_pub",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.remote_node_pub },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_node_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channel_point",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.channel_point },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.channel_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.capacity },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_balance",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.local_balance },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.local_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remote_balance",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.remote_balance },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "local_chan_reserve_sat",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.local_chan_reserve_sat },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.local_chan_reserve_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "remote_chan_reserve_sat",
                    |m: &PendingChannelsResponse_PendingChannel| { &m.remote_chan_reserve_sat },
                    |m: &mut PendingChannelsResponse_PendingChannel| { &mut m.remote_chan_reserve_sat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_PendingChannel>(
                    "PendingChannelsResponse_PendingChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_PendingChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_PendingChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_PendingChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingChannel {
    fn clear(&mut self) {
        self.remote_node_pub.clear();
        self.channel_point.clear();
        self.capacity = 0;
        self.local_balance = 0;
        self.remote_balance = 0;
        self.local_chan_reserve_sat = 0;
        self.remote_chan_reserve_sat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_PendingOpenChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub confirmation_height: u32,
    pub commit_fee: i64,
    pub commit_weight: i64,
    pub fee_per_kw: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_PendingOpenChannel {
    fn default() -> &'a PendingChannelsResponse_PendingOpenChannel {
        <PendingChannelsResponse_PendingOpenChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_PendingOpenChannel {
    pub fn new() -> PendingChannelsResponse_PendingOpenChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // uint32 confirmation_height = 2;


    pub fn get_confirmation_height(&self) -> u32 {
        self.confirmation_height
    }
    pub fn clear_confirmation_height(&mut self) {
        self.confirmation_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmation_height(&mut self, v: u32) {
        self.confirmation_height = v;
    }

    // int64 commit_fee = 4;


    pub fn get_commit_fee(&self) -> i64 {
        self.commit_fee
    }
    pub fn clear_commit_fee(&mut self) {
        self.commit_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_fee(&mut self, v: i64) {
        self.commit_fee = v;
    }

    // int64 commit_weight = 5;


    pub fn get_commit_weight(&self) -> i64 {
        self.commit_weight
    }
    pub fn clear_commit_weight(&mut self) {
        self.commit_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_weight(&mut self, v: i64) {
        self.commit_weight = v;
    }

    // int64 fee_per_kw = 6;


    pub fn get_fee_per_kw(&self) -> i64 {
        self.fee_per_kw
    }
    pub fn clear_fee_per_kw(&mut self) {
        self.fee_per_kw = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_kw(&mut self, v: i64) {
        self.fee_per_kw = v;
    }
}

impl ::protobuf::Message for PendingChannelsResponse_PendingOpenChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.confirmation_height = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.commit_weight = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_kw = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.confirmation_height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.confirmation_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.commit_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.commit_weight != 0 {
            my_size += ::protobuf::rt::value_size(5, self.commit_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_kw != 0 {
            my_size += ::protobuf::rt::value_size(6, self.fee_per_kw, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.confirmation_height != 0 {
            os.write_uint32(2, self.confirmation_height)?;
        }
        if self.commit_fee != 0 {
            os.write_int64(4, self.commit_fee)?;
        }
        if self.commit_weight != 0 {
            os.write_int64(5, self.commit_weight)?;
        }
        if self.fee_per_kw != 0 {
            os.write_int64(6, self.fee_per_kw)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_PendingOpenChannel {
        PendingChannelsResponse_PendingOpenChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "confirmation_height",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.confirmation_height },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.confirmation_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_fee",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_fee },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "commit_weight",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.commit_weight },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.commit_weight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_per_kw",
                    |m: &PendingChannelsResponse_PendingOpenChannel| { &m.fee_per_kw },
                    |m: &mut PendingChannelsResponse_PendingOpenChannel| { &mut m.fee_per_kw },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_PendingOpenChannel>(
                    "PendingChannelsResponse_PendingOpenChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_PendingOpenChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_PendingOpenChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_PendingOpenChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_PendingOpenChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_PendingOpenChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.confirmation_height = 0;
        self.commit_fee = 0;
        self.commit_weight = 0;
        self.fee_per_kw = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_PendingOpenChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_PendingOpenChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_WaitingCloseChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub limbo_balance: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_WaitingCloseChannel {
    fn default() -> &'a PendingChannelsResponse_WaitingCloseChannel {
        <PendingChannelsResponse_WaitingCloseChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_WaitingCloseChannel {
    pub fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // int64 limbo_balance = 2;


    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }
    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }
}

impl ::protobuf::Message for PendingChannelsResponse_WaitingCloseChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(2, self.limbo_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_WaitingCloseChannel {
        PendingChannelsResponse_WaitingCloseChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limbo_balance",
                    |m: &PendingChannelsResponse_WaitingCloseChannel| { &m.limbo_balance },
                    |m: &mut PendingChannelsResponse_WaitingCloseChannel| { &mut m.limbo_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_WaitingCloseChannel>(
                    "PendingChannelsResponse_WaitingCloseChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_WaitingCloseChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_WaitingCloseChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_WaitingCloseChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_WaitingCloseChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_WaitingCloseChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.limbo_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_WaitingCloseChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_WaitingCloseChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_ClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_ClosedChannel {
    fn default() -> &'a PendingChannelsResponse_ClosedChannel {
        <PendingChannelsResponse_ClosedChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_ClosedChannel {
    pub fn new() -> PendingChannelsResponse_ClosedChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // string closing_txid = 2;


    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }
    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ClosedChannel {
        PendingChannelsResponse_ClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_ClosedChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_txid",
                    |m: &PendingChannelsResponse_ClosedChannel| { &m.closing_txid },
                    |m: &mut PendingChannelsResponse_ClosedChannel| { &mut m.closing_txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_ClosedChannel>(
                    "PendingChannelsResponse_ClosedChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_ClosedChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_ClosedChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_ClosedChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_ClosedChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ClosedChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.closing_txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PendingChannelsResponse_ForceClosedChannel {
    // message fields
    pub channel: ::protobuf::SingularPtrField<PendingChannelsResponse_PendingChannel>,
    pub closing_txid: ::std::string::String,
    pub limbo_balance: i64,
    pub maturity_height: u32,
    pub blocks_til_maturity: i32,
    pub recovered_balance: i64,
    pub pending_htlcs: ::protobuf::RepeatedField<PendingHTLC>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PendingChannelsResponse_ForceClosedChannel {
    fn default() -> &'a PendingChannelsResponse_ForceClosedChannel {
        <PendingChannelsResponse_ForceClosedChannel as ::protobuf::Message>::default_instance()
    }
}

impl PendingChannelsResponse_ForceClosedChannel {
    pub fn new() -> PendingChannelsResponse_ForceClosedChannel {
        ::std::default::Default::default()
    }

    // .lnrpc.PendingChannelsResponse.PendingChannel channel = 1;


    pub fn get_channel(&self) -> &PendingChannelsResponse_PendingChannel {
        self.channel.as_ref().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: PendingChannelsResponse_PendingChannel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut PendingChannelsResponse_PendingChannel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> PendingChannelsResponse_PendingChannel {
        self.channel.take().unwrap_or_else(|| PendingChannelsResponse_PendingChannel::new())
    }

    // string closing_txid = 2;


    pub fn get_closing_txid(&self) -> &str {
        &self.closing_txid
    }
    pub fn clear_closing_txid(&mut self) {
        self.closing_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_closing_txid(&mut self, v: ::std::string::String) {
        self.closing_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closing_txid(&mut self) -> &mut ::std::string::String {
        &mut self.closing_txid
    }

    // Take field
    pub fn take_closing_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.closing_txid, ::std::string::String::new())
    }

    // int64 limbo_balance = 3;


    pub fn get_limbo_balance(&self) -> i64 {
        self.limbo_balance
    }
    pub fn clear_limbo_balance(&mut self) {
        self.limbo_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_limbo_balance(&mut self, v: i64) {
        self.limbo_balance = v;
    }

    // uint32 maturity_height = 4;


    pub fn get_maturity_height(&self) -> u32 {
        self.maturity_height
    }
    pub fn clear_maturity_height(&mut self) {
        self.maturity_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_height(&mut self, v: u32) {
        self.maturity_height = v;
    }

    // int32 blocks_til_maturity = 5;


    pub fn get_blocks_til_maturity(&self) -> i32 {
        self.blocks_til_maturity
    }
    pub fn clear_blocks_til_maturity(&mut self) {
        self.blocks_til_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocks_til_maturity(&mut self, v: i32) {
        self.blocks_til_maturity = v;
    }

    // int64 recovered_balance = 6;


    pub fn get_recovered_balance(&self) -> i64 {
        self.recovered_balance
    }
    pub fn clear_recovered_balance(&mut self) {
        self.recovered_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_recovered_balance(&mut self, v: i64) {
        self.recovered_balance = v;
    }

    // repeated .lnrpc.PendingHTLC pending_htlcs = 8;


    pub fn get_pending_htlcs(&self) -> &[PendingHTLC] {
        &self.pending_htlcs
    }
    pub fn clear_pending_htlcs(&mut self) {
        self.pending_htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_htlcs(&mut self, v: ::protobuf::RepeatedField<PendingHTLC>) {
        self.pending_htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<PendingHTLC> {
        &mut self.pending_htlcs
    }

    // Take field
    pub fn take_pending_htlcs(&mut self) -> ::protobuf::RepeatedField<PendingHTLC> {
        ::std::mem::replace(&mut self.pending_htlcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PendingChannelsResponse_ForceClosedChannel {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.closing_txid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limbo_balance = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maturity_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blocks_til_maturity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.recovered_balance = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_htlcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.closing_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.closing_txid);
        }
        if self.limbo_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limbo_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maturity_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maturity_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocks_til_maturity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blocks_til_maturity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.recovered_balance != 0 {
            my_size += ::protobuf::rt::value_size(6, self.recovered_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_htlcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.closing_txid.is_empty() {
            os.write_string(2, &self.closing_txid)?;
        }
        if self.limbo_balance != 0 {
            os.write_int64(3, self.limbo_balance)?;
        }
        if self.maturity_height != 0 {
            os.write_uint32(4, self.maturity_height)?;
        }
        if self.blocks_til_maturity != 0 {
            os.write_int32(5, self.blocks_til_maturity)?;
        }
        if self.recovered_balance != 0 {
            os.write_int64(6, self.recovered_balance)?;
        }
        for v in &self.pending_htlcs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PendingChannelsResponse_ForceClosedChannel {
        PendingChannelsResponse_ForceClosedChannel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingChannelsResponse_PendingChannel>>(
                    "channel",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.channel },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.channel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "closing_txid",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.closing_txid },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.closing_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limbo_balance",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.limbo_balance },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.limbo_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maturity_height",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.maturity_height },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.maturity_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "blocks_til_maturity",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.blocks_til_maturity },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.blocks_til_maturity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "recovered_balance",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.recovered_balance },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.recovered_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PendingHTLC>>(
                    "pending_htlcs",
                    |m: &PendingChannelsResponse_ForceClosedChannel| { &m.pending_htlcs },
                    |m: &mut PendingChannelsResponse_ForceClosedChannel| { &mut m.pending_htlcs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PendingChannelsResponse_ForceClosedChannel>(
                    "PendingChannelsResponse_ForceClosedChannel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PendingChannelsResponse_ForceClosedChannel {
        static mut instance: ::protobuf::lazy::Lazy<PendingChannelsResponse_ForceClosedChannel> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PendingChannelsResponse_ForceClosedChannel,
        };
        unsafe {
            instance.get(PendingChannelsResponse_ForceClosedChannel::new)
        }
    }
}

impl ::protobuf::Clear for PendingChannelsResponse_ForceClosedChannel {
    fn clear(&mut self) {
        self.channel.clear();
        self.closing_txid.clear();
        self.limbo_balance = 0;
        self.maturity_height = 0;
        self.blocks_til_maturity = 0;
        self.recovered_balance = 0;
        self.pending_htlcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PendingChannelsResponse_ForceClosedChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PendingChannelsResponse_ForceClosedChannel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelEventSubscription {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEventSubscription {
    fn default() -> &'a ChannelEventSubscription {
        <ChannelEventSubscription as ::protobuf::Message>::default_instance()
    }
}

impl ChannelEventSubscription {
    pub fn new() -> ChannelEventSubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelEventSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEventSubscription {
        ChannelEventSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ChannelEventSubscription>(
                    "ChannelEventSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelEventSubscription {
        static mut instance: ::protobuf::lazy::Lazy<ChannelEventSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelEventSubscription,
        };
        unsafe {
            instance.get(ChannelEventSubscription::new)
        }
    }
}

impl ::protobuf::Clear for ChannelEventSubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEventSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEventSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelEventUpdate {
    // message fields
    pub field_type: ChannelEventUpdate_UpdateType,
    // message oneof groups
    pub channel: ::std::option::Option<ChannelEventUpdate_oneof_channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEventUpdate {
    fn default() -> &'a ChannelEventUpdate {
        <ChannelEventUpdate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ChannelEventUpdate_oneof_channel {
    open_channel(Channel),
    closed_channel(ChannelCloseSummary),
    active_channel(ChannelPoint),
    inactive_channel(ChannelPoint),
}

impl ChannelEventUpdate {
    pub fn new() -> ChannelEventUpdate {
        ::std::default::Default::default()
    }

    // .lnrpc.Channel open_channel = 1;


    pub fn get_open_channel(&self) -> &Channel {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(ref v)) => v,
            _ => Channel::default_instance(),
        }
    }
    pub fn clear_open_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_open_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_open_channel(&mut self, v: Channel) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_open_channel(&mut self) -> &mut Channel {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(Channel::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_open_channel(&mut self) -> Channel {
        if self.has_open_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            Channel::new()
        }
    }

    // .lnrpc.ChannelCloseSummary closed_channel = 2;


    pub fn get_closed_channel(&self) -> &ChannelCloseSummary {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(ref v)) => v,
            _ => ChannelCloseSummary::default_instance(),
        }
    }
    pub fn clear_closed_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_closed_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_closed_channel(&mut self, v: ChannelCloseSummary) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_closed_channel(&mut self) -> &mut ChannelCloseSummary {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(ChannelCloseSummary::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_closed_channel(&mut self) -> ChannelCloseSummary {
        if self.has_closed_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelCloseSummary::new()
        }
    }

    // .lnrpc.ChannelPoint active_channel = 3;


    pub fn get_active_channel(&self) -> &ChannelPoint {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(ref v)) => v,
            _ => ChannelPoint::default_instance(),
        }
    }
    pub fn clear_active_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_active_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_active_channel(&mut self, v: ChannelPoint) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_active_channel(&mut self) -> &mut ChannelPoint {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(ChannelPoint::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_active_channel(&mut self) -> ChannelPoint {
        if self.has_active_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPoint::new()
        }
    }

    // .lnrpc.ChannelPoint inactive_channel = 4;


    pub fn get_inactive_channel(&self) -> &ChannelPoint {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(ref v)) => v,
            _ => ChannelPoint::default_instance(),
        }
    }
    pub fn clear_inactive_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_inactive_channel(&self) -> bool {
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_inactive_channel(&mut self, v: ChannelPoint) {
        self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_inactive_channel(&mut self) -> &mut ChannelPoint {
        if let ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(_)) = self.channel {
        } else {
            self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(ChannelPoint::new()));
        }
        match self.channel {
            ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_inactive_channel(&mut self) -> ChannelPoint {
        if self.has_inactive_channel() {
            match self.channel.take() {
                ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPoint::new()
        }
    }

    // .lnrpc.ChannelEventUpdate.UpdateType type = 5;


    pub fn get_field_type(&self) -> ChannelEventUpdate_UpdateType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ChannelEventUpdate_UpdateType::OPEN_CHANNEL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ChannelEventUpdate_UpdateType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for ChannelEventUpdate {
    fn is_initialized(&self) -> bool {
        if let Some(ChannelEventUpdate_oneof_channel::open_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelEventUpdate_oneof_channel::closed_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelEventUpdate_oneof_channel::active_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ChannelEventUpdate_oneof_channel::inactive_channel(ref v)) = self.channel {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::open_channel(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::closed_channel(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::active_channel(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.channel = ::std::option::Option::Some(ChannelEventUpdate_oneof_channel::inactive_channel(is.read_message()?));
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ChannelEventUpdate_UpdateType::OPEN_CHANNEL {
            my_size += ::protobuf::rt::enum_size(5, self.field_type);
        }
        if let ::std::option::Option::Some(ref v) = self.channel {
            match v {
                &ChannelEventUpdate_oneof_channel::open_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelEventUpdate_oneof_channel::closed_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelEventUpdate_oneof_channel::active_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ChannelEventUpdate_oneof_channel::inactive_channel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ChannelEventUpdate_UpdateType::OPEN_CHANNEL {
            os.write_enum(5, self.field_type.value())?;
        }
        if let ::std::option::Option::Some(ref v) = self.channel {
            match v {
                &ChannelEventUpdate_oneof_channel::open_channel(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelEventUpdate_oneof_channel::closed_channel(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelEventUpdate_oneof_channel::active_channel(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ChannelEventUpdate_oneof_channel::inactive_channel(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEventUpdate {
        ChannelEventUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Channel>(
                    "open_channel",
                    ChannelEventUpdate::has_open_channel,
                    ChannelEventUpdate::get_open_channel,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelCloseSummary>(
                    "closed_channel",
                    ChannelEventUpdate::has_closed_channel,
                    ChannelEventUpdate::get_closed_channel,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPoint>(
                    "active_channel",
                    ChannelEventUpdate::has_active_channel,
                    ChannelEventUpdate::get_active_channel,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPoint>(
                    "inactive_channel",
                    ChannelEventUpdate::has_inactive_channel,
                    ChannelEventUpdate::get_inactive_channel,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelEventUpdate_UpdateType>>(
                    "type",
                    |m: &ChannelEventUpdate| { &m.field_type },
                    |m: &mut ChannelEventUpdate| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelEventUpdate>(
                    "ChannelEventUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelEventUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelEventUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelEventUpdate,
        };
        unsafe {
            instance.get(ChannelEventUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelEventUpdate {
    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.field_type = ChannelEventUpdate_UpdateType::OPEN_CHANNEL;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEventUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEventUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChannelEventUpdate_UpdateType {
    OPEN_CHANNEL = 0,
    CLOSED_CHANNEL = 1,
    ACTIVE_CHANNEL = 2,
    INACTIVE_CHANNEL = 3,
}

impl ::protobuf::ProtobufEnum for ChannelEventUpdate_UpdateType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelEventUpdate_UpdateType> {
        match value {
            0 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::OPEN_CHANNEL),
            1 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::CLOSED_CHANNEL),
            2 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::ACTIVE_CHANNEL),
            3 => ::std::option::Option::Some(ChannelEventUpdate_UpdateType::INACTIVE_CHANNEL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelEventUpdate_UpdateType] = &[
            ChannelEventUpdate_UpdateType::OPEN_CHANNEL,
            ChannelEventUpdate_UpdateType::CLOSED_CHANNEL,
            ChannelEventUpdate_UpdateType::ACTIVE_CHANNEL,
            ChannelEventUpdate_UpdateType::INACTIVE_CHANNEL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChannelEventUpdate_UpdateType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChannelEventUpdate_UpdateType {
}

impl ::std::default::Default for ChannelEventUpdate_UpdateType {
    fn default() -> Self {
        ChannelEventUpdate_UpdateType::OPEN_CHANNEL
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEventUpdate_UpdateType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WalletBalanceRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletBalanceRequest {
    fn default() -> &'a WalletBalanceRequest {
        <WalletBalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl WalletBalanceRequest {
    pub fn new() -> WalletBalanceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WalletBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletBalanceRequest {
        WalletBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WalletBalanceRequest>(
                    "WalletBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WalletBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<WalletBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WalletBalanceRequest,
        };
        unsafe {
            instance.get(WalletBalanceRequest::new)
        }
    }
}

impl ::protobuf::Clear for WalletBalanceRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WalletBalanceResponse {
    // message fields
    pub total_balance: i64,
    pub confirmed_balance: i64,
    pub unconfirmed_balance: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletBalanceResponse {
    fn default() -> &'a WalletBalanceResponse {
        <WalletBalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl WalletBalanceResponse {
    pub fn new() -> WalletBalanceResponse {
        ::std::default::Default::default()
    }

    // int64 total_balance = 1;


    pub fn get_total_balance(&self) -> i64 {
        self.total_balance
    }
    pub fn clear_total_balance(&mut self) {
        self.total_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_balance(&mut self, v: i64) {
        self.total_balance = v;
    }

    // int64 confirmed_balance = 2;


    pub fn get_confirmed_balance(&self) -> i64 {
        self.confirmed_balance
    }
    pub fn clear_confirmed_balance(&mut self) {
        self.confirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_confirmed_balance(&mut self, v: i64) {
        self.confirmed_balance = v;
    }

    // int64 unconfirmed_balance = 3;


    pub fn get_unconfirmed_balance(&self) -> i64 {
        self.unconfirmed_balance
    }
    pub fn clear_unconfirmed_balance(&mut self) {
        self.unconfirmed_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_unconfirmed_balance(&mut self, v: i64) {
        self.unconfirmed_balance = v;
    }
}

impl ::protobuf::Message for WalletBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.confirmed_balance = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unconfirmed_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.confirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.confirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unconfirmed_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.unconfirmed_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_balance != 0 {
            os.write_int64(1, self.total_balance)?;
        }
        if self.confirmed_balance != 0 {
            os.write_int64(2, self.confirmed_balance)?;
        }
        if self.unconfirmed_balance != 0 {
            os.write_int64(3, self.unconfirmed_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletBalanceResponse {
        WalletBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_balance",
                    |m: &WalletBalanceResponse| { &m.total_balance },
                    |m: &mut WalletBalanceResponse| { &mut m.total_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "confirmed_balance",
                    |m: &WalletBalanceResponse| { &m.confirmed_balance },
                    |m: &mut WalletBalanceResponse| { &mut m.confirmed_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unconfirmed_balance",
                    |m: &WalletBalanceResponse| { &m.unconfirmed_balance },
                    |m: &mut WalletBalanceResponse| { &mut m.unconfirmed_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WalletBalanceResponse>(
                    "WalletBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WalletBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<WalletBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WalletBalanceResponse,
        };
        unsafe {
            instance.get(WalletBalanceResponse::new)
        }
    }
}

impl ::protobuf::Clear for WalletBalanceResponse {
    fn clear(&mut self) {
        self.total_balance = 0;
        self.confirmed_balance = 0;
        self.unconfirmed_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelBalanceRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBalanceRequest {
    fn default() -> &'a ChannelBalanceRequest {
        <ChannelBalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBalanceRequest {
    pub fn new() -> ChannelBalanceRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBalanceRequest {
        ChannelBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ChannelBalanceRequest>(
                    "ChannelBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChannelBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelBalanceRequest,
        };
        unsafe {
            instance.get(ChannelBalanceRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChannelBalanceRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelBalanceResponse {
    // message fields
    pub balance: i64,
    pub pending_open_balance: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBalanceResponse {
    fn default() -> &'a ChannelBalanceResponse {
        <ChannelBalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBalanceResponse {
    pub fn new() -> ChannelBalanceResponse {
        ::std::default::Default::default()
    }

    // int64 balance = 1;


    pub fn get_balance(&self) -> i64 {
        self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = v;
    }

    // int64 pending_open_balance = 2;


    pub fn get_pending_open_balance(&self) -> i64 {
        self.pending_open_balance
    }
    pub fn clear_pending_open_balance(&mut self) {
        self.pending_open_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_pending_open_balance(&mut self, v: i64) {
        self.pending_open_balance = v;
    }
}

impl ::protobuf::Message for ChannelBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.pending_open_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pending_open_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pending_open_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.balance != 0 {
            os.write_int64(1, self.balance)?;
        }
        if self.pending_open_balance != 0 {
            os.write_int64(2, self.pending_open_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBalanceResponse {
        ChannelBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "balance",
                    |m: &ChannelBalanceResponse| { &m.balance },
                    |m: &mut ChannelBalanceResponse| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "pending_open_balance",
                    |m: &ChannelBalanceResponse| { &m.pending_open_balance },
                    |m: &mut ChannelBalanceResponse| { &mut m.pending_open_balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelBalanceResponse>(
                    "ChannelBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<ChannelBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelBalanceResponse,
        };
        unsafe {
            instance.get(ChannelBalanceResponse::new)
        }
    }
}

impl ::protobuf::Clear for ChannelBalanceResponse {
    fn clear(&mut self) {
        self.balance = 0;
        self.pending_open_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRoutesRequest {
    // message fields
    pub pub_key: ::std::string::String,
    pub amt: i64,
    pub final_cltv_delta: i32,
    pub fee_limit: ::protobuf::SingularPtrField<FeeLimit>,
    pub ignored_nodes: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub ignored_edges: ::protobuf::RepeatedField<EdgeLocator>,
    pub source_pub_key: ::std::string::String,
    pub use_mission_control: bool,
    pub ignored_pairs: ::protobuf::RepeatedField<NodePair>,
    pub dest_tlv: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRoutesRequest {
    fn default() -> &'a QueryRoutesRequest {
        <QueryRoutesRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryRoutesRequest {
    pub fn new() -> QueryRoutesRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // int64 amt = 2;


    pub fn get_amt(&self) -> i64 {
        self.amt
    }
    pub fn clear_amt(&mut self) {
        self.amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt(&mut self, v: i64) {
        self.amt = v;
    }

    // int32 final_cltv_delta = 4;


    pub fn get_final_cltv_delta(&self) -> i32 {
        self.final_cltv_delta
    }
    pub fn clear_final_cltv_delta(&mut self) {
        self.final_cltv_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_final_cltv_delta(&mut self, v: i32) {
        self.final_cltv_delta = v;
    }

    // .lnrpc.FeeLimit fee_limit = 5;


    pub fn get_fee_limit(&self) -> &FeeLimit {
        self.fee_limit.as_ref().unwrap_or_else(|| FeeLimit::default_instance())
    }
    pub fn clear_fee_limit(&mut self) {
        self.fee_limit.clear();
    }

    pub fn has_fee_limit(&self) -> bool {
        self.fee_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: FeeLimit) {
        self.fee_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fee_limit(&mut self) -> &mut FeeLimit {
        if self.fee_limit.is_none() {
            self.fee_limit.set_default();
        }
        self.fee_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_fee_limit(&mut self) -> FeeLimit {
        self.fee_limit.take().unwrap_or_else(|| FeeLimit::new())
    }

    // repeated bytes ignored_nodes = 6;


    pub fn get_ignored_nodes(&self) -> &[::std::vec::Vec<u8>] {
        &self.ignored_nodes
    }
    pub fn clear_ignored_nodes(&mut self) {
        self.ignored_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignored_nodes(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.ignored_nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignored_nodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.ignored_nodes
    }

    // Take field
    pub fn take_ignored_nodes(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.ignored_nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.EdgeLocator ignored_edges = 7;


    pub fn get_ignored_edges(&self) -> &[EdgeLocator] {
        &self.ignored_edges
    }
    pub fn clear_ignored_edges(&mut self) {
        self.ignored_edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignored_edges(&mut self, v: ::protobuf::RepeatedField<EdgeLocator>) {
        self.ignored_edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignored_edges(&mut self) -> &mut ::protobuf::RepeatedField<EdgeLocator> {
        &mut self.ignored_edges
    }

    // Take field
    pub fn take_ignored_edges(&mut self) -> ::protobuf::RepeatedField<EdgeLocator> {
        ::std::mem::replace(&mut self.ignored_edges, ::protobuf::RepeatedField::new())
    }

    // string source_pub_key = 8;


    pub fn get_source_pub_key(&self) -> &str {
        &self.source_pub_key
    }
    pub fn clear_source_pub_key(&mut self) {
        self.source_pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_pub_key(&mut self, v: ::std::string::String) {
        self.source_pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.source_pub_key
    }

    // Take field
    pub fn take_source_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_pub_key, ::std::string::String::new())
    }

    // bool use_mission_control = 9;


    pub fn get_use_mission_control(&self) -> bool {
        self.use_mission_control
    }
    pub fn clear_use_mission_control(&mut self) {
        self.use_mission_control = false;
    }

    // Param is passed by value, moved
    pub fn set_use_mission_control(&mut self, v: bool) {
        self.use_mission_control = v;
    }

    // repeated .lnrpc.NodePair ignored_pairs = 10;


    pub fn get_ignored_pairs(&self) -> &[NodePair] {
        &self.ignored_pairs
    }
    pub fn clear_ignored_pairs(&mut self) {
        self.ignored_pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_ignored_pairs(&mut self, v: ::protobuf::RepeatedField<NodePair>) {
        self.ignored_pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ignored_pairs(&mut self) -> &mut ::protobuf::RepeatedField<NodePair> {
        &mut self.ignored_pairs
    }

    // Take field
    pub fn take_ignored_pairs(&mut self) -> ::protobuf::RepeatedField<NodePair> {
        ::std::mem::replace(&mut self.ignored_pairs, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.QueryRoutesRequest.DestTlvEntry dest_tlv = 11;


    pub fn get_dest_tlv(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.dest_tlv
    }
    pub fn clear_dest_tlv(&mut self) {
        self.dest_tlv.clear();
    }

    // Param is passed by value, moved
    pub fn set_dest_tlv(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.dest_tlv = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dest_tlv(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.dest_tlv
    }

    // Take field
    pub fn take_dest_tlv(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.dest_tlv, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for QueryRoutesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fee_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ignored_edges {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ignored_pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.final_cltv_delta = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fee_limit)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.ignored_nodes)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ignored_edges)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_pub_key)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_mission_control = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ignored_pairs)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.dest_tlv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if self.amt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.amt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.final_cltv_delta != 0 {
            my_size += ::protobuf::rt::value_size(4, self.final_cltv_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ignored_nodes {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        for value in &self.ignored_edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.source_pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.source_pub_key);
        }
        if self.use_mission_control != false {
            my_size += 2;
        }
        for value in &self.ignored_pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_tlv);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if self.amt != 0 {
            os.write_int64(2, self.amt)?;
        }
        if self.final_cltv_delta != 0 {
            os.write_int32(4, self.final_cltv_delta)?;
        }
        if let Some(ref v) = self.fee_limit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ignored_nodes {
            os.write_bytes(6, &v)?;
        };
        for v in &self.ignored_edges {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.source_pub_key.is_empty() {
            os.write_string(8, &self.source_pub_key)?;
        }
        if self.use_mission_control != false {
            os.write_bool(9, self.use_mission_control)?;
        }
        for v in &self.ignored_pairs {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(11, &self.dest_tlv, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRoutesRequest {
        QueryRoutesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &QueryRoutesRequest| { &m.pub_key },
                    |m: &mut QueryRoutesRequest| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt",
                    |m: &QueryRoutesRequest| { &m.amt },
                    |m: &mut QueryRoutesRequest| { &mut m.amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "final_cltv_delta",
                    |m: &QueryRoutesRequest| { &m.final_cltv_delta },
                    |m: &mut QueryRoutesRequest| { &mut m.final_cltv_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeLimit>>(
                    "fee_limit",
                    |m: &QueryRoutesRequest| { &m.fee_limit },
                    |m: &mut QueryRoutesRequest| { &mut m.fee_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ignored_nodes",
                    |m: &QueryRoutesRequest| { &m.ignored_nodes },
                    |m: &mut QueryRoutesRequest| { &mut m.ignored_nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeLocator>>(
                    "ignored_edges",
                    |m: &QueryRoutesRequest| { &m.ignored_edges },
                    |m: &mut QueryRoutesRequest| { &mut m.ignored_edges },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source_pub_key",
                    |m: &QueryRoutesRequest| { &m.source_pub_key },
                    |m: &mut QueryRoutesRequest| { &mut m.source_pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "use_mission_control",
                    |m: &QueryRoutesRequest| { &m.use_mission_control },
                    |m: &mut QueryRoutesRequest| { &mut m.use_mission_control },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePair>>(
                    "ignored_pairs",
                    |m: &QueryRoutesRequest| { &m.ignored_pairs },
                    |m: &mut QueryRoutesRequest| { &mut m.ignored_pairs },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                    "dest_tlv",
                    |m: &QueryRoutesRequest| { &m.dest_tlv },
                    |m: &mut QueryRoutesRequest| { &mut m.dest_tlv },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRoutesRequest>(
                    "QueryRoutesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRoutesRequest {
        static mut instance: ::protobuf::lazy::Lazy<QueryRoutesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRoutesRequest,
        };
        unsafe {
            instance.get(QueryRoutesRequest::new)
        }
    }
}

impl ::protobuf::Clear for QueryRoutesRequest {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.amt = 0;
        self.final_cltv_delta = 0;
        self.fee_limit.clear();
        self.ignored_nodes.clear();
        self.ignored_edges.clear();
        self.source_pub_key.clear();
        self.use_mission_control = false;
        self.ignored_pairs.clear();
        self.dest_tlv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRoutesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRoutesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodePair {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodePair {
    fn default() -> &'a NodePair {
        <NodePair as ::protobuf::Message>::default_instance()
    }
}

impl NodePair {
    pub fn new() -> NodePair {
        ::std::default::Default::default()
    }

    // bytes from = 1;


    pub fn get_from(&self) -> &[u8] {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    // bytes to = 2;


    pub fn get_to(&self) -> &[u8] {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NodePair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodePair {
        NodePair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &NodePair| { &m.from },
                    |m: &mut NodePair| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &NodePair| { &m.to },
                    |m: &mut NodePair| { &mut m.to },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodePair>(
                    "NodePair",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodePair {
        static mut instance: ::protobuf::lazy::Lazy<NodePair> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodePair,
        };
        unsafe {
            instance.get(NodePair::new)
        }
    }
}

impl ::protobuf::Clear for NodePair {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePair {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeLocator {
    // message fields
    pub channel_id: u64,
    pub direction_reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EdgeLocator {
    fn default() -> &'a EdgeLocator {
        <EdgeLocator as ::protobuf::Message>::default_instance()
    }
}

impl EdgeLocator {
    pub fn new() -> EdgeLocator {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    // bool direction_reverse = 2;


    pub fn get_direction_reverse(&self) -> bool {
        self.direction_reverse
    }
    pub fn clear_direction_reverse(&mut self) {
        self.direction_reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_direction_reverse(&mut self, v: bool) {
        self.direction_reverse = v;
    }
}

impl ::protobuf::Message for EdgeLocator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.direction_reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.direction_reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if self.direction_reverse != false {
            os.write_bool(2, self.direction_reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeLocator {
        EdgeLocator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "channel_id",
                    |m: &EdgeLocator| { &m.channel_id },
                    |m: &mut EdgeLocator| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "direction_reverse",
                    |m: &EdgeLocator| { &m.direction_reverse },
                    |m: &mut EdgeLocator| { &mut m.direction_reverse },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeLocator>(
                    "EdgeLocator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeLocator {
        static mut instance: ::protobuf::lazy::Lazy<EdgeLocator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeLocator,
        };
        unsafe {
            instance.get(EdgeLocator::new)
        }
    }
}

impl ::protobuf::Clear for EdgeLocator {
    fn clear(&mut self) {
        self.channel_id = 0;
        self.direction_reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeLocator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeLocator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRoutesResponse {
    // message fields
    pub routes: ::protobuf::RepeatedField<Route>,
    pub success_prob: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryRoutesResponse {
    fn default() -> &'a QueryRoutesResponse {
        <QueryRoutesResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryRoutesResponse {
    pub fn new() -> QueryRoutesResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Route routes = 1;


    pub fn get_routes(&self) -> &[Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    // double success_prob = 2;


    pub fn get_success_prob(&self) -> f64 {
        self.success_prob
    }
    pub fn clear_success_prob(&mut self) {
        self.success_prob = 0.;
    }

    // Param is passed by value, moved
    pub fn set_success_prob(&mut self, v: f64) {
        self.success_prob = v;
    }
}

impl ::protobuf::Message for QueryRoutesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.success_prob = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.success_prob != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.routes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.success_prob != 0. {
            os.write_double(2, self.success_prob)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRoutesResponse {
        QueryRoutesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                    "routes",
                    |m: &QueryRoutesResponse| { &m.routes },
                    |m: &mut QueryRoutesResponse| { &mut m.routes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "success_prob",
                    |m: &QueryRoutesResponse| { &m.success_prob },
                    |m: &mut QueryRoutesResponse| { &mut m.success_prob },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRoutesResponse>(
                    "QueryRoutesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRoutesResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryRoutesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRoutesResponse,
        };
        unsafe {
            instance.get(QueryRoutesResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryRoutesResponse {
    fn clear(&mut self) {
        self.routes.clear();
        self.success_prob = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRoutesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRoutesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hop {
    // message fields
    pub chan_id: u64,
    pub chan_capacity: i64,
    pub amt_to_forward: i64,
    pub fee: i64,
    pub expiry: u32,
    pub amt_to_forward_msat: i64,
    pub fee_msat: i64,
    pub pub_key: ::std::string::String,
    pub tlv_payload: bool,
    pub tlv_records: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Hop {
    fn default() -> &'a Hop {
        <Hop as ::protobuf::Message>::default_instance()
    }
}

impl Hop {
    pub fn new() -> Hop {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // int64 chan_capacity = 2;


    pub fn get_chan_capacity(&self) -> i64 {
        self.chan_capacity
    }
    pub fn clear_chan_capacity(&mut self) {
        self.chan_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_capacity(&mut self, v: i64) {
        self.chan_capacity = v;
    }

    // int64 amt_to_forward = 3;


    pub fn get_amt_to_forward(&self) -> i64 {
        self.amt_to_forward
    }
    pub fn clear_amt_to_forward(&mut self) {
        self.amt_to_forward = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_to_forward(&mut self, v: i64) {
        self.amt_to_forward = v;
    }

    // int64 fee = 4;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // uint32 expiry = 5;


    pub fn get_expiry(&self) -> u32 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: u32) {
        self.expiry = v;
    }

    // int64 amt_to_forward_msat = 6;


    pub fn get_amt_to_forward_msat(&self) -> i64 {
        self.amt_to_forward_msat
    }
    pub fn clear_amt_to_forward_msat(&mut self) {
        self.amt_to_forward_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_to_forward_msat(&mut self, v: i64) {
        self.amt_to_forward_msat = v;
    }

    // int64 fee_msat = 7;


    pub fn get_fee_msat(&self) -> i64 {
        self.fee_msat
    }
    pub fn clear_fee_msat(&mut self) {
        self.fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_msat(&mut self, v: i64) {
        self.fee_msat = v;
    }

    // string pub_key = 8;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // bool tlv_payload = 9;


    pub fn get_tlv_payload(&self) -> bool {
        self.tlv_payload
    }
    pub fn clear_tlv_payload(&mut self) {
        self.tlv_payload = false;
    }

    // Param is passed by value, moved
    pub fn set_tlv_payload(&mut self, v: bool) {
        self.tlv_payload = v;
    }

    // repeated .lnrpc.Hop.TlvRecordsEntry tlv_records = 10;


    pub fn get_tlv_records(&self) -> &::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &self.tlv_records
    }
    pub fn clear_tlv_records(&mut self) {
        self.tlv_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_tlv_records(&mut self, v: ::std::collections::HashMap<u64, ::std::vec::Vec<u8>>) {
        self.tlv_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tlv_records(&mut self) -> &mut ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        &mut self.tlv_records
    }

    // Take field
    pub fn take_tlv_records(&mut self) -> ::std::collections::HashMap<u64, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.tlv_records, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Hop {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.chan_capacity = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_to_forward = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiry = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_to_forward_msat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_msat = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tlv_payload = tmp;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.tlv_records)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_capacity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_to_forward != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt_to_forward, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_to_forward_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.amt_to_forward_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.pub_key);
        }
        if self.tlv_payload != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(10, &self.tlv_records);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.chan_capacity != 0 {
            os.write_int64(2, self.chan_capacity)?;
        }
        if self.amt_to_forward != 0 {
            os.write_int64(3, self.amt_to_forward)?;
        }
        if self.fee != 0 {
            os.write_int64(4, self.fee)?;
        }
        if self.expiry != 0 {
            os.write_uint32(5, self.expiry)?;
        }
        if self.amt_to_forward_msat != 0 {
            os.write_int64(6, self.amt_to_forward_msat)?;
        }
        if self.fee_msat != 0 {
            os.write_int64(7, self.fee_msat)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(8, &self.pub_key)?;
        }
        if self.tlv_payload != false {
            os.write_bool(9, self.tlv_payload)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(10, &self.tlv_records, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hop {
        Hop::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &Hop| { &m.chan_id },
                    |m: &mut Hop| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "chan_capacity",
                    |m: &Hop| { &m.chan_capacity },
                    |m: &mut Hop| { &mut m.chan_capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_to_forward",
                    |m: &Hop| { &m.amt_to_forward },
                    |m: &mut Hop| { &mut m.amt_to_forward },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &Hop| { &m.fee },
                    |m: &mut Hop| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "expiry",
                    |m: &Hop| { &m.expiry },
                    |m: &mut Hop| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_to_forward_msat",
                    |m: &Hop| { &m.amt_to_forward_msat },
                    |m: &mut Hop| { &mut m.amt_to_forward_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_msat",
                    |m: &Hop| { &m.fee_msat },
                    |m: &mut Hop| { &mut m.fee_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &Hop| { &m.pub_key },
                    |m: &mut Hop| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tlv_payload",
                    |m: &Hop| { &m.tlv_payload },
                    |m: &mut Hop| { &mut m.tlv_payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeUint64, ::protobuf::types::ProtobufTypeBytes>(
                    "tlv_records",
                    |m: &Hop| { &m.tlv_records },
                    |m: &mut Hop| { &mut m.tlv_records },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Hop>(
                    "Hop",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hop {
        static mut instance: ::protobuf::lazy::Lazy<Hop> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Hop,
        };
        unsafe {
            instance.get(Hop::new)
        }
    }
}

impl ::protobuf::Clear for Hop {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.chan_capacity = 0;
        self.amt_to_forward = 0;
        self.fee = 0;
        self.expiry = 0;
        self.amt_to_forward_msat = 0;
        self.fee_msat = 0;
        self.pub_key.clear();
        self.tlv_payload = false;
        self.tlv_records.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hop {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Route {
    // message fields
    pub total_time_lock: u32,
    pub total_fees: i64,
    pub total_amt: i64,
    pub hops: ::protobuf::RepeatedField<Hop>,
    pub total_fees_msat: i64,
    pub total_amt_msat: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Route {
    fn default() -> &'a Route {
        <Route as ::protobuf::Message>::default_instance()
    }
}

impl Route {
    pub fn new() -> Route {
        ::std::default::Default::default()
    }

    // uint32 total_time_lock = 1;


    pub fn get_total_time_lock(&self) -> u32 {
        self.total_time_lock
    }
    pub fn clear_total_time_lock(&mut self) {
        self.total_time_lock = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_time_lock(&mut self, v: u32) {
        self.total_time_lock = v;
    }

    // int64 total_fees = 2;


    pub fn get_total_fees(&self) -> i64 {
        self.total_fees
    }
    pub fn clear_total_fees(&mut self) {
        self.total_fees = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees(&mut self, v: i64) {
        self.total_fees = v;
    }

    // int64 total_amt = 3;


    pub fn get_total_amt(&self) -> i64 {
        self.total_amt
    }
    pub fn clear_total_amt(&mut self) {
        self.total_amt = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_amt(&mut self, v: i64) {
        self.total_amt = v;
    }

    // repeated .lnrpc.Hop hops = 4;


    pub fn get_hops(&self) -> &[Hop] {
        &self.hops
    }
    pub fn clear_hops(&mut self) {
        self.hops.clear();
    }

    // Param is passed by value, moved
    pub fn set_hops(&mut self, v: ::protobuf::RepeatedField<Hop>) {
        self.hops = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hops(&mut self) -> &mut ::protobuf::RepeatedField<Hop> {
        &mut self.hops
    }

    // Take field
    pub fn take_hops(&mut self) -> ::protobuf::RepeatedField<Hop> {
        ::std::mem::replace(&mut self.hops, ::protobuf::RepeatedField::new())
    }

    // int64 total_fees_msat = 5;


    pub fn get_total_fees_msat(&self) -> i64 {
        self.total_fees_msat
    }
    pub fn clear_total_fees_msat(&mut self) {
        self.total_fees_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_fees_msat(&mut self, v: i64) {
        self.total_fees_msat = v;
    }

    // int64 total_amt_msat = 6;


    pub fn get_total_amt_msat(&self) -> i64 {
        self.total_amt_msat
    }
    pub fn clear_total_amt_msat(&mut self) {
        self.total_amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_amt_msat(&mut self, v: i64) {
        self.total_amt_msat = v;
    }
}

impl ::protobuf::Message for Route {
    fn is_initialized(&self) -> bool {
        for v in &self.hops {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_time_lock = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_amt = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hops)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_fees_msat = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_amt_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_time_lock != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_time_lock, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_fees != 0 {
            my_size += ::protobuf::rt::value_size(2, self.total_fees, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_amt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_amt, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.hops {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.total_fees_msat != 0 {
            my_size += ::protobuf::rt::value_size(5, self.total_fees_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.total_amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_time_lock != 0 {
            os.write_uint32(1, self.total_time_lock)?;
        }
        if self.total_fees != 0 {
            os.write_int64(2, self.total_fees)?;
        }
        if self.total_amt != 0 {
            os.write_int64(3, self.total_amt)?;
        }
        for v in &self.hops {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.total_fees_msat != 0 {
            os.write_int64(5, self.total_fees_msat)?;
        }
        if self.total_amt_msat != 0 {
            os.write_int64(6, self.total_amt_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Route {
        Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "total_time_lock",
                    |m: &Route| { &m.total_time_lock },
                    |m: &mut Route| { &mut m.total_time_lock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_fees",
                    |m: &Route| { &m.total_fees },
                    |m: &mut Route| { &mut m.total_fees },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_amt",
                    |m: &Route| { &m.total_amt },
                    |m: &mut Route| { &mut m.total_amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hop>>(
                    "hops",
                    |m: &Route| { &m.hops },
                    |m: &mut Route| { &mut m.hops },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_fees_msat",
                    |m: &Route| { &m.total_fees_msat },
                    |m: &mut Route| { &mut m.total_fees_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_amt_msat",
                    |m: &Route| { &m.total_amt_msat },
                    |m: &mut Route| { &mut m.total_amt_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Route>(
                    "Route",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Route {
        static mut instance: ::protobuf::lazy::Lazy<Route> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Route,
        };
        unsafe {
            instance.get(Route::new)
        }
    }
}

impl ::protobuf::Clear for Route {
    fn clear(&mut self) {
        self.total_time_lock = 0;
        self.total_fees = 0;
        self.total_amt = 0;
        self.hops.clear();
        self.total_fees_msat = 0;
        self.total_amt_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Route {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfoRequest {
    // message fields
    pub pub_key: ::std::string::String,
    pub include_channels: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfoRequest {
    fn default() -> &'a NodeInfoRequest {
        <NodeInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfoRequest {
    pub fn new() -> NodeInfoRequest {
        ::std::default::Default::default()
    }

    // string pub_key = 1;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // bool include_channels = 2;


    pub fn get_include_channels(&self) -> bool {
        self.include_channels
    }
    pub fn clear_include_channels(&mut self) {
        self.include_channels = false;
    }

    // Param is passed by value, moved
    pub fn set_include_channels(&mut self, v: bool) {
        self.include_channels = v;
    }
}

impl ::protobuf::Message for NodeInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_channels = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pub_key);
        }
        if self.include_channels != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pub_key.is_empty() {
            os.write_string(1, &self.pub_key)?;
        }
        if self.include_channels != false {
            os.write_bool(2, self.include_channels)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfoRequest {
        NodeInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &NodeInfoRequest| { &m.pub_key },
                    |m: &mut NodeInfoRequest| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_channels",
                    |m: &NodeInfoRequest| { &m.include_channels },
                    |m: &mut NodeInfoRequest| { &mut m.include_channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfoRequest>(
                    "NodeInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfoRequest,
        };
        unsafe {
            instance.get(NodeInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfoRequest {
    fn clear(&mut self) {
        self.pub_key.clear();
        self.include_channels = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeInfo {
    // message fields
    pub node: ::protobuf::SingularPtrField<LightningNode>,
    pub num_channels: u32,
    pub total_capacity: i64,
    pub channels: ::protobuf::RepeatedField<ChannelEdge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo {
    fn default() -> &'a NodeInfo {
        <NodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo {
    pub fn new() -> NodeInfo {
        ::std::default::Default::default()
    }

    // .lnrpc.LightningNode node = 1;


    pub fn get_node(&self) -> &LightningNode {
        self.node.as_ref().unwrap_or_else(|| LightningNode::default_instance())
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    pub fn has_node(&self) -> bool {
        self.node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: LightningNode) {
        self.node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut LightningNode {
        if self.node.is_none() {
            self.node.set_default();
        }
        self.node.as_mut().unwrap()
    }

    // Take field
    pub fn take_node(&mut self) -> LightningNode {
        self.node.take().unwrap_or_else(|| LightningNode::new())
    }

    // uint32 num_channels = 2;


    pub fn get_num_channels(&self) -> u32 {
        self.num_channels
    }
    pub fn clear_num_channels(&mut self) {
        self.num_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_channels(&mut self, v: u32) {
        self.num_channels = v;
    }

    // int64 total_capacity = 3;


    pub fn get_total_capacity(&self) -> i64 {
        self.total_capacity
    }
    pub fn clear_total_capacity(&mut self) {
        self.total_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_capacity(&mut self, v: i64) {
        self.total_capacity = v;
    }

    // repeated .lnrpc.ChannelEdge channels = 4;


    pub fn get_channels(&self) -> &[ChannelEdge] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<ChannelEdge>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdge> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<ChannelEdge> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_channels = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_capacity = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.num_channels != 0 {
            os.write_uint32(2, self.num_channels)?;
        }
        if self.total_capacity != 0 {
            os.write_int64(3, self.total_capacity)?;
        }
        for v in &self.channels {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo {
        NodeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningNode>>(
                    "node",
                    |m: &NodeInfo| { &m.node },
                    |m: &mut NodeInfo| { &mut m.node },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_channels",
                    |m: &NodeInfo| { &m.num_channels },
                    |m: &mut NodeInfo| { &mut m.num_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_capacity",
                    |m: &NodeInfo| { &m.total_capacity },
                    |m: &mut NodeInfo| { &mut m.total_capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdge>>(
                    "channels",
                    |m: &NodeInfo| { &m.channels },
                    |m: &mut NodeInfo| { &mut m.channels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeInfo>(
                    "NodeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeInfo,
        };
        unsafe {
            instance.get(NodeInfo::new)
        }
    }
}

impl ::protobuf::Clear for NodeInfo {
    fn clear(&mut self) {
        self.node.clear();
        self.num_channels = 0;
        self.total_capacity = 0;
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightningNode {
    // message fields
    pub last_update: u32,
    pub pub_key: ::std::string::String,
    pub alias: ::std::string::String,
    pub addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub color: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightningNode {
    fn default() -> &'a LightningNode {
        <LightningNode as ::protobuf::Message>::default_instance()
    }
}

impl LightningNode {
    pub fn new() -> LightningNode {
        ::std::default::Default::default()
    }

    // uint32 last_update = 1;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    // string pub_key = 2;


    pub fn get_pub_key(&self) -> &str {
        &self.pub_key
    }
    pub fn clear_pub_key(&mut self) {
        self.pub_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_pub_key(&mut self, v: ::std::string::String) {
        self.pub_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key(&mut self) -> &mut ::std::string::String {
        &mut self.pub_key
    }

    // Take field
    pub fn take_pub_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pub_key, ::std::string::String::new())
    }

    // string alias = 3;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // repeated .lnrpc.NodeAddress addresses = 4;


    pub fn get_addresses(&self) -> &[NodeAddress] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // string color = 5;


    pub fn get_color(&self) -> &str {
        &self.color
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightningNode {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(1, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pub_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pub_key);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.alias);
        }
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.last_update != 0 {
            os.write_uint32(1, self.last_update)?;
        }
        if !self.pub_key.is_empty() {
            os.write_string(2, &self.pub_key)?;
        }
        if !self.alias.is_empty() {
            os.write_string(3, &self.alias)?;
        }
        for v in &self.addresses {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightningNode {
        LightningNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_update",
                    |m: &LightningNode| { &m.last_update },
                    |m: &mut LightningNode| { &mut m.last_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pub_key",
                    |m: &LightningNode| { &m.pub_key },
                    |m: &mut LightningNode| { &mut m.pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &LightningNode| { &m.alias },
                    |m: &mut LightningNode| { &mut m.alias },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                    "addresses",
                    |m: &LightningNode| { &m.addresses },
                    |m: &mut LightningNode| { &mut m.addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "color",
                    |m: &LightningNode| { &m.color },
                    |m: &mut LightningNode| { &mut m.color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LightningNode>(
                    "LightningNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LightningNode {
        static mut instance: ::protobuf::lazy::Lazy<LightningNode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LightningNode,
        };
        unsafe {
            instance.get(LightningNode::new)
        }
    }
}

impl ::protobuf::Clear for LightningNode {
    fn clear(&mut self) {
        self.last_update = 0;
        self.pub_key.clear();
        self.alias.clear();
        self.addresses.clear();
        self.color.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightningNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightningNode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAddress {
    // message fields
    pub network: ::std::string::String,
    pub addr: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeAddress {
    fn default() -> &'a NodeAddress {
        <NodeAddress as ::protobuf::Message>::default_instance()
    }
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // string network = 1;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }

    // string addr = 2;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.network);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.network.is_empty() {
            os.write_string(1, &self.network)?;
        }
        if !self.addr.is_empty() {
            os.write_string(2, &self.addr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "network",
                    |m: &NodeAddress| { &m.network },
                    |m: &mut NodeAddress| { &mut m.network },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addr",
                    |m: &NodeAddress| { &m.addr },
                    |m: &mut NodeAddress| { &mut m.addr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAddress>(
                    "NodeAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeAddress {
        static mut instance: ::protobuf::lazy::Lazy<NodeAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAddress,
        };
        unsafe {
            instance.get(NodeAddress::new)
        }
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.network.clear();
        self.addr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingPolicy {
    // message fields
    pub time_lock_delta: u32,
    pub min_htlc: i64,
    pub fee_base_msat: i64,
    pub fee_rate_milli_msat: i64,
    pub disabled: bool,
    pub max_htlc_msat: u64,
    pub last_update: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingPolicy {
    fn default() -> &'a RoutingPolicy {
        <RoutingPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RoutingPolicy {
    pub fn new() -> RoutingPolicy {
        ::std::default::Default::default()
    }

    // uint32 time_lock_delta = 1;


    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }
    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }

    // int64 min_htlc = 2;


    pub fn get_min_htlc(&self) -> i64 {
        self.min_htlc
    }
    pub fn clear_min_htlc(&mut self) {
        self.min_htlc = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_htlc(&mut self, v: i64) {
        self.min_htlc = v;
    }

    // int64 fee_base_msat = 3;


    pub fn get_fee_base_msat(&self) -> i64 {
        self.fee_base_msat
    }
    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: i64) {
        self.fee_base_msat = v;
    }

    // int64 fee_rate_milli_msat = 4;


    pub fn get_fee_rate_milli_msat(&self) -> i64 {
        self.fee_rate_milli_msat
    }
    pub fn clear_fee_rate_milli_msat(&mut self) {
        self.fee_rate_milli_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate_milli_msat(&mut self, v: i64) {
        self.fee_rate_milli_msat = v;
    }

    // bool disabled = 5;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }

    // uint64 max_htlc_msat = 6;


    pub fn get_max_htlc_msat(&self) -> u64 {
        self.max_htlc_msat
    }
    pub fn clear_max_htlc_msat(&mut self) {
        self.max_htlc_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_htlc_msat(&mut self, v: u64) {
        self.max_htlc_msat = v;
    }

    // uint32 last_update = 7;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }
}

impl ::protobuf::Message for RoutingPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_htlc = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_base_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_rate_milli_msat = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_htlc_msat = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_htlc != 0 {
            my_size += ::protobuf::rt::value_size(2, self.min_htlc, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_base_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_base_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate_milli_msat != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee_rate_milli_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disabled != false {
            my_size += 2;
        }
        if self.max_htlc_msat != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_htlc_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(7, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time_lock_delta != 0 {
            os.write_uint32(1, self.time_lock_delta)?;
        }
        if self.min_htlc != 0 {
            os.write_int64(2, self.min_htlc)?;
        }
        if self.fee_base_msat != 0 {
            os.write_int64(3, self.fee_base_msat)?;
        }
        if self.fee_rate_milli_msat != 0 {
            os.write_int64(4, self.fee_rate_milli_msat)?;
        }
        if self.disabled != false {
            os.write_bool(5, self.disabled)?;
        }
        if self.max_htlc_msat != 0 {
            os.write_uint64(6, self.max_htlc_msat)?;
        }
        if self.last_update != 0 {
            os.write_uint32(7, self.last_update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingPolicy {
        RoutingPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_lock_delta",
                    |m: &RoutingPolicy| { &m.time_lock_delta },
                    |m: &mut RoutingPolicy| { &mut m.time_lock_delta },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_htlc",
                    |m: &RoutingPolicy| { &m.min_htlc },
                    |m: &mut RoutingPolicy| { &mut m.min_htlc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_base_msat",
                    |m: &RoutingPolicy| { &m.fee_base_msat },
                    |m: &mut RoutingPolicy| { &mut m.fee_base_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_rate_milli_msat",
                    |m: &RoutingPolicy| { &m.fee_rate_milli_msat },
                    |m: &mut RoutingPolicy| { &mut m.fee_rate_milli_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "disabled",
                    |m: &RoutingPolicy| { &m.disabled },
                    |m: &mut RoutingPolicy| { &mut m.disabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "max_htlc_msat",
                    |m: &RoutingPolicy| { &m.max_htlc_msat },
                    |m: &mut RoutingPolicy| { &mut m.max_htlc_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_update",
                    |m: &RoutingPolicy| { &m.last_update },
                    |m: &mut RoutingPolicy| { &mut m.last_update },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoutingPolicy>(
                    "RoutingPolicy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoutingPolicy {
        static mut instance: ::protobuf::lazy::Lazy<RoutingPolicy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoutingPolicy,
        };
        unsafe {
            instance.get(RoutingPolicy::new)
        }
    }
}

impl ::protobuf::Clear for RoutingPolicy {
    fn clear(&mut self) {
        self.time_lock_delta = 0;
        self.min_htlc = 0;
        self.fee_base_msat = 0;
        self.fee_rate_milli_msat = 0;
        self.disabled = false;
        self.max_htlc_msat = 0;
        self.last_update = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelEdge {
    // message fields
    pub channel_id: u64,
    pub chan_point: ::std::string::String,
    pub last_update: u32,
    pub node1_pub: ::std::string::String,
    pub node2_pub: ::std::string::String,
    pub capacity: i64,
    pub node1_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    pub node2_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEdge {
    fn default() -> &'a ChannelEdge {
        <ChannelEdge as ::protobuf::Message>::default_instance()
    }
}

impl ChannelEdge {
    pub fn new() -> ChannelEdge {
        ::std::default::Default::default()
    }

    // uint64 channel_id = 1;


    pub fn get_channel_id(&self) -> u64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = v;
    }

    // string chan_point = 2;


    pub fn get_chan_point(&self) -> &str {
        &self.chan_point
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ::std::string::String) {
        self.chan_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ::std::string::String {
        &mut self.chan_point
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_point, ::std::string::String::new())
    }

    // uint32 last_update = 3;


    pub fn get_last_update(&self) -> u32 {
        self.last_update
    }
    pub fn clear_last_update(&mut self) {
        self.last_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_update(&mut self, v: u32) {
        self.last_update = v;
    }

    // string node1_pub = 4;


    pub fn get_node1_pub(&self) -> &str {
        &self.node1_pub
    }
    pub fn clear_node1_pub(&mut self) {
        self.node1_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node1_pub(&mut self, v: ::std::string::String) {
        self.node1_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node1_pub
    }

    // Take field
    pub fn take_node1_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node1_pub, ::std::string::String::new())
    }

    // string node2_pub = 5;


    pub fn get_node2_pub(&self) -> &str {
        &self.node2_pub
    }
    pub fn clear_node2_pub(&mut self) {
        self.node2_pub.clear();
    }

    // Param is passed by value, moved
    pub fn set_node2_pub(&mut self, v: ::std::string::String) {
        self.node2_pub = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_pub(&mut self) -> &mut ::std::string::String {
        &mut self.node2_pub
    }

    // Take field
    pub fn take_node2_pub(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node2_pub, ::std::string::String::new())
    }

    // int64 capacity = 6;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // .lnrpc.RoutingPolicy node1_policy = 7;


    pub fn get_node1_policy(&self) -> &RoutingPolicy {
        self.node1_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }
    pub fn clear_node1_policy(&mut self) {
        self.node1_policy.clear();
    }

    pub fn has_node1_policy(&self) -> bool {
        self.node1_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node1_policy(&mut self, v: RoutingPolicy) {
        self.node1_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node1_policy(&mut self) -> &mut RoutingPolicy {
        if self.node1_policy.is_none() {
            self.node1_policy.set_default();
        }
        self.node1_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node1_policy(&mut self) -> RoutingPolicy {
        self.node1_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    // .lnrpc.RoutingPolicy node2_policy = 8;


    pub fn get_node2_policy(&self) -> &RoutingPolicy {
        self.node2_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }
    pub fn clear_node2_policy(&mut self) {
        self.node2_policy.clear();
    }

    pub fn has_node2_policy(&self) -> bool {
        self.node2_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node2_policy(&mut self, v: RoutingPolicy) {
        self.node2_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node2_policy(&mut self) -> &mut RoutingPolicy {
        if self.node2_policy.is_none() {
            self.node2_policy.set_default();
        }
        self.node2_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_node2_policy(&mut self) -> RoutingPolicy {
        self.node2_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }
}

impl ::protobuf::Message for ChannelEdge {
    fn is_initialized(&self) -> bool {
        for v in &self.node1_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node2_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.channel_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_update = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node1_pub)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node2_pub)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node1_policy)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node2_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chan_point.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chan_point);
        }
        if self.last_update != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.node1_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node1_pub);
        }
        if !self.node2_pub.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.node2_pub);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_id != 0 {
            os.write_uint64(1, self.channel_id)?;
        }
        if !self.chan_point.is_empty() {
            os.write_string(2, &self.chan_point)?;
        }
        if self.last_update != 0 {
            os.write_uint32(3, self.last_update)?;
        }
        if !self.node1_pub.is_empty() {
            os.write_string(4, &self.node1_pub)?;
        }
        if !self.node2_pub.is_empty() {
            os.write_string(5, &self.node2_pub)?;
        }
        if self.capacity != 0 {
            os.write_int64(6, self.capacity)?;
        }
        if let Some(ref v) = self.node1_policy.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.node2_policy.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEdge {
        ChannelEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "channel_id",
                    |m: &ChannelEdge| { &m.channel_id },
                    |m: &mut ChannelEdge| { &mut m.channel_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chan_point",
                    |m: &ChannelEdge| { &m.chan_point },
                    |m: &mut ChannelEdge| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_update",
                    |m: &ChannelEdge| { &m.last_update },
                    |m: &mut ChannelEdge| { &mut m.last_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node1_pub",
                    |m: &ChannelEdge| { &m.node1_pub },
                    |m: &mut ChannelEdge| { &mut m.node1_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node2_pub",
                    |m: &ChannelEdge| { &m.node2_pub },
                    |m: &mut ChannelEdge| { &mut m.node2_pub },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ChannelEdge| { &m.capacity },
                    |m: &mut ChannelEdge| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "node1_policy",
                    |m: &ChannelEdge| { &m.node1_policy },
                    |m: &mut ChannelEdge| { &mut m.node1_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "node2_policy",
                    |m: &ChannelEdge| { &m.node2_policy },
                    |m: &mut ChannelEdge| { &mut m.node2_policy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelEdge>(
                    "ChannelEdge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelEdge {
        static mut instance: ::protobuf::lazy::Lazy<ChannelEdge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelEdge,
        };
        unsafe {
            instance.get(ChannelEdge::new)
        }
    }
}

impl ::protobuf::Clear for ChannelEdge {
    fn clear(&mut self) {
        self.channel_id = 0;
        self.chan_point.clear();
        self.last_update = 0;
        self.node1_pub.clear();
        self.node2_pub.clear();
        self.capacity = 0;
        self.node1_policy.clear();
        self.node2_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelGraphRequest {
    // message fields
    pub include_unannounced: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelGraphRequest {
    fn default() -> &'a ChannelGraphRequest {
        <ChannelGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelGraphRequest {
    pub fn new() -> ChannelGraphRequest {
        ::std::default::Default::default()
    }

    // bool include_unannounced = 1;


    pub fn get_include_unannounced(&self) -> bool {
        self.include_unannounced
    }
    pub fn clear_include_unannounced(&mut self) {
        self.include_unannounced = false;
    }

    // Param is passed by value, moved
    pub fn set_include_unannounced(&mut self, v: bool) {
        self.include_unannounced = v;
    }
}

impl ::protobuf::Message for ChannelGraphRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_unannounced = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.include_unannounced != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.include_unannounced != false {
            os.write_bool(1, self.include_unannounced)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraphRequest {
        ChannelGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_unannounced",
                    |m: &ChannelGraphRequest| { &m.include_unannounced },
                    |m: &mut ChannelGraphRequest| { &mut m.include_unannounced },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelGraphRequest>(
                    "ChannelGraphRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelGraphRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChannelGraphRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelGraphRequest,
        };
        unsafe {
            instance.get(ChannelGraphRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChannelGraphRequest {
    fn clear(&mut self) {
        self.include_unannounced = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelGraph {
    // message fields
    pub nodes: ::protobuf::RepeatedField<LightningNode>,
    pub edges: ::protobuf::RepeatedField<ChannelEdge>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelGraph {
    fn default() -> &'a ChannelGraph {
        <ChannelGraph as ::protobuf::Message>::default_instance()
    }
}

impl ChannelGraph {
    pub fn new() -> ChannelGraph {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.LightningNode nodes = 1;


    pub fn get_nodes(&self) -> &[LightningNode] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<LightningNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<LightningNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<LightningNode> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.ChannelEdge edges = 2;


    pub fn get_edges(&self) -> &[ChannelEdge] {
        &self.edges
    }
    pub fn clear_edges(&mut self) {
        self.edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_edges(&mut self, v: ::protobuf::RepeatedField<ChannelEdge>) {
        self.edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edges(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdge> {
        &mut self.edges
    }

    // Take field
    pub fn take_edges(&mut self) -> ::protobuf::RepeatedField<ChannelEdge> {
        ::std::mem::replace(&mut self.edges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChannelGraph {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelGraph {
        ChannelGraph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LightningNode>>(
                    "nodes",
                    |m: &ChannelGraph| { &m.nodes },
                    |m: &mut ChannelGraph| { &mut m.nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdge>>(
                    "edges",
                    |m: &ChannelGraph| { &m.edges },
                    |m: &mut ChannelGraph| { &mut m.edges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelGraph>(
                    "ChannelGraph",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelGraph {
        static mut instance: ::protobuf::lazy::Lazy<ChannelGraph> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelGraph,
        };
        unsafe {
            instance.get(ChannelGraph::new)
        }
    }
}

impl ::protobuf::Clear for ChannelGraph {
    fn clear(&mut self) {
        self.nodes.clear();
        self.edges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelGraph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelGraph {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChanInfoRequest {
    // message fields
    pub chan_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChanInfoRequest {
    fn default() -> &'a ChanInfoRequest {
        <ChanInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChanInfoRequest {
    pub fn new() -> ChanInfoRequest {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }
}

impl ::protobuf::Message for ChanInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanInfoRequest {
        ChanInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ChanInfoRequest| { &m.chan_id },
                    |m: &mut ChanInfoRequest| { &mut m.chan_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChanInfoRequest>(
                    "ChanInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChanInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChanInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChanInfoRequest,
        };
        unsafe {
            instance.get(ChanInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChanInfoRequest {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkInfoRequest {
    fn default() -> &'a NetworkInfoRequest {
        <NetworkInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl NetworkInfoRequest {
    pub fn new() -> NetworkInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NetworkInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkInfoRequest {
        NetworkInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfoRequest>(
                    "NetworkInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NetworkInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfoRequest,
        };
        unsafe {
            instance.get(NetworkInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for NetworkInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkInfo {
    // message fields
    pub graph_diameter: u32,
    pub avg_out_degree: f64,
    pub max_out_degree: u32,
    pub num_nodes: u32,
    pub num_channels: u32,
    pub total_network_capacity: i64,
    pub avg_channel_size: f64,
    pub min_channel_size: i64,
    pub max_channel_size: i64,
    pub median_channel_size_sat: i64,
    pub num_zombie_chans: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkInfo {
    fn default() -> &'a NetworkInfo {
        <NetworkInfo as ::protobuf::Message>::default_instance()
    }
}

impl NetworkInfo {
    pub fn new() -> NetworkInfo {
        ::std::default::Default::default()
    }

    // uint32 graph_diameter = 1;


    pub fn get_graph_diameter(&self) -> u32 {
        self.graph_diameter
    }
    pub fn clear_graph_diameter(&mut self) {
        self.graph_diameter = 0;
    }

    // Param is passed by value, moved
    pub fn set_graph_diameter(&mut self, v: u32) {
        self.graph_diameter = v;
    }

    // double avg_out_degree = 2;


    pub fn get_avg_out_degree(&self) -> f64 {
        self.avg_out_degree
    }
    pub fn clear_avg_out_degree(&mut self) {
        self.avg_out_degree = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_out_degree(&mut self, v: f64) {
        self.avg_out_degree = v;
    }

    // uint32 max_out_degree = 3;


    pub fn get_max_out_degree(&self) -> u32 {
        self.max_out_degree
    }
    pub fn clear_max_out_degree(&mut self) {
        self.max_out_degree = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_out_degree(&mut self, v: u32) {
        self.max_out_degree = v;
    }

    // uint32 num_nodes = 4;


    pub fn get_num_nodes(&self) -> u32 {
        self.num_nodes
    }
    pub fn clear_num_nodes(&mut self) {
        self.num_nodes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_nodes(&mut self, v: u32) {
        self.num_nodes = v;
    }

    // uint32 num_channels = 5;


    pub fn get_num_channels(&self) -> u32 {
        self.num_channels
    }
    pub fn clear_num_channels(&mut self) {
        self.num_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_channels(&mut self, v: u32) {
        self.num_channels = v;
    }

    // int64 total_network_capacity = 6;


    pub fn get_total_network_capacity(&self) -> i64 {
        self.total_network_capacity
    }
    pub fn clear_total_network_capacity(&mut self) {
        self.total_network_capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_network_capacity(&mut self, v: i64) {
        self.total_network_capacity = v;
    }

    // double avg_channel_size = 7;


    pub fn get_avg_channel_size(&self) -> f64 {
        self.avg_channel_size
    }
    pub fn clear_avg_channel_size(&mut self) {
        self.avg_channel_size = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_channel_size(&mut self, v: f64) {
        self.avg_channel_size = v;
    }

    // int64 min_channel_size = 8;


    pub fn get_min_channel_size(&self) -> i64 {
        self.min_channel_size
    }
    pub fn clear_min_channel_size(&mut self) {
        self.min_channel_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_channel_size(&mut self, v: i64) {
        self.min_channel_size = v;
    }

    // int64 max_channel_size = 9;


    pub fn get_max_channel_size(&self) -> i64 {
        self.max_channel_size
    }
    pub fn clear_max_channel_size(&mut self) {
        self.max_channel_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_channel_size(&mut self, v: i64) {
        self.max_channel_size = v;
    }

    // int64 median_channel_size_sat = 10;


    pub fn get_median_channel_size_sat(&self) -> i64 {
        self.median_channel_size_sat
    }
    pub fn clear_median_channel_size_sat(&mut self) {
        self.median_channel_size_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_median_channel_size_sat(&mut self, v: i64) {
        self.median_channel_size_sat = v;
    }

    // uint64 num_zombie_chans = 11;


    pub fn get_num_zombie_chans(&self) -> u64 {
        self.num_zombie_chans
    }
    pub fn clear_num_zombie_chans(&mut self) {
        self.num_zombie_chans = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_zombie_chans(&mut self, v: u64) {
        self.num_zombie_chans = v;
    }
}

impl ::protobuf::Message for NetworkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.graph_diameter = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_out_degree = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_out_degree = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_nodes = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_channels = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_network_capacity = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_channel_size = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min_channel_size = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_channel_size = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.median_channel_size_sat = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_zombie_chans = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.graph_diameter != 0 {
            my_size += ::protobuf::rt::value_size(1, self.graph_diameter, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_out_degree != 0. {
            my_size += 9;
        }
        if self.max_out_degree != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_out_degree, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_nodes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_nodes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_network_capacity != 0 {
            my_size += ::protobuf::rt::value_size(6, self.total_network_capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_channel_size != 0. {
            my_size += 9;
        }
        if self.min_channel_size != 0 {
            my_size += ::protobuf::rt::value_size(8, self.min_channel_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_channel_size != 0 {
            my_size += ::protobuf::rt::value_size(9, self.max_channel_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.median_channel_size_sat != 0 {
            my_size += ::protobuf::rt::value_size(10, self.median_channel_size_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_zombie_chans != 0 {
            my_size += ::protobuf::rt::value_size(11, self.num_zombie_chans, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.graph_diameter != 0 {
            os.write_uint32(1, self.graph_diameter)?;
        }
        if self.avg_out_degree != 0. {
            os.write_double(2, self.avg_out_degree)?;
        }
        if self.max_out_degree != 0 {
            os.write_uint32(3, self.max_out_degree)?;
        }
        if self.num_nodes != 0 {
            os.write_uint32(4, self.num_nodes)?;
        }
        if self.num_channels != 0 {
            os.write_uint32(5, self.num_channels)?;
        }
        if self.total_network_capacity != 0 {
            os.write_int64(6, self.total_network_capacity)?;
        }
        if self.avg_channel_size != 0. {
            os.write_double(7, self.avg_channel_size)?;
        }
        if self.min_channel_size != 0 {
            os.write_int64(8, self.min_channel_size)?;
        }
        if self.max_channel_size != 0 {
            os.write_int64(9, self.max_channel_size)?;
        }
        if self.median_channel_size_sat != 0 {
            os.write_int64(10, self.median_channel_size_sat)?;
        }
        if self.num_zombie_chans != 0 {
            os.write_uint64(11, self.num_zombie_chans)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkInfo {
        NetworkInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "graph_diameter",
                    |m: &NetworkInfo| { &m.graph_diameter },
                    |m: &mut NetworkInfo| { &mut m.graph_diameter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "avg_out_degree",
                    |m: &NetworkInfo| { &m.avg_out_degree },
                    |m: &mut NetworkInfo| { &mut m.avg_out_degree },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_out_degree",
                    |m: &NetworkInfo| { &m.max_out_degree },
                    |m: &mut NetworkInfo| { &mut m.max_out_degree },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_nodes",
                    |m: &NetworkInfo| { &m.num_nodes },
                    |m: &mut NetworkInfo| { &mut m.num_nodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_channels",
                    |m: &NetworkInfo| { &m.num_channels },
                    |m: &mut NetworkInfo| { &mut m.num_channels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "total_network_capacity",
                    |m: &NetworkInfo| { &m.total_network_capacity },
                    |m: &mut NetworkInfo| { &mut m.total_network_capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "avg_channel_size",
                    |m: &NetworkInfo| { &m.avg_channel_size },
                    |m: &mut NetworkInfo| { &mut m.avg_channel_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min_channel_size",
                    |m: &NetworkInfo| { &m.min_channel_size },
                    |m: &mut NetworkInfo| { &mut m.min_channel_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_channel_size",
                    |m: &NetworkInfo| { &m.max_channel_size },
                    |m: &mut NetworkInfo| { &mut m.max_channel_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "median_channel_size_sat",
                    |m: &NetworkInfo| { &m.median_channel_size_sat },
                    |m: &mut NetworkInfo| { &mut m.median_channel_size_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_zombie_chans",
                    |m: &NetworkInfo| { &m.num_zombie_chans },
                    |m: &mut NetworkInfo| { &mut m.num_zombie_chans },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfo>(
                    "NetworkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NetworkInfo {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfo,
        };
        unsafe {
            instance.get(NetworkInfo::new)
        }
    }
}

impl ::protobuf::Clear for NetworkInfo {
    fn clear(&mut self) {
        self.graph_diameter = 0;
        self.avg_out_degree = 0.;
        self.max_out_degree = 0;
        self.num_nodes = 0;
        self.num_channels = 0;
        self.total_network_capacity = 0;
        self.avg_channel_size = 0.;
        self.min_channel_size = 0;
        self.max_channel_size = 0;
        self.median_channel_size_sat = 0;
        self.num_zombie_chans = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopRequest {
    fn default() -> &'a StopRequest {
        <StopRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopRequest {
    pub fn new() -> StopRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopRequest {
        StopRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopRequest>(
                    "StopRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopRequest,
        };
        unsafe {
            instance.get(StopRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopResponse {
    fn default() -> &'a StopResponse {
        <StopResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopResponse {
    pub fn new() -> StopResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopResponse {
        StopResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopResponse>(
                    "StopResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopResponse {
        static mut instance: ::protobuf::lazy::Lazy<StopResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopResponse,
        };
        unsafe {
            instance.get(StopResponse::new)
        }
    }
}

impl ::protobuf::Clear for StopResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphTopologySubscription {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphTopologySubscription {
    fn default() -> &'a GraphTopologySubscription {
        <GraphTopologySubscription as ::protobuf::Message>::default_instance()
    }
}

impl GraphTopologySubscription {
    pub fn new() -> GraphTopologySubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GraphTopologySubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphTopologySubscription {
        GraphTopologySubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GraphTopologySubscription>(
                    "GraphTopologySubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphTopologySubscription {
        static mut instance: ::protobuf::lazy::Lazy<GraphTopologySubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphTopologySubscription,
        };
        unsafe {
            instance.get(GraphTopologySubscription::new)
        }
    }
}

impl ::protobuf::Clear for GraphTopologySubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphTopologySubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphTopologySubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphTopologyUpdate {
    // message fields
    pub node_updates: ::protobuf::RepeatedField<NodeUpdate>,
    pub channel_updates: ::protobuf::RepeatedField<ChannelEdgeUpdate>,
    pub closed_chans: ::protobuf::RepeatedField<ClosedChannelUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GraphTopologyUpdate {
    fn default() -> &'a GraphTopologyUpdate {
        <GraphTopologyUpdate as ::protobuf::Message>::default_instance()
    }
}

impl GraphTopologyUpdate {
    pub fn new() -> GraphTopologyUpdate {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.NodeUpdate node_updates = 1;


    pub fn get_node_updates(&self) -> &[NodeUpdate] {
        &self.node_updates
    }
    pub fn clear_node_updates(&mut self) {
        self.node_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_updates(&mut self, v: ::protobuf::RepeatedField<NodeUpdate>) {
        self.node_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_updates(&mut self) -> &mut ::protobuf::RepeatedField<NodeUpdate> {
        &mut self.node_updates
    }

    // Take field
    pub fn take_node_updates(&mut self) -> ::protobuf::RepeatedField<NodeUpdate> {
        ::std::mem::replace(&mut self.node_updates, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.ChannelEdgeUpdate channel_updates = 2;


    pub fn get_channel_updates(&self) -> &[ChannelEdgeUpdate] {
        &self.channel_updates
    }
    pub fn clear_channel_updates(&mut self) {
        self.channel_updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_updates(&mut self, v: ::protobuf::RepeatedField<ChannelEdgeUpdate>) {
        self.channel_updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_updates(&mut self) -> &mut ::protobuf::RepeatedField<ChannelEdgeUpdate> {
        &mut self.channel_updates
    }

    // Take field
    pub fn take_channel_updates(&mut self) -> ::protobuf::RepeatedField<ChannelEdgeUpdate> {
        ::std::mem::replace(&mut self.channel_updates, ::protobuf::RepeatedField::new())
    }

    // repeated .lnrpc.ClosedChannelUpdate closed_chans = 3;


    pub fn get_closed_chans(&self) -> &[ClosedChannelUpdate] {
        &self.closed_chans
    }
    pub fn clear_closed_chans(&mut self) {
        self.closed_chans.clear();
    }

    // Param is passed by value, moved
    pub fn set_closed_chans(&mut self, v: ::protobuf::RepeatedField<ClosedChannelUpdate>) {
        self.closed_chans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_closed_chans(&mut self) -> &mut ::protobuf::RepeatedField<ClosedChannelUpdate> {
        &mut self.closed_chans
    }

    // Take field
    pub fn take_closed_chans(&mut self) -> ::protobuf::RepeatedField<ClosedChannelUpdate> {
        ::std::mem::replace(&mut self.closed_chans, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GraphTopologyUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.node_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.channel_updates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.closed_chans {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node_updates)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_updates)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.closed_chans)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.channel_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.closed_chans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node_updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.channel_updates {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.closed_chans {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphTopologyUpdate {
        GraphTopologyUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeUpdate>>(
                    "node_updates",
                    |m: &GraphTopologyUpdate| { &m.node_updates },
                    |m: &mut GraphTopologyUpdate| { &mut m.node_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelEdgeUpdate>>(
                    "channel_updates",
                    |m: &GraphTopologyUpdate| { &m.channel_updates },
                    |m: &mut GraphTopologyUpdate| { &mut m.channel_updates },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClosedChannelUpdate>>(
                    "closed_chans",
                    |m: &GraphTopologyUpdate| { &m.closed_chans },
                    |m: &mut GraphTopologyUpdate| { &mut m.closed_chans },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphTopologyUpdate>(
                    "GraphTopologyUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphTopologyUpdate {
        static mut instance: ::protobuf::lazy::Lazy<GraphTopologyUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphTopologyUpdate,
        };
        unsafe {
            instance.get(GraphTopologyUpdate::new)
        }
    }
}

impl ::protobuf::Clear for GraphTopologyUpdate {
    fn clear(&mut self) {
        self.node_updates.clear();
        self.channel_updates.clear();
        self.closed_chans.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphTopologyUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphTopologyUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeUpdate {
    // message fields
    pub addresses: ::protobuf::RepeatedField<::std::string::String>,
    pub identity_key: ::std::string::String,
    pub global_features: ::std::vec::Vec<u8>,
    pub alias: ::std::string::String,
    pub color: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeUpdate {
    fn default() -> &'a NodeUpdate {
        <NodeUpdate as ::protobuf::Message>::default_instance()
    }
}

impl NodeUpdate {
    pub fn new() -> NodeUpdate {
        ::std::default::Default::default()
    }

    // repeated string addresses = 1;


    pub fn get_addresses(&self) -> &[::std::string::String] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // string identity_key = 2;


    pub fn get_identity_key(&self) -> &str {
        &self.identity_key
    }
    pub fn clear_identity_key(&mut self) {
        self.identity_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_key(&mut self, v: ::std::string::String) {
        self.identity_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_key(&mut self) -> &mut ::std::string::String {
        &mut self.identity_key
    }

    // Take field
    pub fn take_identity_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_key, ::std::string::String::new())
    }

    // bytes global_features = 3;


    pub fn get_global_features(&self) -> &[u8] {
        &self.global_features
    }
    pub fn clear_global_features(&mut self) {
        self.global_features.clear();
    }

    // Param is passed by value, moved
    pub fn set_global_features(&mut self, v: ::std::vec::Vec<u8>) {
        self.global_features = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_global_features(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.global_features
    }

    // Take field
    pub fn take_global_features(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.global_features, ::std::vec::Vec::new())
    }

    // string alias = 4;


    pub fn get_alias(&self) -> &str {
        &self.alias
    }
    pub fn clear_alias(&mut self) {
        self.alias.clear();
    }

    // Param is passed by value, moved
    pub fn set_alias(&mut self, v: ::std::string::String) {
        self.alias = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alias(&mut self) -> &mut ::std::string::String {
        &mut self.alias
    }

    // Take field
    pub fn take_alias(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alias, ::std::string::String::new())
    }

    // string color = 5;


    pub fn get_color(&self) -> &str {
        &self.color
    }
    pub fn clear_color(&mut self) {
        self.color.clear();
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: ::std::string::String) {
        self.color = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_color(&mut self) -> &mut ::std::string::String {
        &mut self.color
    }

    // Take field
    pub fn take_color(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.color, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.global_features)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alias)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.color)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.identity_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity_key);
        }
        if !self.global_features.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.global_features);
        }
        if !self.alias.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.alias);
        }
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_string(1, &v)?;
        };
        if !self.identity_key.is_empty() {
            os.write_string(2, &self.identity_key)?;
        }
        if !self.global_features.is_empty() {
            os.write_bytes(3, &self.global_features)?;
        }
        if !self.alias.is_empty() {
            os.write_string(4, &self.alias)?;
        }
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeUpdate {
        NodeUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addresses",
                    |m: &NodeUpdate| { &m.addresses },
                    |m: &mut NodeUpdate| { &mut m.addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identity_key",
                    |m: &NodeUpdate| { &m.identity_key },
                    |m: &mut NodeUpdate| { &mut m.identity_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "global_features",
                    |m: &NodeUpdate| { &m.global_features },
                    |m: &mut NodeUpdate| { &mut m.global_features },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alias",
                    |m: &NodeUpdate| { &m.alias },
                    |m: &mut NodeUpdate| { &mut m.alias },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "color",
                    |m: &NodeUpdate| { &m.color },
                    |m: &mut NodeUpdate| { &mut m.color },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeUpdate>(
                    "NodeUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeUpdate {
        static mut instance: ::protobuf::lazy::Lazy<NodeUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeUpdate,
        };
        unsafe {
            instance.get(NodeUpdate::new)
        }
    }
}

impl ::protobuf::Clear for NodeUpdate {
    fn clear(&mut self) {
        self.addresses.clear();
        self.identity_key.clear();
        self.global_features.clear();
        self.alias.clear();
        self.color.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelEdgeUpdate {
    // message fields
    pub chan_id: u64,
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub capacity: i64,
    pub routing_policy: ::protobuf::SingularPtrField<RoutingPolicy>,
    pub advertising_node: ::std::string::String,
    pub connecting_node: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelEdgeUpdate {
    fn default() -> &'a ChannelEdgeUpdate {
        <ChannelEdgeUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ChannelEdgeUpdate {
    pub fn new() -> ChannelEdgeUpdate {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // .lnrpc.ChannelPoint chan_point = 2;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // int64 capacity = 3;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // .lnrpc.RoutingPolicy routing_policy = 4;


    pub fn get_routing_policy(&self) -> &RoutingPolicy {
        self.routing_policy.as_ref().unwrap_or_else(|| RoutingPolicy::default_instance())
    }
    pub fn clear_routing_policy(&mut self) {
        self.routing_policy.clear();
    }

    pub fn has_routing_policy(&self) -> bool {
        self.routing_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_policy(&mut self, v: RoutingPolicy) {
        self.routing_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routing_policy(&mut self) -> &mut RoutingPolicy {
        if self.routing_policy.is_none() {
            self.routing_policy.set_default();
        }
        self.routing_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_routing_policy(&mut self) -> RoutingPolicy {
        self.routing_policy.take().unwrap_or_else(|| RoutingPolicy::new())
    }

    // string advertising_node = 5;


    pub fn get_advertising_node(&self) -> &str {
        &self.advertising_node
    }
    pub fn clear_advertising_node(&mut self) {
        self.advertising_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_advertising_node(&mut self, v: ::std::string::String) {
        self.advertising_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_advertising_node(&mut self) -> &mut ::std::string::String {
        &mut self.advertising_node
    }

    // Take field
    pub fn take_advertising_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.advertising_node, ::std::string::String::new())
    }

    // string connecting_node = 6;


    pub fn get_connecting_node(&self) -> &str {
        &self.connecting_node
    }
    pub fn clear_connecting_node(&mut self) {
        self.connecting_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_connecting_node(&mut self, v: ::std::string::String) {
        self.connecting_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connecting_node(&mut self) -> &mut ::std::string::String {
        &mut self.connecting_node
    }

    // Take field
    pub fn take_connecting_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.connecting_node, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChannelEdgeUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routing_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routing_policy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.advertising_node)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.connecting_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(3, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routing_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.advertising_node.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.advertising_node);
        }
        if !self.connecting_node.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.connecting_node);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.capacity != 0 {
            os.write_int64(3, self.capacity)?;
        }
        if let Some(ref v) = self.routing_policy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.advertising_node.is_empty() {
            os.write_string(5, &self.advertising_node)?;
        }
        if !self.connecting_node.is_empty() {
            os.write_string(6, &self.connecting_node)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelEdgeUpdate {
        ChannelEdgeUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ChannelEdgeUpdate| { &m.chan_id },
                    |m: &mut ChannelEdgeUpdate| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "chan_point",
                    |m: &ChannelEdgeUpdate| { &m.chan_point },
                    |m: &mut ChannelEdgeUpdate| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ChannelEdgeUpdate| { &m.capacity },
                    |m: &mut ChannelEdgeUpdate| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingPolicy>>(
                    "routing_policy",
                    |m: &ChannelEdgeUpdate| { &m.routing_policy },
                    |m: &mut ChannelEdgeUpdate| { &mut m.routing_policy },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "advertising_node",
                    |m: &ChannelEdgeUpdate| { &m.advertising_node },
                    |m: &mut ChannelEdgeUpdate| { &mut m.advertising_node },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "connecting_node",
                    |m: &ChannelEdgeUpdate| { &m.connecting_node },
                    |m: &mut ChannelEdgeUpdate| { &mut m.connecting_node },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelEdgeUpdate>(
                    "ChannelEdgeUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelEdgeUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ChannelEdgeUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelEdgeUpdate,
        };
        unsafe {
            instance.get(ChannelEdgeUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ChannelEdgeUpdate {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.chan_point.clear();
        self.capacity = 0;
        self.routing_policy.clear();
        self.advertising_node.clear();
        self.connecting_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelEdgeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelEdgeUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClosedChannelUpdate {
    // message fields
    pub chan_id: u64,
    pub capacity: i64,
    pub closed_height: u32,
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClosedChannelUpdate {
    fn default() -> &'a ClosedChannelUpdate {
        <ClosedChannelUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ClosedChannelUpdate {
    pub fn new() -> ClosedChannelUpdate {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // int64 capacity = 2;


    pub fn get_capacity(&self) -> i64 {
        self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: i64) {
        self.capacity = v;
    }

    // uint32 closed_height = 3;


    pub fn get_closed_height(&self) -> u32 {
        self.closed_height
    }
    pub fn clear_closed_height(&mut self) {
        self.closed_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_closed_height(&mut self, v: u32) {
        self.closed_height = v;
    }

    // .lnrpc.ChannelPoint chan_point = 4;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }
}

impl ::protobuf::Message for ClosedChannelUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.capacity = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.closed_height = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.capacity != 0 {
            my_size += ::protobuf::rt::value_size(2, self.capacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.closed_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.closed_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.capacity != 0 {
            os.write_int64(2, self.capacity)?;
        }
        if self.closed_height != 0 {
            os.write_uint32(3, self.closed_height)?;
        }
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClosedChannelUpdate {
        ClosedChannelUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &ClosedChannelUpdate| { &m.chan_id },
                    |m: &mut ClosedChannelUpdate| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "capacity",
                    |m: &ClosedChannelUpdate| { &m.capacity },
                    |m: &mut ClosedChannelUpdate| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "closed_height",
                    |m: &ClosedChannelUpdate| { &m.closed_height },
                    |m: &mut ClosedChannelUpdate| { &mut m.closed_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "chan_point",
                    |m: &ClosedChannelUpdate| { &m.chan_point },
                    |m: &mut ClosedChannelUpdate| { &mut m.chan_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClosedChannelUpdate>(
                    "ClosedChannelUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClosedChannelUpdate {
        static mut instance: ::protobuf::lazy::Lazy<ClosedChannelUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClosedChannelUpdate,
        };
        unsafe {
            instance.get(ClosedChannelUpdate::new)
        }
    }
}

impl ::protobuf::Clear for ClosedChannelUpdate {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.capacity = 0;
        self.closed_height = 0;
        self.chan_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClosedChannelUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClosedChannelUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HopHint {
    // message fields
    pub node_id: ::std::string::String,
    pub chan_id: u64,
    pub fee_base_msat: u32,
    pub fee_proportional_millionths: u32,
    pub cltv_expiry_delta: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HopHint {
    fn default() -> &'a HopHint {
        <HopHint as ::protobuf::Message>::default_instance()
    }
}

impl HopHint {
    pub fn new() -> HopHint {
        ::std::default::Default::default()
    }

    // string node_id = 1;


    pub fn get_node_id(&self) -> &str {
        &self.node_id
    }
    pub fn clear_node_id(&mut self) {
        self.node_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: ::std::string::String) {
        self.node_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_id
    }

    // Take field
    pub fn take_node_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_id, ::std::string::String::new())
    }

    // uint64 chan_id = 2;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // uint32 fee_base_msat = 3;


    pub fn get_fee_base_msat(&self) -> u32 {
        self.fee_base_msat
    }
    pub fn clear_fee_base_msat(&mut self) {
        self.fee_base_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_base_msat(&mut self, v: u32) {
        self.fee_base_msat = v;
    }

    // uint32 fee_proportional_millionths = 4;


    pub fn get_fee_proportional_millionths(&self) -> u32 {
        self.fee_proportional_millionths
    }
    pub fn clear_fee_proportional_millionths(&mut self) {
        self.fee_proportional_millionths = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_proportional_millionths(&mut self, v: u32) {
        self.fee_proportional_millionths = v;
    }

    // uint32 cltv_expiry_delta = 5;


    pub fn get_cltv_expiry_delta(&self) -> u32 {
        self.cltv_expiry_delta
    }
    pub fn clear_cltv_expiry_delta(&mut self) {
        self.cltv_expiry_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry_delta(&mut self, v: u32) {
        self.cltv_expiry_delta = v;
    }
}

impl ::protobuf::Message for HopHint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_base_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fee_proportional_millionths = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cltv_expiry_delta = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.node_id);
        }
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_base_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_base_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_proportional_millionths != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee_proportional_millionths, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cltv_expiry_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.cltv_expiry_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_id.is_empty() {
            os.write_string(1, &self.node_id)?;
        }
        if self.chan_id != 0 {
            os.write_uint64(2, self.chan_id)?;
        }
        if self.fee_base_msat != 0 {
            os.write_uint32(3, self.fee_base_msat)?;
        }
        if self.fee_proportional_millionths != 0 {
            os.write_uint32(4, self.fee_proportional_millionths)?;
        }
        if self.cltv_expiry_delta != 0 {
            os.write_uint32(5, self.cltv_expiry_delta)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HopHint {
        HopHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node_id",
                    |m: &HopHint| { &m.node_id },
                    |m: &mut HopHint| { &mut m.node_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &HopHint| { &m.chan_id },
                    |m: &mut HopHint| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fee_base_msat",
                    |m: &HopHint| { &m.fee_base_msat },
                    |m: &mut HopHint| { &mut m.fee_base_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fee_proportional_millionths",
                    |m: &HopHint| { &m.fee_proportional_millionths },
                    |m: &mut HopHint| { &mut m.fee_proportional_millionths },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cltv_expiry_delta",
                    |m: &HopHint| { &m.cltv_expiry_delta },
                    |m: &mut HopHint| { &mut m.cltv_expiry_delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HopHint>(
                    "HopHint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HopHint {
        static mut instance: ::protobuf::lazy::Lazy<HopHint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HopHint,
        };
        unsafe {
            instance.get(HopHint::new)
        }
    }
}

impl ::protobuf::Clear for HopHint {
    fn clear(&mut self) {
        self.node_id.clear();
        self.chan_id = 0;
        self.fee_base_msat = 0;
        self.fee_proportional_millionths = 0;
        self.cltv_expiry_delta = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HopHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HopHint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteHint {
    // message fields
    pub hop_hints: ::protobuf::RepeatedField<HopHint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteHint {
    fn default() -> &'a RouteHint {
        <RouteHint as ::protobuf::Message>::default_instance()
    }
}

impl RouteHint {
    pub fn new() -> RouteHint {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.HopHint hop_hints = 1;


    pub fn get_hop_hints(&self) -> &[HopHint] {
        &self.hop_hints
    }
    pub fn clear_hop_hints(&mut self) {
        self.hop_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_hop_hints(&mut self, v: ::protobuf::RepeatedField<HopHint>) {
        self.hop_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hop_hints(&mut self) -> &mut ::protobuf::RepeatedField<HopHint> {
        &mut self.hop_hints
    }

    // Take field
    pub fn take_hop_hints(&mut self) -> ::protobuf::RepeatedField<HopHint> {
        ::std::mem::replace(&mut self.hop_hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RouteHint {
    fn is_initialized(&self) -> bool {
        for v in &self.hop_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hop_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hop_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hop_hints {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteHint {
        RouteHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HopHint>>(
                    "hop_hints",
                    |m: &RouteHint| { &m.hop_hints },
                    |m: &mut RouteHint| { &mut m.hop_hints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RouteHint>(
                    "RouteHint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RouteHint {
        static mut instance: ::protobuf::lazy::Lazy<RouteHint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RouteHint,
        };
        unsafe {
            instance.get(RouteHint::new)
        }
    }
}

impl ::protobuf::Clear for RouteHint {
    fn clear(&mut self) {
        self.hop_hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteHint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Invoice {
    // message fields
    pub memo: ::std::string::String,
    pub receipt: ::std::vec::Vec<u8>,
    pub r_preimage: ::std::vec::Vec<u8>,
    pub r_hash: ::std::vec::Vec<u8>,
    pub value: i64,
    pub settled: bool,
    pub creation_date: i64,
    pub settle_date: i64,
    pub payment_request: ::std::string::String,
    pub description_hash: ::std::vec::Vec<u8>,
    pub expiry: i64,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: u64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    pub private: bool,
    pub add_index: u64,
    pub settle_index: u64,
    pub amt_paid: i64,
    pub amt_paid_sat: i64,
    pub amt_paid_msat: i64,
    pub state: Invoice_InvoiceState,
    pub htlcs: ::protobuf::RepeatedField<InvoiceHTLC>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Invoice {
    fn default() -> &'a Invoice {
        <Invoice as ::protobuf::Message>::default_instance()
    }
}

impl Invoice {
    pub fn new() -> Invoice {
        ::std::default::Default::default()
    }

    // string memo = 1;


    pub fn get_memo(&self) -> &str {
        &self.memo
    }
    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::string::String) {
        self.memo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::string::String {
        &mut self.memo
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.memo, ::std::string::String::new())
    }

    // bytes receipt = 2;


    pub fn get_receipt(&self) -> &[u8] {
        &self.receipt
    }
    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ::std::vec::Vec<u8>) {
        self.receipt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receipt
    }

    // Take field
    pub fn take_receipt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receipt, ::std::vec::Vec::new())
    }

    // bytes r_preimage = 3;


    pub fn get_r_preimage(&self) -> &[u8] {
        &self.r_preimage
    }
    pub fn clear_r_preimage(&mut self) {
        self.r_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_preimage(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_preimage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_preimage
    }

    // Take field
    pub fn take_r_preimage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_preimage, ::std::vec::Vec::new())
    }

    // bytes r_hash = 4;


    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }
    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    // int64 value = 5;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // bool settled = 6;


    pub fn get_settled(&self) -> bool {
        self.settled
    }
    pub fn clear_settled(&mut self) {
        self.settled = false;
    }

    // Param is passed by value, moved
    pub fn set_settled(&mut self, v: bool) {
        self.settled = v;
    }

    // int64 creation_date = 7;


    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }
    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    // int64 settle_date = 8;


    pub fn get_settle_date(&self) -> i64 {
        self.settle_date
    }
    pub fn clear_settle_date(&mut self) {
        self.settle_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_date(&mut self, v: i64) {
        self.settle_date = v;
    }

    // string payment_request = 9;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // bytes description_hash = 10;


    pub fn get_description_hash(&self) -> &[u8] {
        &self.description_hash
    }
    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description_hash, ::std::vec::Vec::new())
    }

    // int64 expiry = 11;


    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    // string fallback_addr = 12;


    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }
    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    // uint64 cltv_expiry = 13;


    pub fn get_cltv_expiry(&self) -> u64 {
        self.cltv_expiry
    }
    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: u64) {
        self.cltv_expiry = v;
    }

    // repeated .lnrpc.RouteHint route_hints = 14;


    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }
    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }

    // bool private = 15;


    pub fn get_private(&self) -> bool {
        self.private
    }
    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }

    // uint64 add_index = 16;


    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    // uint64 settle_index = 17;


    pub fn get_settle_index(&self) -> u64 {
        self.settle_index
    }
    pub fn clear_settle_index(&mut self) {
        self.settle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_index(&mut self, v: u64) {
        self.settle_index = v;
    }

    // int64 amt_paid = 18;


    pub fn get_amt_paid(&self) -> i64 {
        self.amt_paid
    }
    pub fn clear_amt_paid(&mut self) {
        self.amt_paid = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid(&mut self, v: i64) {
        self.amt_paid = v;
    }

    // int64 amt_paid_sat = 19;


    pub fn get_amt_paid_sat(&self) -> i64 {
        self.amt_paid_sat
    }
    pub fn clear_amt_paid_sat(&mut self) {
        self.amt_paid_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_sat(&mut self, v: i64) {
        self.amt_paid_sat = v;
    }

    // int64 amt_paid_msat = 20;


    pub fn get_amt_paid_msat(&self) -> i64 {
        self.amt_paid_msat
    }
    pub fn clear_amt_paid_msat(&mut self) {
        self.amt_paid_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_paid_msat(&mut self, v: i64) {
        self.amt_paid_msat = v;
    }

    // .lnrpc.Invoice.InvoiceState state = 21;


    pub fn get_state(&self) -> Invoice_InvoiceState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Invoice_InvoiceState::OPEN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Invoice_InvoiceState) {
        self.state = v;
    }

    // repeated .lnrpc.InvoiceHTLC htlcs = 22;


    pub fn get_htlcs(&self) -> &[InvoiceHTLC] {
        &self.htlcs
    }
    pub fn clear_htlcs(&mut self) {
        self.htlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_htlcs(&mut self, v: ::protobuf::RepeatedField<InvoiceHTLC>) {
        self.htlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_htlcs(&mut self) -> &mut ::protobuf::RepeatedField<InvoiceHTLC> {
        &mut self.htlcs
    }

    // Take field
    pub fn take_htlcs(&mut self) -> ::protobuf::RepeatedField<InvoiceHTLC> {
        ::std::mem::replace(&mut self.htlcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Invoice {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.htlcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.memo)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receipt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_preimage)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.settled = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.settle_date = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description_hash)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cltv_expiry = tmp;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_index = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_sat = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amt_paid_msat = tmp;
                },
                21 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 21, &mut self.unknown_fields)?
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.htlcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.memo.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.memo);
        }
        if !self.receipt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.receipt);
        }
        if !self.r_preimage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.r_preimage);
        }
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.r_hash);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settled != false {
            my_size += 2;
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(7, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_date != 0 {
            my_size += ::protobuf::rt::value_size(8, self.settle_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.payment_request);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.description_hash);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(11, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(13, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.private != false {
            my_size += 2;
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_index != 0 {
            my_size += ::protobuf::rt::value_size(17, self.settle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid != 0 {
            my_size += ::protobuf::rt::value_size(18, self.amt_paid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_sat != 0 {
            my_size += ::protobuf::rt::value_size(19, self.amt_paid_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_paid_msat != 0 {
            my_size += ::protobuf::rt::value_size(20, self.amt_paid_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != Invoice_InvoiceState::OPEN {
            my_size += ::protobuf::rt::enum_size(21, self.state);
        }
        for value in &self.htlcs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.memo.is_empty() {
            os.write_string(1, &self.memo)?;
        }
        if !self.receipt.is_empty() {
            os.write_bytes(2, &self.receipt)?;
        }
        if !self.r_preimage.is_empty() {
            os.write_bytes(3, &self.r_preimage)?;
        }
        if !self.r_hash.is_empty() {
            os.write_bytes(4, &self.r_hash)?;
        }
        if self.value != 0 {
            os.write_int64(5, self.value)?;
        }
        if self.settled != false {
            os.write_bool(6, self.settled)?;
        }
        if self.creation_date != 0 {
            os.write_int64(7, self.creation_date)?;
        }
        if self.settle_date != 0 {
            os.write_int64(8, self.settle_date)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(9, &self.payment_request)?;
        }
        if !self.description_hash.is_empty() {
            os.write_bytes(10, &self.description_hash)?;
        }
        if self.expiry != 0 {
            os.write_int64(11, self.expiry)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(12, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_uint64(13, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.private != false {
            os.write_bool(15, self.private)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        if self.settle_index != 0 {
            os.write_uint64(17, self.settle_index)?;
        }
        if self.amt_paid != 0 {
            os.write_int64(18, self.amt_paid)?;
        }
        if self.amt_paid_sat != 0 {
            os.write_int64(19, self.amt_paid_sat)?;
        }
        if self.amt_paid_msat != 0 {
            os.write_int64(20, self.amt_paid_msat)?;
        }
        if self.state != Invoice_InvoiceState::OPEN {
            os.write_enum(21, self.state.value())?;
        }
        for v in &self.htlcs {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Invoice {
        Invoice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "memo",
                    |m: &Invoice| { &m.memo },
                    |m: &mut Invoice| { &mut m.memo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receipt",
                    |m: &Invoice| { &m.receipt },
                    |m: &mut Invoice| { &mut m.receipt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_preimage",
                    |m: &Invoice| { &m.r_preimage },
                    |m: &mut Invoice| { &mut m.r_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &Invoice| { &m.r_hash },
                    |m: &mut Invoice| { &mut m.r_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &Invoice| { &m.value },
                    |m: &mut Invoice| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "settled",
                    |m: &Invoice| { &m.settled },
                    |m: &mut Invoice| { &mut m.settled },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "creation_date",
                    |m: &Invoice| { &m.creation_date },
                    |m: &mut Invoice| { &mut m.creation_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "settle_date",
                    |m: &Invoice| { &m.settle_date },
                    |m: &mut Invoice| { &mut m.settle_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &Invoice| { &m.payment_request },
                    |m: &mut Invoice| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "description_hash",
                    |m: &Invoice| { &m.description_hash },
                    |m: &mut Invoice| { &mut m.description_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiry",
                    |m: &Invoice| { &m.expiry },
                    |m: &mut Invoice| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fallback_addr",
                    |m: &Invoice| { &m.fallback_addr },
                    |m: &mut Invoice| { &mut m.fallback_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cltv_expiry",
                    |m: &Invoice| { &m.cltv_expiry },
                    |m: &mut Invoice| { &mut m.cltv_expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                    "route_hints",
                    |m: &Invoice| { &m.route_hints },
                    |m: &mut Invoice| { &mut m.route_hints },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "private",
                    |m: &Invoice| { &m.private },
                    |m: &mut Invoice| { &mut m.private },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &Invoice| { &m.add_index },
                    |m: &mut Invoice| { &mut m.add_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settle_index",
                    |m: &Invoice| { &m.settle_index },
                    |m: &mut Invoice| { &mut m.settle_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid",
                    |m: &Invoice| { &m.amt_paid },
                    |m: &mut Invoice| { &mut m.amt_paid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid_sat",
                    |m: &Invoice| { &m.amt_paid_sat },
                    |m: &mut Invoice| { &mut m.amt_paid_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "amt_paid_msat",
                    |m: &Invoice| { &m.amt_paid_msat },
                    |m: &mut Invoice| { &mut m.amt_paid_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Invoice_InvoiceState>>(
                    "state",
                    |m: &Invoice| { &m.state },
                    |m: &mut Invoice| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvoiceHTLC>>(
                    "htlcs",
                    |m: &Invoice| { &m.htlcs },
                    |m: &mut Invoice| { &mut m.htlcs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Invoice>(
                    "Invoice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Invoice {
        static mut instance: ::protobuf::lazy::Lazy<Invoice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Invoice,
        };
        unsafe {
            instance.get(Invoice::new)
        }
    }
}

impl ::protobuf::Clear for Invoice {
    fn clear(&mut self) {
        self.memo.clear();
        self.receipt.clear();
        self.r_preimage.clear();
        self.r_hash.clear();
        self.value = 0;
        self.settled = false;
        self.creation_date = 0;
        self.settle_date = 0;
        self.payment_request.clear();
        self.description_hash.clear();
        self.expiry = 0;
        self.fallback_addr.clear();
        self.cltv_expiry = 0;
        self.route_hints.clear();
        self.private = false;
        self.add_index = 0;
        self.settle_index = 0;
        self.amt_paid = 0;
        self.amt_paid_sat = 0;
        self.amt_paid_msat = 0;
        self.state = Invoice_InvoiceState::OPEN;
        self.htlcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Invoice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Invoice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Invoice_InvoiceState {
    OPEN = 0,
    SETTLED = 1,
    CANCELED = 2,
    ACCEPTED = 3,
}

impl ::protobuf::ProtobufEnum for Invoice_InvoiceState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Invoice_InvoiceState> {
        match value {
            0 => ::std::option::Option::Some(Invoice_InvoiceState::OPEN),
            1 => ::std::option::Option::Some(Invoice_InvoiceState::SETTLED),
            2 => ::std::option::Option::Some(Invoice_InvoiceState::CANCELED),
            3 => ::std::option::Option::Some(Invoice_InvoiceState::ACCEPTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Invoice_InvoiceState] = &[
            Invoice_InvoiceState::OPEN,
            Invoice_InvoiceState::SETTLED,
            Invoice_InvoiceState::CANCELED,
            Invoice_InvoiceState::ACCEPTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Invoice_InvoiceState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Invoice_InvoiceState {
}

impl ::std::default::Default for Invoice_InvoiceState {
    fn default() -> Self {
        Invoice_InvoiceState::OPEN
    }
}

impl ::protobuf::reflect::ProtobufValue for Invoice_InvoiceState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvoiceHTLC {
    // message fields
    pub chan_id: u64,
    pub htlc_index: u64,
    pub amt_msat: u64,
    pub accept_height: i32,
    pub accept_time: i64,
    pub resolve_time: i64,
    pub expiry_height: i32,
    pub state: InvoiceHTLCState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvoiceHTLC {
    fn default() -> &'a InvoiceHTLC {
        <InvoiceHTLC as ::protobuf::Message>::default_instance()
    }
}

impl InvoiceHTLC {
    pub fn new() -> InvoiceHTLC {
        ::std::default::Default::default()
    }

    // uint64 chan_id = 1;


    pub fn get_chan_id(&self) -> u64 {
        self.chan_id
    }
    pub fn clear_chan_id(&mut self) {
        self.chan_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id(&mut self, v: u64) {
        self.chan_id = v;
    }

    // uint64 htlc_index = 2;


    pub fn get_htlc_index(&self) -> u64 {
        self.htlc_index
    }
    pub fn clear_htlc_index(&mut self) {
        self.htlc_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_htlc_index(&mut self, v: u64) {
        self.htlc_index = v;
    }

    // uint64 amt_msat = 3;


    pub fn get_amt_msat(&self) -> u64 {
        self.amt_msat
    }
    pub fn clear_amt_msat(&mut self) {
        self.amt_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_msat(&mut self, v: u64) {
        self.amt_msat = v;
    }

    // int32 accept_height = 4;


    pub fn get_accept_height(&self) -> i32 {
        self.accept_height
    }
    pub fn clear_accept_height(&mut self) {
        self.accept_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_accept_height(&mut self, v: i32) {
        self.accept_height = v;
    }

    // int64 accept_time = 5;


    pub fn get_accept_time(&self) -> i64 {
        self.accept_time
    }
    pub fn clear_accept_time(&mut self) {
        self.accept_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_accept_time(&mut self, v: i64) {
        self.accept_time = v;
    }

    // int64 resolve_time = 6;


    pub fn get_resolve_time(&self) -> i64 {
        self.resolve_time
    }
    pub fn clear_resolve_time(&mut self) {
        self.resolve_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_resolve_time(&mut self, v: i64) {
        self.resolve_time = v;
    }

    // int32 expiry_height = 7;


    pub fn get_expiry_height(&self) -> i32 {
        self.expiry_height
    }
    pub fn clear_expiry_height(&mut self) {
        self.expiry_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry_height(&mut self, v: i32) {
        self.expiry_height = v;
    }

    // .lnrpc.InvoiceHTLCState state = 8;


    pub fn get_state(&self) -> InvoiceHTLCState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = InvoiceHTLCState::ACCEPTED;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: InvoiceHTLCState) {
        self.state = v;
    }
}

impl ::protobuf::Message for InvoiceHTLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.htlc_index = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.accept_height = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.accept_time = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.resolve_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiry_height = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chan_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chan_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.htlc_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.htlc_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amt_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accept_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.accept_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accept_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.accept_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.resolve_time != 0 {
            my_size += ::protobuf::rt::value_size(6, self.resolve_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry_height != 0 {
            my_size += ::protobuf::rt::value_size(7, self.expiry_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.state != InvoiceHTLCState::ACCEPTED {
            my_size += ::protobuf::rt::enum_size(8, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chan_id != 0 {
            os.write_uint64(1, self.chan_id)?;
        }
        if self.htlc_index != 0 {
            os.write_uint64(2, self.htlc_index)?;
        }
        if self.amt_msat != 0 {
            os.write_uint64(3, self.amt_msat)?;
        }
        if self.accept_height != 0 {
            os.write_int32(4, self.accept_height)?;
        }
        if self.accept_time != 0 {
            os.write_int64(5, self.accept_time)?;
        }
        if self.resolve_time != 0 {
            os.write_int64(6, self.resolve_time)?;
        }
        if self.expiry_height != 0 {
            os.write_int32(7, self.expiry_height)?;
        }
        if self.state != InvoiceHTLCState::ACCEPTED {
            os.write_enum(8, self.state.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvoiceHTLC {
        InvoiceHTLC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id",
                    |m: &InvoiceHTLC| { &m.chan_id },
                    |m: &mut InvoiceHTLC| { &mut m.chan_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "htlc_index",
                    |m: &InvoiceHTLC| { &m.htlc_index },
                    |m: &mut InvoiceHTLC| { &mut m.htlc_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amt_msat",
                    |m: &InvoiceHTLC| { &m.amt_msat },
                    |m: &mut InvoiceHTLC| { &mut m.amt_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "accept_height",
                    |m: &InvoiceHTLC| { &m.accept_height },
                    |m: &mut InvoiceHTLC| { &mut m.accept_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "accept_time",
                    |m: &InvoiceHTLC| { &m.accept_time },
                    |m: &mut InvoiceHTLC| { &mut m.accept_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "resolve_time",
                    |m: &InvoiceHTLC| { &m.resolve_time },
                    |m: &mut InvoiceHTLC| { &mut m.resolve_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "expiry_height",
                    |m: &InvoiceHTLC| { &m.expiry_height },
                    |m: &mut InvoiceHTLC| { &mut m.expiry_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InvoiceHTLCState>>(
                    "state",
                    |m: &InvoiceHTLC| { &m.state },
                    |m: &mut InvoiceHTLC| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InvoiceHTLC>(
                    "InvoiceHTLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvoiceHTLC {
        static mut instance: ::protobuf::lazy::Lazy<InvoiceHTLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InvoiceHTLC,
        };
        unsafe {
            instance.get(InvoiceHTLC::new)
        }
    }
}

impl ::protobuf::Clear for InvoiceHTLC {
    fn clear(&mut self) {
        self.chan_id = 0;
        self.htlc_index = 0;
        self.amt_msat = 0;
        self.accept_height = 0;
        self.accept_time = 0;
        self.resolve_time = 0;
        self.expiry_height = 0;
        self.state = InvoiceHTLCState::ACCEPTED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvoiceHTLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceHTLC {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddInvoiceResponse {
    // message fields
    pub r_hash: ::std::vec::Vec<u8>,
    pub payment_request: ::std::string::String,
    pub add_index: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddInvoiceResponse {
    fn default() -> &'a AddInvoiceResponse {
        <AddInvoiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddInvoiceResponse {
    pub fn new() -> AddInvoiceResponse {
        ::std::default::Default::default()
    }

    // bytes r_hash = 1;


    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }
    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }

    // string payment_request = 2;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // uint64 add_index = 16;


    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }
}

impl ::protobuf::Message for AddInvoiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.r_hash);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_request);
        }
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(16, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.r_hash.is_empty() {
            os.write_bytes(1, &self.r_hash)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(2, &self.payment_request)?;
        }
        if self.add_index != 0 {
            os.write_uint64(16, self.add_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddInvoiceResponse {
        AddInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &AddInvoiceResponse| { &m.r_hash },
                    |m: &mut AddInvoiceResponse| { &mut m.r_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &AddInvoiceResponse| { &m.payment_request },
                    |m: &mut AddInvoiceResponse| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &AddInvoiceResponse| { &m.add_index },
                    |m: &mut AddInvoiceResponse| { &mut m.add_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddInvoiceResponse>(
                    "AddInvoiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddInvoiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddInvoiceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddInvoiceResponse,
        };
        unsafe {
            instance.get(AddInvoiceResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddInvoiceResponse {
    fn clear(&mut self) {
        self.r_hash.clear();
        self.payment_request.clear();
        self.add_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PaymentHash {
    // message fields
    pub r_hash_str: ::std::string::String,
    pub r_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentHash {
    fn default() -> &'a PaymentHash {
        <PaymentHash as ::protobuf::Message>::default_instance()
    }
}

impl PaymentHash {
    pub fn new() -> PaymentHash {
        ::std::default::Default::default()
    }

    // string r_hash_str = 1;


    pub fn get_r_hash_str(&self) -> &str {
        &self.r_hash_str
    }
    pub fn clear_r_hash_str(&mut self) {
        self.r_hash_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash_str(&mut self, v: ::std::string::String) {
        self.r_hash_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash_str(&mut self) -> &mut ::std::string::String {
        &mut self.r_hash_str
    }

    // Take field
    pub fn take_r_hash_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.r_hash_str, ::std::string::String::new())
    }

    // bytes r_hash = 2;


    pub fn get_r_hash(&self) -> &[u8] {
        &self.r_hash
    }
    pub fn clear_r_hash(&mut self) {
        self.r_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_r_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.r_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.r_hash
    }

    // Take field
    pub fn take_r_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.r_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PaymentHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.r_hash_str)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.r_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.r_hash_str.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.r_hash_str);
        }
        if !self.r_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.r_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.r_hash_str.is_empty() {
            os.write_string(1, &self.r_hash_str)?;
        }
        if !self.r_hash.is_empty() {
            os.write_bytes(2, &self.r_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentHash {
        PaymentHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "r_hash_str",
                    |m: &PaymentHash| { &m.r_hash_str },
                    |m: &mut PaymentHash| { &mut m.r_hash_str },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "r_hash",
                    |m: &PaymentHash| { &m.r_hash },
                    |m: &mut PaymentHash| { &mut m.r_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PaymentHash>(
                    "PaymentHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PaymentHash {
        static mut instance: ::protobuf::lazy::Lazy<PaymentHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PaymentHash,
        };
        unsafe {
            instance.get(PaymentHash::new)
        }
    }
}

impl ::protobuf::Clear for PaymentHash {
    fn clear(&mut self) {
        self.r_hash_str.clear();
        self.r_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInvoiceRequest {
    // message fields
    pub pending_only: bool,
    pub index_offset: u64,
    pub num_max_invoices: u64,
    pub reversed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInvoiceRequest {
    fn default() -> &'a ListInvoiceRequest {
        <ListInvoiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListInvoiceRequest {
    pub fn new() -> ListInvoiceRequest {
        ::std::default::Default::default()
    }

    // bool pending_only = 1;


    pub fn get_pending_only(&self) -> bool {
        self.pending_only
    }
    pub fn clear_pending_only(&mut self) {
        self.pending_only = false;
    }

    // Param is passed by value, moved
    pub fn set_pending_only(&mut self, v: bool) {
        self.pending_only = v;
    }

    // uint64 index_offset = 4;


    pub fn get_index_offset(&self) -> u64 {
        self.index_offset
    }
    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u64) {
        self.index_offset = v;
    }

    // uint64 num_max_invoices = 5;


    pub fn get_num_max_invoices(&self) -> u64 {
        self.num_max_invoices
    }
    pub fn clear_num_max_invoices(&mut self) {
        self.num_max_invoices = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_max_invoices(&mut self, v: u64) {
        self.num_max_invoices = v;
    }

    // bool reversed = 6;


    pub fn get_reversed(&self) -> bool {
        self.reversed
    }
    pub fn clear_reversed(&mut self) {
        self.reversed = false;
    }

    // Param is passed by value, moved
    pub fn set_reversed(&mut self, v: bool) {
        self.reversed = v;
    }
}

impl ::protobuf::Message for ListInvoiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pending_only = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.index_offset = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_max_invoices = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reversed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.pending_only != false {
            my_size += 2;
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_max_invoices != 0 {
            my_size += ::protobuf::rt::value_size(5, self.num_max_invoices, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reversed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.pending_only != false {
            os.write_bool(1, self.pending_only)?;
        }
        if self.index_offset != 0 {
            os.write_uint64(4, self.index_offset)?;
        }
        if self.num_max_invoices != 0 {
            os.write_uint64(5, self.num_max_invoices)?;
        }
        if self.reversed != false {
            os.write_bool(6, self.reversed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceRequest {
        ListInvoiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pending_only",
                    |m: &ListInvoiceRequest| { &m.pending_only },
                    |m: &mut ListInvoiceRequest| { &mut m.pending_only },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "index_offset",
                    |m: &ListInvoiceRequest| { &m.index_offset },
                    |m: &mut ListInvoiceRequest| { &mut m.index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_max_invoices",
                    |m: &ListInvoiceRequest| { &m.num_max_invoices },
                    |m: &mut ListInvoiceRequest| { &mut m.num_max_invoices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "reversed",
                    |m: &ListInvoiceRequest| { &m.reversed },
                    |m: &mut ListInvoiceRequest| { &mut m.reversed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListInvoiceRequest>(
                    "ListInvoiceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInvoiceRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListInvoiceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInvoiceRequest,
        };
        unsafe {
            instance.get(ListInvoiceRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListInvoiceRequest {
    fn clear(&mut self) {
        self.pending_only = false;
        self.index_offset = 0;
        self.num_max_invoices = 0;
        self.reversed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInvoiceResponse {
    // message fields
    pub invoices: ::protobuf::RepeatedField<Invoice>,
    pub last_index_offset: u64,
    pub first_index_offset: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListInvoiceResponse {
    fn default() -> &'a ListInvoiceResponse {
        <ListInvoiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListInvoiceResponse {
    pub fn new() -> ListInvoiceResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Invoice invoices = 1;


    pub fn get_invoices(&self) -> &[Invoice] {
        &self.invoices
    }
    pub fn clear_invoices(&mut self) {
        self.invoices.clear();
    }

    // Param is passed by value, moved
    pub fn set_invoices(&mut self, v: ::protobuf::RepeatedField<Invoice>) {
        self.invoices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invoices(&mut self) -> &mut ::protobuf::RepeatedField<Invoice> {
        &mut self.invoices
    }

    // Take field
    pub fn take_invoices(&mut self) -> ::protobuf::RepeatedField<Invoice> {
        ::std::mem::replace(&mut self.invoices, ::protobuf::RepeatedField::new())
    }

    // uint64 last_index_offset = 2;


    pub fn get_last_index_offset(&self) -> u64 {
        self.last_index_offset
    }
    pub fn clear_last_index_offset(&mut self) {
        self.last_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_index_offset(&mut self, v: u64) {
        self.last_index_offset = v;
    }

    // uint64 first_index_offset = 3;


    pub fn get_first_index_offset(&self) -> u64 {
        self.first_index_offset
    }
    pub fn clear_first_index_offset(&mut self) {
        self.first_index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_index_offset(&mut self, v: u64) {
        self.first_index_offset = v;
    }
}

impl ::protobuf::Message for ListInvoiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.invoices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.invoices)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.last_index_offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.first_index_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invoices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.last_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.first_index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.first_index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invoices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.last_index_offset != 0 {
            os.write_uint64(2, self.last_index_offset)?;
        }
        if self.first_index_offset != 0 {
            os.write_uint64(3, self.first_index_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInvoiceResponse {
        ListInvoiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Invoice>>(
                    "invoices",
                    |m: &ListInvoiceResponse| { &m.invoices },
                    |m: &mut ListInvoiceResponse| { &mut m.invoices },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "last_index_offset",
                    |m: &ListInvoiceResponse| { &m.last_index_offset },
                    |m: &mut ListInvoiceResponse| { &mut m.last_index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "first_index_offset",
                    |m: &ListInvoiceResponse| { &m.first_index_offset },
                    |m: &mut ListInvoiceResponse| { &mut m.first_index_offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListInvoiceResponse>(
                    "ListInvoiceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInvoiceResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListInvoiceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInvoiceResponse,
        };
        unsafe {
            instance.get(ListInvoiceResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListInvoiceResponse {
    fn clear(&mut self) {
        self.invoices.clear();
        self.last_index_offset = 0;
        self.first_index_offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInvoiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInvoiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvoiceSubscription {
    // message fields
    pub add_index: u64,
    pub settle_index: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvoiceSubscription {
    fn default() -> &'a InvoiceSubscription {
        <InvoiceSubscription as ::protobuf::Message>::default_instance()
    }
}

impl InvoiceSubscription {
    pub fn new() -> InvoiceSubscription {
        ::std::default::Default::default()
    }

    // uint64 add_index = 1;


    pub fn get_add_index(&self) -> u64 {
        self.add_index
    }
    pub fn clear_add_index(&mut self) {
        self.add_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_add_index(&mut self, v: u64) {
        self.add_index = v;
    }

    // uint64 settle_index = 2;


    pub fn get_settle_index(&self) -> u64 {
        self.settle_index
    }
    pub fn clear_settle_index(&mut self) {
        self.settle_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_settle_index(&mut self, v: u64) {
        self.settle_index = v;
    }
}

impl ::protobuf::Message for InvoiceSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.add_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.settle_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.add_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.add_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.settle_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.settle_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.add_index != 0 {
            os.write_uint64(1, self.add_index)?;
        }
        if self.settle_index != 0 {
            os.write_uint64(2, self.settle_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvoiceSubscription {
        InvoiceSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "add_index",
                    |m: &InvoiceSubscription| { &m.add_index },
                    |m: &mut InvoiceSubscription| { &mut m.add_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "settle_index",
                    |m: &InvoiceSubscription| { &m.settle_index },
                    |m: &mut InvoiceSubscription| { &mut m.settle_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InvoiceSubscription>(
                    "InvoiceSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvoiceSubscription {
        static mut instance: ::protobuf::lazy::Lazy<InvoiceSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InvoiceSubscription,
        };
        unsafe {
            instance.get(InvoiceSubscription::new)
        }
    }
}

impl ::protobuf::Clear for InvoiceSubscription {
    fn clear(&mut self) {
        self.add_index = 0;
        self.settle_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvoiceSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Payment {
    // message fields
    pub payment_hash: ::std::string::String,
    pub value: i64,
    pub creation_date: i64,
    pub path: ::protobuf::RepeatedField<::std::string::String>,
    pub fee: i64,
    pub payment_preimage: ::std::string::String,
    pub value_sat: i64,
    pub value_msat: i64,
    pub payment_request: ::std::string::String,
    pub status: Payment_PaymentStatus,
    pub fee_sat: i64,
    pub fee_msat: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Payment {
    fn default() -> &'a Payment {
        <Payment as ::protobuf::Message>::default_instance()
    }
}

impl Payment {
    pub fn new() -> Payment {
        ::std::default::Default::default()
    }

    // string payment_hash = 1;


    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    // int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // int64 creation_date = 3;


    pub fn get_creation_date(&self) -> i64 {
        self.creation_date
    }
    pub fn clear_creation_date(&mut self) {
        self.creation_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_creation_date(&mut self, v: i64) {
        self.creation_date = v;
    }

    // repeated string path = 4;


    pub fn get_path(&self) -> &[::std::string::String] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    // int64 fee = 5;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // string payment_preimage = 6;


    pub fn get_payment_preimage(&self) -> &str {
        &self.payment_preimage
    }
    pub fn clear_payment_preimage(&mut self) {
        self.payment_preimage.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_preimage(&mut self, v: ::std::string::String) {
        self.payment_preimage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_preimage(&mut self) -> &mut ::std::string::String {
        &mut self.payment_preimage
    }

    // Take field
    pub fn take_payment_preimage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_preimage, ::std::string::String::new())
    }

    // int64 value_sat = 7;


    pub fn get_value_sat(&self) -> i64 {
        self.value_sat
    }
    pub fn clear_value_sat(&mut self) {
        self.value_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_sat(&mut self, v: i64) {
        self.value_sat = v;
    }

    // int64 value_msat = 8;


    pub fn get_value_msat(&self) -> i64 {
        self.value_msat
    }
    pub fn clear_value_msat(&mut self) {
        self.value_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_msat(&mut self, v: i64) {
        self.value_msat = v;
    }

    // string payment_request = 9;


    pub fn get_payment_request(&self) -> &str {
        &self.payment_request
    }
    pub fn clear_payment_request(&mut self) {
        self.payment_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_request(&mut self, v: ::std::string::String) {
        self.payment_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_request(&mut self) -> &mut ::std::string::String {
        &mut self.payment_request
    }

    // Take field
    pub fn take_payment_request(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_request, ::std::string::String::new())
    }

    // .lnrpc.Payment.PaymentStatus status = 10;


    pub fn get_status(&self) -> Payment_PaymentStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Payment_PaymentStatus::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Payment_PaymentStatus) {
        self.status = v;
    }

    // int64 fee_sat = 11;


    pub fn get_fee_sat(&self) -> i64 {
        self.fee_sat
    }
    pub fn clear_fee_sat(&mut self) {
        self.fee_sat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_sat(&mut self, v: i64) {
        self.fee_sat = v;
    }

    // int64 fee_msat = 12;


    pub fn get_fee_msat(&self) -> i64 {
        self.fee_msat
    }
    pub fn clear_fee_msat(&mut self) {
        self.fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_msat(&mut self, v: i64) {
        self.fee_msat = v;
    }
}

impl ::protobuf::Message for Payment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_date = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.path)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_preimage)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_sat = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_msat = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_request)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_sat = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.payment_hash);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.creation_date != 0 {
            my_size += ::protobuf::rt::value_size(3, self.creation_date, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.path {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(5, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_preimage.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payment_preimage);
        }
        if self.value_sat != 0 {
            my_size += ::protobuf::rt::value_size(7, self.value_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value_msat != 0 {
            my_size += ::protobuf::rt::value_size(8, self.value_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_request.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.payment_request);
        }
        if self.status != Payment_PaymentStatus::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(10, self.status);
        }
        if self.fee_sat != 0 {
            my_size += ::protobuf::rt::value_size(11, self.fee_sat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(12, self.fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.payment_hash.is_empty() {
            os.write_string(1, &self.payment_hash)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        if self.creation_date != 0 {
            os.write_int64(3, self.creation_date)?;
        }
        for v in &self.path {
            os.write_string(4, &v)?;
        };
        if self.fee != 0 {
            os.write_int64(5, self.fee)?;
        }
        if !self.payment_preimage.is_empty() {
            os.write_string(6, &self.payment_preimage)?;
        }
        if self.value_sat != 0 {
            os.write_int64(7, self.value_sat)?;
        }
        if self.value_msat != 0 {
            os.write_int64(8, self.value_msat)?;
        }
        if !self.payment_request.is_empty() {
            os.write_string(9, &self.payment_request)?;
        }
        if self.status != Payment_PaymentStatus::UNKNOWN {
            os.write_enum(10, self.status.value())?;
        }
        if self.fee_sat != 0 {
            os.write_int64(11, self.fee_sat)?;
        }
        if self.fee_msat != 0 {
            os.write_int64(12, self.fee_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Payment {
        Payment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash",
                    |m: &Payment| { &m.payment_hash },
                    |m: &mut Payment| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &Payment| { &m.value },
                    |m: &mut Payment| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "creation_date",
                    |m: &Payment| { &m.creation_date },
                    |m: &mut Payment| { &mut m.creation_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &Payment| { &m.path },
                    |m: &mut Payment| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &Payment| { &m.fee },
                    |m: &mut Payment| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_preimage",
                    |m: &Payment| { &m.payment_preimage },
                    |m: &mut Payment| { &mut m.payment_preimage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_sat",
                    |m: &Payment| { &m.value_sat },
                    |m: &mut Payment| { &mut m.value_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_msat",
                    |m: &Payment| { &m.value_msat },
                    |m: &mut Payment| { &mut m.value_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_request",
                    |m: &Payment| { &m.payment_request },
                    |m: &mut Payment| { &mut m.payment_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Payment_PaymentStatus>>(
                    "status",
                    |m: &Payment| { &m.status },
                    |m: &mut Payment| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_sat",
                    |m: &Payment| { &m.fee_sat },
                    |m: &mut Payment| { &mut m.fee_sat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_msat",
                    |m: &Payment| { &m.fee_msat },
                    |m: &mut Payment| { &mut m.fee_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Payment>(
                    "Payment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Payment {
        static mut instance: ::protobuf::lazy::Lazy<Payment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Payment,
        };
        unsafe {
            instance.get(Payment::new)
        }
    }
}

impl ::protobuf::Clear for Payment {
    fn clear(&mut self) {
        self.payment_hash.clear();
        self.value = 0;
        self.creation_date = 0;
        self.path.clear();
        self.fee = 0;
        self.payment_preimage.clear();
        self.value_sat = 0;
        self.value_msat = 0;
        self.payment_request.clear();
        self.status = Payment_PaymentStatus::UNKNOWN;
        self.fee_sat = 0;
        self.fee_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Payment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Payment_PaymentStatus {
    UNKNOWN = 0,
    IN_FLIGHT = 1,
    SUCCEEDED = 2,
    FAILED = 3,
}

impl ::protobuf::ProtobufEnum for Payment_PaymentStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Payment_PaymentStatus> {
        match value {
            0 => ::std::option::Option::Some(Payment_PaymentStatus::UNKNOWN),
            1 => ::std::option::Option::Some(Payment_PaymentStatus::IN_FLIGHT),
            2 => ::std::option::Option::Some(Payment_PaymentStatus::SUCCEEDED),
            3 => ::std::option::Option::Some(Payment_PaymentStatus::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Payment_PaymentStatus] = &[
            Payment_PaymentStatus::UNKNOWN,
            Payment_PaymentStatus::IN_FLIGHT,
            Payment_PaymentStatus::SUCCEEDED,
            Payment_PaymentStatus::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Payment_PaymentStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Payment_PaymentStatus {
}

impl ::std::default::Default for Payment_PaymentStatus {
    fn default() -> Self {
        Payment_PaymentStatus::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Payment_PaymentStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPaymentsRequest {
    // message fields
    pub include_incomplete: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPaymentsRequest {
    fn default() -> &'a ListPaymentsRequest {
        <ListPaymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListPaymentsRequest {
    pub fn new() -> ListPaymentsRequest {
        ::std::default::Default::default()
    }

    // bool include_incomplete = 1;


    pub fn get_include_incomplete(&self) -> bool {
        self.include_incomplete
    }
    pub fn clear_include_incomplete(&mut self) {
        self.include_incomplete = false;
    }

    // Param is passed by value, moved
    pub fn set_include_incomplete(&mut self, v: bool) {
        self.include_incomplete = v;
    }
}

impl ::protobuf::Message for ListPaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_incomplete = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.include_incomplete != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.include_incomplete != false {
            os.write_bool(1, self.include_incomplete)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPaymentsRequest {
        ListPaymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "include_incomplete",
                    |m: &ListPaymentsRequest| { &m.include_incomplete },
                    |m: &mut ListPaymentsRequest| { &mut m.include_incomplete },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPaymentsRequest>(
                    "ListPaymentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPaymentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListPaymentsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPaymentsRequest,
        };
        unsafe {
            instance.get(ListPaymentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListPaymentsRequest {
    fn clear(&mut self) {
        self.include_incomplete = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPaymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPaymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListPaymentsResponse {
    // message fields
    pub payments: ::protobuf::RepeatedField<Payment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListPaymentsResponse {
    fn default() -> &'a ListPaymentsResponse {
        <ListPaymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListPaymentsResponse {
    pub fn new() -> ListPaymentsResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.Payment payments = 1;


    pub fn get_payments(&self) -> &[Payment] {
        &self.payments
    }
    pub fn clear_payments(&mut self) {
        self.payments.clear();
    }

    // Param is passed by value, moved
    pub fn set_payments(&mut self, v: ::protobuf::RepeatedField<Payment>) {
        self.payments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_payments(&mut self) -> &mut ::protobuf::RepeatedField<Payment> {
        &mut self.payments
    }

    // Take field
    pub fn take_payments(&mut self) -> ::protobuf::RepeatedField<Payment> {
        ::std::mem::replace(&mut self.payments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListPaymentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.payments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.payments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.payments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.payments {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListPaymentsResponse {
        ListPaymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Payment>>(
                    "payments",
                    |m: &ListPaymentsResponse| { &m.payments },
                    |m: &mut ListPaymentsResponse| { &mut m.payments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListPaymentsResponse>(
                    "ListPaymentsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListPaymentsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListPaymentsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListPaymentsResponse,
        };
        unsafe {
            instance.get(ListPaymentsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListPaymentsResponse {
    fn clear(&mut self) {
        self.payments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListPaymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListPaymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAllPaymentsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAllPaymentsRequest {
    fn default() -> &'a DeleteAllPaymentsRequest {
        <DeleteAllPaymentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAllPaymentsRequest {
    pub fn new() -> DeleteAllPaymentsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteAllPaymentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAllPaymentsRequest {
        DeleteAllPaymentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteAllPaymentsRequest>(
                    "DeleteAllPaymentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteAllPaymentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteAllPaymentsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteAllPaymentsRequest,
        };
        unsafe {
            instance.get(DeleteAllPaymentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteAllPaymentsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAllPaymentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAllPaymentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteAllPaymentsResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteAllPaymentsResponse {
    fn default() -> &'a DeleteAllPaymentsResponse {
        <DeleteAllPaymentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteAllPaymentsResponse {
    pub fn new() -> DeleteAllPaymentsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteAllPaymentsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteAllPaymentsResponse {
        DeleteAllPaymentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteAllPaymentsResponse>(
                    "DeleteAllPaymentsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteAllPaymentsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteAllPaymentsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteAllPaymentsResponse,
        };
        unsafe {
            instance.get(DeleteAllPaymentsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteAllPaymentsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteAllPaymentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteAllPaymentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonChannelRequest {
    // message fields
    pub channel_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonChannelRequest {
    fn default() -> &'a AbandonChannelRequest {
        <AbandonChannelRequest as ::protobuf::Message>::default_instance()
    }
}

impl AbandonChannelRequest {
    pub fn new() -> AbandonChannelRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint channel_point = 1;


    pub fn get_channel_point(&self) -> &ChannelPoint {
        self.channel_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
    pub fn clear_channel_point(&mut self) {
        self.channel_point.clear();
    }

    pub fn has_channel_point(&self) -> bool {
        self.channel_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_point(&mut self, v: ChannelPoint) {
        self.channel_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_point(&mut self) -> &mut ChannelPoint {
        if self.channel_point.is_none() {
            self.channel_point.set_default();
        }
        self.channel_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel_point(&mut self) -> ChannelPoint {
        self.channel_point.take().unwrap_or_else(|| ChannelPoint::new())
    }
}

impl ::protobuf::Message for AbandonChannelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonChannelRequest {
        AbandonChannelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "channel_point",
                    |m: &AbandonChannelRequest| { &m.channel_point },
                    |m: &mut AbandonChannelRequest| { &mut m.channel_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbandonChannelRequest>(
                    "AbandonChannelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbandonChannelRequest {
        static mut instance: ::protobuf::lazy::Lazy<AbandonChannelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonChannelRequest,
        };
        unsafe {
            instance.get(AbandonChannelRequest::new)
        }
    }
}

impl ::protobuf::Clear for AbandonChannelRequest {
    fn clear(&mut self) {
        self.channel_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonChannelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonChannelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonChannelResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonChannelResponse {
    fn default() -> &'a AbandonChannelResponse {
        <AbandonChannelResponse as ::protobuf::Message>::default_instance()
    }
}

impl AbandonChannelResponse {
    pub fn new() -> AbandonChannelResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AbandonChannelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonChannelResponse {
        AbandonChannelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AbandonChannelResponse>(
                    "AbandonChannelResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbandonChannelResponse {
        static mut instance: ::protobuf::lazy::Lazy<AbandonChannelResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonChannelResponse,
        };
        unsafe {
            instance.get(AbandonChannelResponse::new)
        }
    }
}

impl ::protobuf::Clear for AbandonChannelResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonChannelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonChannelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugLevelRequest {
    // message fields
    pub show: bool,
    pub level_spec: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugLevelRequest {
    fn default() -> &'a DebugLevelRequest {
        <DebugLevelRequest as ::protobuf::Message>::default_instance()
    }
}

impl DebugLevelRequest {
    pub fn new() -> DebugLevelRequest {
        ::std::default::Default::default()
    }

    // bool show = 1;


    pub fn get_show(&self) -> bool {
        self.show
    }
    pub fn clear_show(&mut self) {
        self.show = false;
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = v;
    }

    // string level_spec = 2;


    pub fn get_level_spec(&self) -> &str {
        &self.level_spec
    }
    pub fn clear_level_spec(&mut self) {
        self.level_spec.clear();
    }

    // Param is passed by value, moved
    pub fn set_level_spec(&mut self, v: ::std::string::String) {
        self.level_spec = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_spec(&mut self) -> &mut ::std::string::String {
        &mut self.level_spec
    }

    // Take field
    pub fn take_level_spec(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.level_spec, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DebugLevelRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.level_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.show != false {
            my_size += 2;
        }
        if !self.level_spec.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.level_spec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.show != false {
            os.write_bool(1, self.show)?;
        }
        if !self.level_spec.is_empty() {
            os.write_string(2, &self.level_spec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugLevelRequest {
        DebugLevelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show",
                    |m: &DebugLevelRequest| { &m.show },
                    |m: &mut DebugLevelRequest| { &mut m.show },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "level_spec",
                    |m: &DebugLevelRequest| { &m.level_spec },
                    |m: &mut DebugLevelRequest| { &mut m.level_spec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugLevelRequest>(
                    "DebugLevelRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugLevelRequest {
        static mut instance: ::protobuf::lazy::Lazy<DebugLevelRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugLevelRequest,
        };
        unsafe {
            instance.get(DebugLevelRequest::new)
        }
    }
}

impl ::protobuf::Clear for DebugLevelRequest {
    fn clear(&mut self) {
        self.show = false;
        self.level_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugLevelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLevelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugLevelResponse {
    // message fields
    pub sub_systems: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugLevelResponse {
    fn default() -> &'a DebugLevelResponse {
        <DebugLevelResponse as ::protobuf::Message>::default_instance()
    }
}

impl DebugLevelResponse {
    pub fn new() -> DebugLevelResponse {
        ::std::default::Default::default()
    }

    // string sub_systems = 1;


    pub fn get_sub_systems(&self) -> &str {
        &self.sub_systems
    }
    pub fn clear_sub_systems(&mut self) {
        self.sub_systems.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_systems(&mut self, v: ::std::string::String) {
        self.sub_systems = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_systems(&mut self) -> &mut ::std::string::String {
        &mut self.sub_systems
    }

    // Take field
    pub fn take_sub_systems(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sub_systems, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DebugLevelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sub_systems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sub_systems.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sub_systems);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sub_systems.is_empty() {
            os.write_string(1, &self.sub_systems)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugLevelResponse {
        DebugLevelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sub_systems",
                    |m: &DebugLevelResponse| { &m.sub_systems },
                    |m: &mut DebugLevelResponse| { &mut m.sub_systems },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugLevelResponse>(
                    "DebugLevelResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugLevelResponse {
        static mut instance: ::protobuf::lazy::Lazy<DebugLevelResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugLevelResponse,
        };
        unsafe {
            instance.get(DebugLevelResponse::new)
        }
    }
}

impl ::protobuf::Clear for DebugLevelResponse {
    fn clear(&mut self) {
        self.sub_systems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugLevelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLevelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayReqString {
    // message fields
    pub pay_req: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayReqString {
    fn default() -> &'a PayReqString {
        <PayReqString as ::protobuf::Message>::default_instance()
    }
}

impl PayReqString {
    pub fn new() -> PayReqString {
        ::std::default::Default::default()
    }

    // string pay_req = 1;


    pub fn get_pay_req(&self) -> &str {
        &self.pay_req
    }
    pub fn clear_pay_req(&mut self) {
        self.pay_req.clear();
    }

    // Param is passed by value, moved
    pub fn set_pay_req(&mut self, v: ::std::string::String) {
        self.pay_req = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pay_req(&mut self) -> &mut ::std::string::String {
        &mut self.pay_req
    }

    // Take field
    pub fn take_pay_req(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pay_req, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PayReqString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pay_req)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pay_req.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pay_req);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pay_req.is_empty() {
            os.write_string(1, &self.pay_req)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReqString {
        PayReqString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pay_req",
                    |m: &PayReqString| { &m.pay_req },
                    |m: &mut PayReqString| { &mut m.pay_req },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayReqString>(
                    "PayReqString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PayReqString {
        static mut instance: ::protobuf::lazy::Lazy<PayReqString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PayReqString,
        };
        unsafe {
            instance.get(PayReqString::new)
        }
    }
}

impl ::protobuf::Clear for PayReqString {
    fn clear(&mut self) {
        self.pay_req.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReqString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReqString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayReq {
    // message fields
    pub destination: ::std::string::String,
    pub payment_hash: ::std::string::String,
    pub num_satoshis: i64,
    pub timestamp: i64,
    pub expiry: i64,
    pub description: ::std::string::String,
    pub description_hash: ::std::string::String,
    pub fallback_addr: ::std::string::String,
    pub cltv_expiry: i64,
    pub route_hints: ::protobuf::RepeatedField<RouteHint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayReq {
    fn default() -> &'a PayReq {
        <PayReq as ::protobuf::Message>::default_instance()
    }
}

impl PayReq {
    pub fn new() -> PayReq {
        ::std::default::Default::default()
    }

    // string destination = 1;


    pub fn get_destination(&self) -> &str {
        &self.destination
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: ::std::string::String) {
        self.destination = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut ::std::string::String {
        &mut self.destination
    }

    // Take field
    pub fn take_destination(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.destination, ::std::string::String::new())
    }

    // string payment_hash = 2;


    pub fn get_payment_hash(&self) -> &str {
        &self.payment_hash
    }
    pub fn clear_payment_hash(&mut self) {
        self.payment_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_hash(&mut self, v: ::std::string::String) {
        self.payment_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_hash(&mut self) -> &mut ::std::string::String {
        &mut self.payment_hash
    }

    // Take field
    pub fn take_payment_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_hash, ::std::string::String::new())
    }

    // int64 num_satoshis = 3;


    pub fn get_num_satoshis(&self) -> i64 {
        self.num_satoshis
    }
    pub fn clear_num_satoshis(&mut self) {
        self.num_satoshis = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_satoshis(&mut self, v: i64) {
        self.num_satoshis = v;
    }

    // int64 timestamp = 4;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // int64 expiry = 5;


    pub fn get_expiry(&self) -> i64 {
        self.expiry
    }
    pub fn clear_expiry(&mut self) {
        self.expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiry(&mut self, v: i64) {
        self.expiry = v;
    }

    // string description = 6;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string description_hash = 7;


    pub fn get_description_hash(&self) -> &str {
        &self.description_hash
    }
    pub fn clear_description_hash(&mut self) {
        self.description_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_description_hash(&mut self, v: ::std::string::String) {
        self.description_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description_hash(&mut self) -> &mut ::std::string::String {
        &mut self.description_hash
    }

    // Take field
    pub fn take_description_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description_hash, ::std::string::String::new())
    }

    // string fallback_addr = 8;


    pub fn get_fallback_addr(&self) -> &str {
        &self.fallback_addr
    }
    pub fn clear_fallback_addr(&mut self) {
        self.fallback_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_fallback_addr(&mut self, v: ::std::string::String) {
        self.fallback_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallback_addr(&mut self) -> &mut ::std::string::String {
        &mut self.fallback_addr
    }

    // Take field
    pub fn take_fallback_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fallback_addr, ::std::string::String::new())
    }

    // int64 cltv_expiry = 9;


    pub fn get_cltv_expiry(&self) -> i64 {
        self.cltv_expiry
    }
    pub fn clear_cltv_expiry(&mut self) {
        self.cltv_expiry = 0;
    }

    // Param is passed by value, moved
    pub fn set_cltv_expiry(&mut self, v: i64) {
        self.cltv_expiry = v;
    }

    // repeated .lnrpc.RouteHint route_hints = 10;


    pub fn get_route_hints(&self) -> &[RouteHint] {
        &self.route_hints
    }
    pub fn clear_route_hints(&mut self) {
        self.route_hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_route_hints(&mut self, v: ::protobuf::RepeatedField<RouteHint>) {
        self.route_hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_route_hints(&mut self) -> &mut ::protobuf::RepeatedField<RouteHint> {
        &mut self.route_hints
    }

    // Take field
    pub fn take_route_hints(&mut self) -> ::protobuf::RepeatedField<RouteHint> {
        ::std::mem::replace(&mut self.route_hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PayReq {
    fn is_initialized(&self) -> bool {
        for v in &self.route_hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_hash)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_satoshis = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiry = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description_hash)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fallback_addr)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cltv_expiry = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.route_hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.destination.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.destination);
        }
        if !self.payment_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_hash);
        }
        if self.num_satoshis != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_satoshis, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expiry != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        if !self.description_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description_hash);
        }
        if !self.fallback_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.fallback_addr);
        }
        if self.cltv_expiry != 0 {
            my_size += ::protobuf::rt::value_size(9, self.cltv_expiry, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.route_hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.destination.is_empty() {
            os.write_string(1, &self.destination)?;
        }
        if !self.payment_hash.is_empty() {
            os.write_string(2, &self.payment_hash)?;
        }
        if self.num_satoshis != 0 {
            os.write_int64(3, self.num_satoshis)?;
        }
        if self.timestamp != 0 {
            os.write_int64(4, self.timestamp)?;
        }
        if self.expiry != 0 {
            os.write_int64(5, self.expiry)?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        if !self.description_hash.is_empty() {
            os.write_string(7, &self.description_hash)?;
        }
        if !self.fallback_addr.is_empty() {
            os.write_string(8, &self.fallback_addr)?;
        }
        if self.cltv_expiry != 0 {
            os.write_int64(9, self.cltv_expiry)?;
        }
        for v in &self.route_hints {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayReq {
        PayReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "destination",
                    |m: &PayReq| { &m.destination },
                    |m: &mut PayReq| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "payment_hash",
                    |m: &PayReq| { &m.payment_hash },
                    |m: &mut PayReq| { &mut m.payment_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "num_satoshis",
                    |m: &PayReq| { &m.num_satoshis },
                    |m: &mut PayReq| { &mut m.num_satoshis },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &PayReq| { &m.timestamp },
                    |m: &mut PayReq| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "expiry",
                    |m: &PayReq| { &m.expiry },
                    |m: &mut PayReq| { &mut m.expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &PayReq| { &m.description },
                    |m: &mut PayReq| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description_hash",
                    |m: &PayReq| { &m.description_hash },
                    |m: &mut PayReq| { &mut m.description_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fallback_addr",
                    |m: &PayReq| { &m.fallback_addr },
                    |m: &mut PayReq| { &mut m.fallback_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cltv_expiry",
                    |m: &PayReq| { &m.cltv_expiry },
                    |m: &mut PayReq| { &mut m.cltv_expiry },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteHint>>(
                    "route_hints",
                    |m: &PayReq| { &m.route_hints },
                    |m: &mut PayReq| { &mut m.route_hints },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayReq>(
                    "PayReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PayReq {
        static mut instance: ::protobuf::lazy::Lazy<PayReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PayReq,
        };
        unsafe {
            instance.get(PayReq::new)
        }
    }
}

impl ::protobuf::Clear for PayReq {
    fn clear(&mut self) {
        self.destination.clear();
        self.payment_hash.clear();
        self.num_satoshis = 0;
        self.timestamp = 0;
        self.expiry = 0;
        self.description.clear();
        self.description_hash.clear();
        self.fallback_addr.clear();
        self.cltv_expiry = 0;
        self.route_hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeReportRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeReportRequest {
    fn default() -> &'a FeeReportRequest {
        <FeeReportRequest as ::protobuf::Message>::default_instance()
    }
}

impl FeeReportRequest {
    pub fn new() -> FeeReportRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FeeReportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeReportRequest {
        FeeReportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FeeReportRequest>(
                    "FeeReportRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeReportRequest {
        static mut instance: ::protobuf::lazy::Lazy<FeeReportRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeReportRequest,
        };
        unsafe {
            instance.get(FeeReportRequest::new)
        }
    }
}

impl ::protobuf::Clear for FeeReportRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeReportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeReportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelFeeReport {
    // message fields
    pub chan_point: ::std::string::String,
    pub base_fee_msat: i64,
    pub fee_per_mil: i64,
    pub fee_rate: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelFeeReport {
    fn default() -> &'a ChannelFeeReport {
        <ChannelFeeReport as ::protobuf::Message>::default_instance()
    }
}

impl ChannelFeeReport {
    pub fn new() -> ChannelFeeReport {
        ::std::default::Default::default()
    }

    // string chan_point = 1;


    pub fn get_chan_point(&self) -> &str {
        &self.chan_point
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ::std::string::String) {
        self.chan_point = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ::std::string::String {
        &mut self.chan_point
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.chan_point, ::std::string::String::new())
    }

    // int64 base_fee_msat = 2;


    pub fn get_base_fee_msat(&self) -> i64 {
        self.base_fee_msat
    }
    pub fn clear_base_fee_msat(&mut self) {
        self.base_fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_fee_msat(&mut self, v: i64) {
        self.base_fee_msat = v;
    }

    // int64 fee_per_mil = 3;


    pub fn get_fee_per_mil(&self) -> i64 {
        self.fee_per_mil
    }
    pub fn clear_fee_per_mil(&mut self) {
        self.fee_per_mil = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_per_mil(&mut self, v: i64) {
        self.fee_per_mil = v;
    }

    // double fee_rate = 4;


    pub fn get_fee_rate(&self) -> f64 {
        self.fee_rate
    }
    pub fn clear_fee_rate(&mut self) {
        self.fee_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate(&mut self, v: f64) {
        self.fee_rate = v;
    }
}

impl ::protobuf::Message for ChannelFeeReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.chan_point)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_fee_msat = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_per_mil = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.fee_rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.chan_point.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chan_point);
        }
        if self.base_fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(2, self.base_fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_per_mil != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fee_per_mil, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.chan_point.is_empty() {
            os.write_string(1, &self.chan_point)?;
        }
        if self.base_fee_msat != 0 {
            os.write_int64(2, self.base_fee_msat)?;
        }
        if self.fee_per_mil != 0 {
            os.write_int64(3, self.fee_per_mil)?;
        }
        if self.fee_rate != 0. {
            os.write_double(4, self.fee_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelFeeReport {
        ChannelFeeReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "chan_point",
                    |m: &ChannelFeeReport| { &m.chan_point },
                    |m: &mut ChannelFeeReport| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "base_fee_msat",
                    |m: &ChannelFeeReport| { &m.base_fee_msat },
                    |m: &mut ChannelFeeReport| { &mut m.base_fee_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee_per_mil",
                    |m: &ChannelFeeReport| { &m.fee_per_mil },
                    |m: &mut ChannelFeeReport| { &mut m.fee_per_mil },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "fee_rate",
                    |m: &ChannelFeeReport| { &m.fee_rate },
                    |m: &mut ChannelFeeReport| { &mut m.fee_rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelFeeReport>(
                    "ChannelFeeReport",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelFeeReport {
        static mut instance: ::protobuf::lazy::Lazy<ChannelFeeReport> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelFeeReport,
        };
        unsafe {
            instance.get(ChannelFeeReport::new)
        }
    }
}

impl ::protobuf::Clear for ChannelFeeReport {
    fn clear(&mut self) {
        self.chan_point.clear();
        self.base_fee_msat = 0;
        self.fee_per_mil = 0;
        self.fee_rate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelFeeReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelFeeReport {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeReportResponse {
    // message fields
    pub channel_fees: ::protobuf::RepeatedField<ChannelFeeReport>,
    pub day_fee_sum: u64,
    pub week_fee_sum: u64,
    pub month_fee_sum: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FeeReportResponse {
    fn default() -> &'a FeeReportResponse {
        <FeeReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl FeeReportResponse {
    pub fn new() -> FeeReportResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelFeeReport channel_fees = 1;


    pub fn get_channel_fees(&self) -> &[ChannelFeeReport] {
        &self.channel_fees
    }
    pub fn clear_channel_fees(&mut self) {
        self.channel_fees.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_fees(&mut self, v: ::protobuf::RepeatedField<ChannelFeeReport>) {
        self.channel_fees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channel_fees(&mut self) -> &mut ::protobuf::RepeatedField<ChannelFeeReport> {
        &mut self.channel_fees
    }

    // Take field
    pub fn take_channel_fees(&mut self) -> ::protobuf::RepeatedField<ChannelFeeReport> {
        ::std::mem::replace(&mut self.channel_fees, ::protobuf::RepeatedField::new())
    }

    // uint64 day_fee_sum = 2;


    pub fn get_day_fee_sum(&self) -> u64 {
        self.day_fee_sum
    }
    pub fn clear_day_fee_sum(&mut self) {
        self.day_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_day_fee_sum(&mut self, v: u64) {
        self.day_fee_sum = v;
    }

    // uint64 week_fee_sum = 3;


    pub fn get_week_fee_sum(&self) -> u64 {
        self.week_fee_sum
    }
    pub fn clear_week_fee_sum(&mut self) {
        self.week_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_week_fee_sum(&mut self, v: u64) {
        self.week_fee_sum = v;
    }

    // uint64 month_fee_sum = 4;


    pub fn get_month_fee_sum(&self) -> u64 {
        self.month_fee_sum
    }
    pub fn clear_month_fee_sum(&mut self) {
        self.month_fee_sum = 0;
    }

    // Param is passed by value, moved
    pub fn set_month_fee_sum(&mut self, v: u64) {
        self.month_fee_sum = v;
    }
}

impl ::protobuf::Message for FeeReportResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channel_fees {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channel_fees)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.day_fee_sum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.week_fee_sum = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.month_fee_sum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channel_fees {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.day_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.day_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.week_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.week_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.month_fee_sum != 0 {
            my_size += ::protobuf::rt::value_size(4, self.month_fee_sum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channel_fees {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.day_fee_sum != 0 {
            os.write_uint64(2, self.day_fee_sum)?;
        }
        if self.week_fee_sum != 0 {
            os.write_uint64(3, self.week_fee_sum)?;
        }
        if self.month_fee_sum != 0 {
            os.write_uint64(4, self.month_fee_sum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeReportResponse {
        FeeReportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelFeeReport>>(
                    "channel_fees",
                    |m: &FeeReportResponse| { &m.channel_fees },
                    |m: &mut FeeReportResponse| { &mut m.channel_fees },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "day_fee_sum",
                    |m: &FeeReportResponse| { &m.day_fee_sum },
                    |m: &mut FeeReportResponse| { &mut m.day_fee_sum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "week_fee_sum",
                    |m: &FeeReportResponse| { &m.week_fee_sum },
                    |m: &mut FeeReportResponse| { &mut m.week_fee_sum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "month_fee_sum",
                    |m: &FeeReportResponse| { &m.month_fee_sum },
                    |m: &mut FeeReportResponse| { &mut m.month_fee_sum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeeReportResponse>(
                    "FeeReportResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeReportResponse {
        static mut instance: ::protobuf::lazy::Lazy<FeeReportResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeReportResponse,
        };
        unsafe {
            instance.get(FeeReportResponse::new)
        }
    }
}

impl ::protobuf::Clear for FeeReportResponse {
    fn clear(&mut self) {
        self.channel_fees.clear();
        self.day_fee_sum = 0;
        self.week_fee_sum = 0;
        self.month_fee_sum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeReportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PolicyUpdateRequest {
    // message fields
    pub base_fee_msat: i64,
    pub fee_rate: f64,
    pub time_lock_delta: u32,
    // message oneof groups
    pub scope: ::std::option::Option<PolicyUpdateRequest_oneof_scope>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PolicyUpdateRequest {
    fn default() -> &'a PolicyUpdateRequest {
        <PolicyUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum PolicyUpdateRequest_oneof_scope {
    global(bool),
    chan_point(ChannelPoint),
}

impl PolicyUpdateRequest {
    pub fn new() -> PolicyUpdateRequest {
        ::std::default::Default::default()
    }

    // bool global = 1;


    pub fn get_global(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(v)) => v,
            _ => false,
        }
    }
    pub fn clear_global(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_global(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_global(&mut self, v: bool) {
        self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(v))
    }

    // .lnrpc.ChannelPoint chan_point = 2;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ref v)) => v,
            _ => ChannelPoint::default_instance(),
        }
    }
    pub fn clear_chan_point(&mut self) {
        self.scope = ::std::option::Option::None;
    }

    pub fn has_chan_point(&self) -> bool {
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if let ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(_)) = self.scope {
        } else {
            self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ChannelPoint::new()));
        }
        match self.scope {
            ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        if self.has_chan_point() {
            match self.scope.take() {
                ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelPoint::new()
        }
    }

    // int64 base_fee_msat = 3;


    pub fn get_base_fee_msat(&self) -> i64 {
        self.base_fee_msat
    }
    pub fn clear_base_fee_msat(&mut self) {
        self.base_fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_fee_msat(&mut self, v: i64) {
        self.base_fee_msat = v;
    }

    // double fee_rate = 4;


    pub fn get_fee_rate(&self) -> f64 {
        self.fee_rate
    }
    pub fn clear_fee_rate(&mut self) {
        self.fee_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_fee_rate(&mut self, v: f64) {
        self.fee_rate = v;
    }

    // uint32 time_lock_delta = 5;


    pub fn get_time_lock_delta(&self) -> u32 {
        self.time_lock_delta
    }
    pub fn clear_time_lock_delta(&mut self) {
        self.time_lock_delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_lock_delta(&mut self, v: u32) {
        self.time_lock_delta = v;
    }
}

impl ::protobuf::Message for PolicyUpdateRequest {
    fn is_initialized(&self) -> bool {
        if let Some(PolicyUpdateRequest_oneof_scope::chan_point(ref v)) = self.scope {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::global(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scope = ::std::option::Option::Some(PolicyUpdateRequest_oneof_scope::chan_point(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_fee_msat = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.fee_rate = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_lock_delta = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.base_fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(3, self.base_fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_rate != 0. {
            my_size += 9;
        }
        if self.time_lock_delta != 0 {
            my_size += ::protobuf::rt::value_size(5, self.time_lock_delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &PolicyUpdateRequest_oneof_scope::global(v) => {
                    my_size += 2;
                },
                &PolicyUpdateRequest_oneof_scope::chan_point(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.base_fee_msat != 0 {
            os.write_int64(3, self.base_fee_msat)?;
        }
        if self.fee_rate != 0. {
            os.write_double(4, self.fee_rate)?;
        }
        if self.time_lock_delta != 0 {
            os.write_uint32(5, self.time_lock_delta)?;
        }
        if let ::std::option::Option::Some(ref v) = self.scope {
            match v {
                &PolicyUpdateRequest_oneof_scope::global(v) => {
                    os.write_bool(1, v)?;
                },
                &PolicyUpdateRequest_oneof_scope::chan_point(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyUpdateRequest {
        PolicyUpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                    "global",
                    PolicyUpdateRequest::has_global,
                    PolicyUpdateRequest::get_global,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelPoint>(
                    "chan_point",
                    PolicyUpdateRequest::has_chan_point,
                    PolicyUpdateRequest::get_chan_point,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "base_fee_msat",
                    |m: &PolicyUpdateRequest| { &m.base_fee_msat },
                    |m: &mut PolicyUpdateRequest| { &mut m.base_fee_msat },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "fee_rate",
                    |m: &PolicyUpdateRequest| { &m.fee_rate },
                    |m: &mut PolicyUpdateRequest| { &mut m.fee_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "time_lock_delta",
                    |m: &PolicyUpdateRequest| { &m.time_lock_delta },
                    |m: &mut PolicyUpdateRequest| { &mut m.time_lock_delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PolicyUpdateRequest>(
                    "PolicyUpdateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PolicyUpdateRequest {
        static mut instance: ::protobuf::lazy::Lazy<PolicyUpdateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PolicyUpdateRequest,
        };
        unsafe {
            instance.get(PolicyUpdateRequest::new)
        }
    }
}

impl ::protobuf::Clear for PolicyUpdateRequest {
    fn clear(&mut self) {
        self.scope = ::std::option::Option::None;
        self.scope = ::std::option::Option::None;
        self.base_fee_msat = 0;
        self.fee_rate = 0.;
        self.time_lock_delta = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PolicyUpdateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PolicyUpdateResponse {
    fn default() -> &'a PolicyUpdateResponse {
        <PolicyUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl PolicyUpdateResponse {
    pub fn new() -> PolicyUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PolicyUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyUpdateResponse {
        PolicyUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<PolicyUpdateResponse>(
                    "PolicyUpdateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PolicyUpdateResponse {
        static mut instance: ::protobuf::lazy::Lazy<PolicyUpdateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PolicyUpdateResponse,
        };
        unsafe {
            instance.get(PolicyUpdateResponse::new)
        }
    }
}

impl ::protobuf::Clear for PolicyUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingHistoryRequest {
    // message fields
    pub start_time: u64,
    pub end_time: u64,
    pub index_offset: u32,
    pub num_max_events: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingHistoryRequest {
    fn default() -> &'a ForwardingHistoryRequest {
        <ForwardingHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingHistoryRequest {
    pub fn new() -> ForwardingHistoryRequest {
        ::std::default::Default::default()
    }

    // uint64 start_time = 1;


    pub fn get_start_time(&self) -> u64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u64) {
        self.start_time = v;
    }

    // uint64 end_time = 2;


    pub fn get_end_time(&self) -> u64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u64) {
        self.end_time = v;
    }

    // uint32 index_offset = 3;


    pub fn get_index_offset(&self) -> u32 {
        self.index_offset
    }
    pub fn clear_index_offset(&mut self) {
        self.index_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_offset(&mut self, v: u32) {
        self.index_offset = v;
    }

    // uint32 num_max_events = 4;


    pub fn get_num_max_events(&self) -> u32 {
        self.num_max_events
    }
    pub fn clear_num_max_events(&mut self) {
        self.num_max_events = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_max_events(&mut self, v: u32) {
        self.num_max_events = v;
    }
}

impl ::protobuf::Message for ForwardingHistoryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_time = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.end_time = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index_offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_max_events = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index_offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.index_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_max_events != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_max_events, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_time != 0 {
            os.write_uint64(1, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_uint64(2, self.end_time)?;
        }
        if self.index_offset != 0 {
            os.write_uint32(3, self.index_offset)?;
        }
        if self.num_max_events != 0 {
            os.write_uint32(4, self.num_max_events)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingHistoryRequest {
        ForwardingHistoryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_time",
                    |m: &ForwardingHistoryRequest| { &m.start_time },
                    |m: &mut ForwardingHistoryRequest| { &mut m.start_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "end_time",
                    |m: &ForwardingHistoryRequest| { &m.end_time },
                    |m: &mut ForwardingHistoryRequest| { &mut m.end_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "index_offset",
                    |m: &ForwardingHistoryRequest| { &m.index_offset },
                    |m: &mut ForwardingHistoryRequest| { &mut m.index_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_max_events",
                    |m: &ForwardingHistoryRequest| { &m.num_max_events },
                    |m: &mut ForwardingHistoryRequest| { &mut m.num_max_events },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForwardingHistoryRequest>(
                    "ForwardingHistoryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ForwardingHistoryRequest {
        static mut instance: ::protobuf::lazy::Lazy<ForwardingHistoryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ForwardingHistoryRequest,
        };
        unsafe {
            instance.get(ForwardingHistoryRequest::new)
        }
    }
}

impl ::protobuf::Clear for ForwardingHistoryRequest {
    fn clear(&mut self) {
        self.start_time = 0;
        self.end_time = 0;
        self.index_offset = 0;
        self.num_max_events = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingHistoryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingEvent {
    // message fields
    pub timestamp: u64,
    pub chan_id_in: u64,
    pub chan_id_out: u64,
    pub amt_in: u64,
    pub amt_out: u64,
    pub fee: u64,
    pub fee_msat: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingEvent {
    fn default() -> &'a ForwardingEvent {
        <ForwardingEvent as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingEvent {
    pub fn new() -> ForwardingEvent {
        ::std::default::Default::default()
    }

    // uint64 timestamp = 1;


    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    // uint64 chan_id_in = 2;


    pub fn get_chan_id_in(&self) -> u64 {
        self.chan_id_in
    }
    pub fn clear_chan_id_in(&mut self) {
        self.chan_id_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id_in(&mut self, v: u64) {
        self.chan_id_in = v;
    }

    // uint64 chan_id_out = 4;


    pub fn get_chan_id_out(&self) -> u64 {
        self.chan_id_out
    }
    pub fn clear_chan_id_out(&mut self) {
        self.chan_id_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_chan_id_out(&mut self, v: u64) {
        self.chan_id_out = v;
    }

    // uint64 amt_in = 5;


    pub fn get_amt_in(&self) -> u64 {
        self.amt_in
    }
    pub fn clear_amt_in(&mut self) {
        self.amt_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_in(&mut self, v: u64) {
        self.amt_in = v;
    }

    // uint64 amt_out = 6;


    pub fn get_amt_out(&self) -> u64 {
        self.amt_out
    }
    pub fn clear_amt_out(&mut self) {
        self.amt_out = 0;
    }

    // Param is passed by value, moved
    pub fn set_amt_out(&mut self, v: u64) {
        self.amt_out = v;
    }

    // uint64 fee = 7;


    pub fn get_fee(&self) -> u64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = v;
    }

    // uint64 fee_msat = 8;


    pub fn get_fee_msat(&self) -> u64 {
        self.fee_msat
    }
    pub fn clear_fee_msat(&mut self) {
        self.fee_msat = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_msat(&mut self, v: u64) {
        self.fee_msat = v;
    }
}

impl ::protobuf::Message for ForwardingEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id_in = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chan_id_out = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_in = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amt_out = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee_msat = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_id_in != 0 {
            my_size += ::protobuf::rt::value_size(2, self.chan_id_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chan_id_out != 0 {
            my_size += ::protobuf::rt::value_size(4, self.chan_id_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_in != 0 {
            my_size += ::protobuf::rt::value_size(5, self.amt_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amt_out != 0 {
            my_size += ::protobuf::rt::value_size(6, self.amt_out, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(7, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_msat != 0 {
            my_size += ::protobuf::rt::value_size(8, self.fee_msat, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_uint64(1, self.timestamp)?;
        }
        if self.chan_id_in != 0 {
            os.write_uint64(2, self.chan_id_in)?;
        }
        if self.chan_id_out != 0 {
            os.write_uint64(4, self.chan_id_out)?;
        }
        if self.amt_in != 0 {
            os.write_uint64(5, self.amt_in)?;
        }
        if self.amt_out != 0 {
            os.write_uint64(6, self.amt_out)?;
        }
        if self.fee != 0 {
            os.write_uint64(7, self.fee)?;
        }
        if self.fee_msat != 0 {
            os.write_uint64(8, self.fee_msat)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingEvent {
        ForwardingEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &ForwardingEvent| { &m.timestamp },
                    |m: &mut ForwardingEvent| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id_in",
                    |m: &ForwardingEvent| { &m.chan_id_in },
                    |m: &mut ForwardingEvent| { &mut m.chan_id_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chan_id_out",
                    |m: &ForwardingEvent| { &m.chan_id_out },
                    |m: &mut ForwardingEvent| { &mut m.chan_id_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amt_in",
                    |m: &ForwardingEvent| { &m.amt_in },
                    |m: &mut ForwardingEvent| { &mut m.amt_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amt_out",
                    |m: &ForwardingEvent| { &m.amt_out },
                    |m: &mut ForwardingEvent| { &mut m.amt_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &ForwardingEvent| { &m.fee },
                    |m: &mut ForwardingEvent| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee_msat",
                    |m: &ForwardingEvent| { &m.fee_msat },
                    |m: &mut ForwardingEvent| { &mut m.fee_msat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForwardingEvent>(
                    "ForwardingEvent",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ForwardingEvent {
        static mut instance: ::protobuf::lazy::Lazy<ForwardingEvent> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ForwardingEvent,
        };
        unsafe {
            instance.get(ForwardingEvent::new)
        }
    }
}

impl ::protobuf::Clear for ForwardingEvent {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.chan_id_in = 0;
        self.chan_id_out = 0;
        self.amt_in = 0;
        self.amt_out = 0;
        self.fee = 0;
        self.fee_msat = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ForwardingHistoryResponse {
    // message fields
    pub forwarding_events: ::protobuf::RepeatedField<ForwardingEvent>,
    pub last_offset_index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ForwardingHistoryResponse {
    fn default() -> &'a ForwardingHistoryResponse {
        <ForwardingHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl ForwardingHistoryResponse {
    pub fn new() -> ForwardingHistoryResponse {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ForwardingEvent forwarding_events = 1;


    pub fn get_forwarding_events(&self) -> &[ForwardingEvent] {
        &self.forwarding_events
    }
    pub fn clear_forwarding_events(&mut self) {
        self.forwarding_events.clear();
    }

    // Param is passed by value, moved
    pub fn set_forwarding_events(&mut self, v: ::protobuf::RepeatedField<ForwardingEvent>) {
        self.forwarding_events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_forwarding_events(&mut self) -> &mut ::protobuf::RepeatedField<ForwardingEvent> {
        &mut self.forwarding_events
    }

    // Take field
    pub fn take_forwarding_events(&mut self) -> ::protobuf::RepeatedField<ForwardingEvent> {
        ::std::mem::replace(&mut self.forwarding_events, ::protobuf::RepeatedField::new())
    }

    // uint32 last_offset_index = 2;


    pub fn get_last_offset_index(&self) -> u32 {
        self.last_offset_index
    }
    pub fn clear_last_offset_index(&mut self) {
        self.last_offset_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_offset_index(&mut self, v: u32) {
        self.last_offset_index = v;
    }
}

impl ::protobuf::Message for ForwardingHistoryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.forwarding_events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.forwarding_events)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_offset_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.forwarding_events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.last_offset_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.last_offset_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.forwarding_events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.last_offset_index != 0 {
            os.write_uint32(2, self.last_offset_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ForwardingHistoryResponse {
        ForwardingHistoryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ForwardingEvent>>(
                    "forwarding_events",
                    |m: &ForwardingHistoryResponse| { &m.forwarding_events },
                    |m: &mut ForwardingHistoryResponse| { &mut m.forwarding_events },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "last_offset_index",
                    |m: &ForwardingHistoryResponse| { &m.last_offset_index },
                    |m: &mut ForwardingHistoryResponse| { &mut m.last_offset_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ForwardingHistoryResponse>(
                    "ForwardingHistoryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ForwardingHistoryResponse {
        static mut instance: ::protobuf::lazy::Lazy<ForwardingHistoryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ForwardingHistoryResponse,
        };
        unsafe {
            instance.get(ForwardingHistoryResponse::new)
        }
    }
}

impl ::protobuf::Clear for ForwardingHistoryResponse {
    fn clear(&mut self) {
        self.forwarding_events.clear();
        self.last_offset_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ForwardingHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ForwardingHistoryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExportChannelBackupRequest {
    // message fields
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportChannelBackupRequest {
    fn default() -> &'a ExportChannelBackupRequest {
        <ExportChannelBackupRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExportChannelBackupRequest {
    pub fn new() -> ExportChannelBackupRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint chan_point = 1;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }
}

impl ::protobuf::Message for ExportChannelBackupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportChannelBackupRequest {
        ExportChannelBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "chan_point",
                    |m: &ExportChannelBackupRequest| { &m.chan_point },
                    |m: &mut ExportChannelBackupRequest| { &mut m.chan_point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExportChannelBackupRequest>(
                    "ExportChannelBackupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExportChannelBackupRequest {
        static mut instance: ::protobuf::lazy::Lazy<ExportChannelBackupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExportChannelBackupRequest,
        };
        unsafe {
            instance.get(ExportChannelBackupRequest::new)
        }
    }
}

impl ::protobuf::Clear for ExportChannelBackupRequest {
    fn clear(&mut self) {
        self.chan_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportChannelBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportChannelBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelBackup {
    // message fields
    pub chan_point: ::protobuf::SingularPtrField<ChannelPoint>,
    pub chan_backup: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBackup {
    fn default() -> &'a ChannelBackup {
        <ChannelBackup as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBackup {
    pub fn new() -> ChannelBackup {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelPoint chan_point = 1;


    pub fn get_chan_point(&self) -> &ChannelPoint {
        self.chan_point.as_ref().unwrap_or_else(|| ChannelPoint::default_instance())
    }
    pub fn clear_chan_point(&mut self) {
        self.chan_point.clear();
    }

    pub fn has_chan_point(&self) -> bool {
        self.chan_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chan_point(&mut self, v: ChannelPoint) {
        self.chan_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_point(&mut self) -> &mut ChannelPoint {
        if self.chan_point.is_none() {
            self.chan_point.set_default();
        }
        self.chan_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_chan_point(&mut self) -> ChannelPoint {
        self.chan_point.take().unwrap_or_else(|| ChannelPoint::new())
    }

    // bytes chan_backup = 2;


    pub fn get_chan_backup(&self) -> &[u8] {
        &self.chan_backup
    }
    pub fn clear_chan_backup(&mut self) {
        self.chan_backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_backup(&mut self, v: ::std::vec::Vec<u8>) {
        self.chan_backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chan_backup(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.chan_backup
    }

    // Take field
    pub fn take_chan_backup(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.chan_backup, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ChannelBackup {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.chan_point)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.chan_backup)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.chan_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.chan_backup.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.chan_backup);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.chan_point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.chan_backup.is_empty() {
            os.write_bytes(2, &self.chan_backup)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBackup {
        ChannelBackup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "chan_point",
                    |m: &ChannelBackup| { &m.chan_point },
                    |m: &mut ChannelBackup| { &mut m.chan_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "chan_backup",
                    |m: &ChannelBackup| { &m.chan_backup },
                    |m: &mut ChannelBackup| { &mut m.chan_backup },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelBackup>(
                    "ChannelBackup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelBackup {
        static mut instance: ::protobuf::lazy::Lazy<ChannelBackup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelBackup,
        };
        unsafe {
            instance.get(ChannelBackup::new)
        }
    }
}

impl ::protobuf::Clear for ChannelBackup {
    fn clear(&mut self) {
        self.chan_point.clear();
        self.chan_backup.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBackup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBackup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiChanBackup {
    // message fields
    pub chan_points: ::protobuf::RepeatedField<ChannelPoint>,
    pub multi_chan_backup: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiChanBackup {
    fn default() -> &'a MultiChanBackup {
        <MultiChanBackup as ::protobuf::Message>::default_instance()
    }
}

impl MultiChanBackup {
    pub fn new() -> MultiChanBackup {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelPoint chan_points = 1;


    pub fn get_chan_points(&self) -> &[ChannelPoint] {
        &self.chan_points
    }
    pub fn clear_chan_points(&mut self) {
        self.chan_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_points(&mut self, v: ::protobuf::RepeatedField<ChannelPoint>) {
        self.chan_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chan_points(&mut self) -> &mut ::protobuf::RepeatedField<ChannelPoint> {
        &mut self.chan_points
    }

    // Take field
    pub fn take_chan_points(&mut self) -> ::protobuf::RepeatedField<ChannelPoint> {
        ::std::mem::replace(&mut self.chan_points, ::protobuf::RepeatedField::new())
    }

    // bytes multi_chan_backup = 2;


    pub fn get_multi_chan_backup(&self) -> &[u8] {
        &self.multi_chan_backup
    }
    pub fn clear_multi_chan_backup(&mut self) {
        self.multi_chan_backup.clear();
    }

    // Param is passed by value, moved
    pub fn set_multi_chan_backup(&mut self, v: ::std::vec::Vec<u8>) {
        self.multi_chan_backup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multi_chan_backup(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.multi_chan_backup
    }

    // Take field
    pub fn take_multi_chan_backup(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.multi_chan_backup, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MultiChanBackup {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chan_points)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.multi_chan_backup)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chan_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.multi_chan_backup.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.multi_chan_backup);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chan_points {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.multi_chan_backup.is_empty() {
            os.write_bytes(2, &self.multi_chan_backup)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiChanBackup {
        MultiChanBackup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelPoint>>(
                    "chan_points",
                    |m: &MultiChanBackup| { &m.chan_points },
                    |m: &mut MultiChanBackup| { &mut m.chan_points },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "multi_chan_backup",
                    |m: &MultiChanBackup| { &m.multi_chan_backup },
                    |m: &mut MultiChanBackup| { &mut m.multi_chan_backup },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MultiChanBackup>(
                    "MultiChanBackup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MultiChanBackup {
        static mut instance: ::protobuf::lazy::Lazy<MultiChanBackup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MultiChanBackup,
        };
        unsafe {
            instance.get(MultiChanBackup::new)
        }
    }
}

impl ::protobuf::Clear for MultiChanBackup {
    fn clear(&mut self) {
        self.chan_points.clear();
        self.multi_chan_backup.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiChanBackup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiChanBackup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChanBackupExportRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChanBackupExportRequest {
    fn default() -> &'a ChanBackupExportRequest {
        <ChanBackupExportRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChanBackupExportRequest {
    pub fn new() -> ChanBackupExportRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChanBackupExportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanBackupExportRequest {
        ChanBackupExportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ChanBackupExportRequest>(
                    "ChanBackupExportRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChanBackupExportRequest {
        static mut instance: ::protobuf::lazy::Lazy<ChanBackupExportRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChanBackupExportRequest,
        };
        unsafe {
            instance.get(ChanBackupExportRequest::new)
        }
    }
}

impl ::protobuf::Clear for ChanBackupExportRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanBackupExportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanBackupExportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChanBackupSnapshot {
    // message fields
    pub single_chan_backups: ::protobuf::SingularPtrField<ChannelBackups>,
    pub multi_chan_backup: ::protobuf::SingularPtrField<MultiChanBackup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChanBackupSnapshot {
    fn default() -> &'a ChanBackupSnapshot {
        <ChanBackupSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl ChanBackupSnapshot {
    pub fn new() -> ChanBackupSnapshot {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelBackups single_chan_backups = 1;


    pub fn get_single_chan_backups(&self) -> &ChannelBackups {
        self.single_chan_backups.as_ref().unwrap_or_else(|| ChannelBackups::default_instance())
    }
    pub fn clear_single_chan_backups(&mut self) {
        self.single_chan_backups.clear();
    }

    pub fn has_single_chan_backups(&self) -> bool {
        self.single_chan_backups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_single_chan_backups(&mut self, v: ChannelBackups) {
        self.single_chan_backups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_single_chan_backups(&mut self) -> &mut ChannelBackups {
        if self.single_chan_backups.is_none() {
            self.single_chan_backups.set_default();
        }
        self.single_chan_backups.as_mut().unwrap()
    }

    // Take field
    pub fn take_single_chan_backups(&mut self) -> ChannelBackups {
        self.single_chan_backups.take().unwrap_or_else(|| ChannelBackups::new())
    }

    // .lnrpc.MultiChanBackup multi_chan_backup = 2;


    pub fn get_multi_chan_backup(&self) -> &MultiChanBackup {
        self.multi_chan_backup.as_ref().unwrap_or_else(|| MultiChanBackup::default_instance())
    }
    pub fn clear_multi_chan_backup(&mut self) {
        self.multi_chan_backup.clear();
    }

    pub fn has_multi_chan_backup(&self) -> bool {
        self.multi_chan_backup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multi_chan_backup(&mut self, v: MultiChanBackup) {
        self.multi_chan_backup = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multi_chan_backup(&mut self) -> &mut MultiChanBackup {
        if self.multi_chan_backup.is_none() {
            self.multi_chan_backup.set_default();
        }
        self.multi_chan_backup.as_mut().unwrap()
    }

    // Take field
    pub fn take_multi_chan_backup(&mut self) -> MultiChanBackup {
        self.multi_chan_backup.take().unwrap_or_else(|| MultiChanBackup::new())
    }
}

impl ::protobuf::Message for ChanBackupSnapshot {
    fn is_initialized(&self) -> bool {
        for v in &self.single_chan_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multi_chan_backup {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.single_chan_backups)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multi_chan_backup)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.single_chan_backups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.multi_chan_backup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.single_chan_backups.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.multi_chan_backup.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChanBackupSnapshot {
        ChanBackupSnapshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelBackups>>(
                    "single_chan_backups",
                    |m: &ChanBackupSnapshot| { &m.single_chan_backups },
                    |m: &mut ChanBackupSnapshot| { &mut m.single_chan_backups },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MultiChanBackup>>(
                    "multi_chan_backup",
                    |m: &ChanBackupSnapshot| { &m.multi_chan_backup },
                    |m: &mut ChanBackupSnapshot| { &mut m.multi_chan_backup },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChanBackupSnapshot>(
                    "ChanBackupSnapshot",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChanBackupSnapshot {
        static mut instance: ::protobuf::lazy::Lazy<ChanBackupSnapshot> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChanBackupSnapshot,
        };
        unsafe {
            instance.get(ChanBackupSnapshot::new)
        }
    }
}

impl ::protobuf::Clear for ChanBackupSnapshot {
    fn clear(&mut self) {
        self.single_chan_backups.clear();
        self.multi_chan_backup.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChanBackupSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChanBackupSnapshot {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelBackups {
    // message fields
    pub chan_backups: ::protobuf::RepeatedField<ChannelBackup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBackups {
    fn default() -> &'a ChannelBackups {
        <ChannelBackups as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBackups {
    pub fn new() -> ChannelBackups {
        ::std::default::Default::default()
    }

    // repeated .lnrpc.ChannelBackup chan_backups = 1;


    pub fn get_chan_backups(&self) -> &[ChannelBackup] {
        &self.chan_backups
    }
    pub fn clear_chan_backups(&mut self) {
        self.chan_backups.clear();
    }

    // Param is passed by value, moved
    pub fn set_chan_backups(&mut self, v: ::protobuf::RepeatedField<ChannelBackup>) {
        self.chan_backups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chan_backups(&mut self) -> &mut ::protobuf::RepeatedField<ChannelBackup> {
        &mut self.chan_backups
    }

    // Take field
    pub fn take_chan_backups(&mut self) -> ::protobuf::RepeatedField<ChannelBackup> {
        ::std::mem::replace(&mut self.chan_backups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChannelBackups {
    fn is_initialized(&self) -> bool {
        for v in &self.chan_backups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chan_backups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chan_backups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chan_backups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBackups {
        ChannelBackups::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChannelBackup>>(
                    "chan_backups",
                    |m: &ChannelBackups| { &m.chan_backups },
                    |m: &mut ChannelBackups| { &mut m.chan_backups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChannelBackups>(
                    "ChannelBackups",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelBackups {
        static mut instance: ::protobuf::lazy::Lazy<ChannelBackups> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelBackups,
        };
        unsafe {
            instance.get(ChannelBackups::new)
        }
    }
}

impl ::protobuf::Clear for ChannelBackups {
    fn clear(&mut self) {
        self.chan_backups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBackups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBackups {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreChanBackupRequest {
    // message oneof groups
    pub backup: ::std::option::Option<RestoreChanBackupRequest_oneof_backup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreChanBackupRequest {
    fn default() -> &'a RestoreChanBackupRequest {
        <RestoreChanBackupRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RestoreChanBackupRequest_oneof_backup {
    chan_backups(ChannelBackups),
    multi_chan_backup(::std::vec::Vec<u8>),
}

impl RestoreChanBackupRequest {
    pub fn new() -> RestoreChanBackupRequest {
        ::std::default::Default::default()
    }

    // .lnrpc.ChannelBackups chan_backups = 1;


    pub fn get_chan_backups(&self) -> &ChannelBackups {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ref v)) => v,
            _ => ChannelBackups::default_instance(),
        }
    }
    pub fn clear_chan_backups(&mut self) {
        self.backup = ::std::option::Option::None;
    }

    pub fn has_chan_backups(&self) -> bool {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_chan_backups(&mut self, v: ChannelBackups) {
        self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(v))
    }

    // Mutable pointer to the field.
    pub fn mut_chan_backups(&mut self) -> &mut ChannelBackups {
        if let ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(_)) = self.backup {
        } else {
            self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ChannelBackups::new()));
        }
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_chan_backups(&mut self) -> ChannelBackups {
        if self.has_chan_backups() {
            match self.backup.take() {
                ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(v)) => v,
                _ => panic!(),
            }
        } else {
            ChannelBackups::new()
        }
    }

    // bytes multi_chan_backup = 2;


    pub fn get_multi_chan_backup(&self) -> &[u8] {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_multi_chan_backup(&mut self) {
        self.backup = ::std::option::Option::None;
    }

    pub fn has_multi_chan_backup(&self) -> bool {
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_chan_backup(&mut self, v: ::std::vec::Vec<u8>) {
        self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_chan_backup(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(_)) = self.backup {
        } else {
            self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(::std::vec::Vec::new()));
        }
        match self.backup {
            ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_chan_backup(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_multi_chan_backup() {
            match self.backup.take() {
                ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for RestoreChanBackupRequest {
    fn is_initialized(&self) -> bool {
        if let Some(RestoreChanBackupRequest_oneof_backup::chan_backups(ref v)) = self.backup {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::chan_backups(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.backup = ::std::option::Option::Some(RestoreChanBackupRequest_oneof_backup::multi_chan_backup(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.backup {
            match v {
                &RestoreChanBackupRequest_oneof_backup::chan_backups(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.backup {
            match v {
                &RestoreChanBackupRequest_oneof_backup::chan_backups(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RestoreChanBackupRequest_oneof_backup::multi_chan_backup(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreChanBackupRequest {
        RestoreChanBackupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ChannelBackups>(
                    "chan_backups",
                    RestoreChanBackupRequest::has_chan_backups,
                    RestoreChanBackupRequest::get_chan_backups,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "multi_chan_backup",
                    RestoreChanBackupRequest::has_multi_chan_backup,
                    RestoreChanBackupRequest::get_multi_chan_backup,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreChanBackupRequest>(
                    "RestoreChanBackupRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RestoreChanBackupRequest {
        static mut instance: ::protobuf::lazy::Lazy<RestoreChanBackupRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreChanBackupRequest,
        };
        unsafe {
            instance.get(RestoreChanBackupRequest::new)
        }
    }
}

impl ::protobuf::Clear for RestoreChanBackupRequest {
    fn clear(&mut self) {
        self.backup = ::std::option::Option::None;
        self.backup = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreChanBackupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreChanBackupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreBackupResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreBackupResponse {
    fn default() -> &'a RestoreBackupResponse {
        <RestoreBackupResponse as ::protobuf::Message>::default_instance()
    }
}

impl RestoreBackupResponse {
    pub fn new() -> RestoreBackupResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RestoreBackupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreBackupResponse {
        RestoreBackupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RestoreBackupResponse>(
                    "RestoreBackupResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RestoreBackupResponse {
        static mut instance: ::protobuf::lazy::Lazy<RestoreBackupResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreBackupResponse,
        };
        unsafe {
            instance.get(RestoreBackupResponse::new)
        }
    }
}

impl ::protobuf::Clear for RestoreBackupResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreBackupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreBackupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelBackupSubscription {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelBackupSubscription {
    fn default() -> &'a ChannelBackupSubscription {
        <ChannelBackupSubscription as ::protobuf::Message>::default_instance()
    }
}

impl ChannelBackupSubscription {
    pub fn new() -> ChannelBackupSubscription {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelBackupSubscription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelBackupSubscription {
        ChannelBackupSubscription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ChannelBackupSubscription>(
                    "ChannelBackupSubscription",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChannelBackupSubscription {
        static mut instance: ::protobuf::lazy::Lazy<ChannelBackupSubscription> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChannelBackupSubscription,
        };
        unsafe {
            instance.get(ChannelBackupSubscription::new)
        }
    }
}

impl ::protobuf::Clear for ChannelBackupSubscription {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelBackupSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelBackupSubscription {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyChanBackupResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyChanBackupResponse {
    fn default() -> &'a VerifyChanBackupResponse {
        <VerifyChanBackupResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyChanBackupResponse {
    pub fn new() -> VerifyChanBackupResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VerifyChanBackupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyChanBackupResponse {
        VerifyChanBackupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<VerifyChanBackupResponse>(
                    "VerifyChanBackupResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyChanBackupResponse {
        static mut instance: ::protobuf::lazy::Lazy<VerifyChanBackupResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerifyChanBackupResponse,
        };
        unsafe {
            instance.get(VerifyChanBackupResponse::new)
        }
    }
}

impl ::protobuf::Clear for VerifyChanBackupResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyChanBackupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyChanBackupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddressType {
    WITNESS_PUBKEY_HASH = 0,
    NESTED_PUBKEY_HASH = 1,
    UNUSED_WITNESS_PUBKEY_HASH = 2,
    UNUSED_NESTED_PUBKEY_HASH = 3,
}

impl ::protobuf::ProtobufEnum for AddressType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddressType> {
        match value {
            0 => ::std::option::Option::Some(AddressType::WITNESS_PUBKEY_HASH),
            1 => ::std::option::Option::Some(AddressType::NESTED_PUBKEY_HASH),
            2 => ::std::option::Option::Some(AddressType::UNUSED_WITNESS_PUBKEY_HASH),
            3 => ::std::option::Option::Some(AddressType::UNUSED_NESTED_PUBKEY_HASH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddressType] = &[
            AddressType::WITNESS_PUBKEY_HASH,
            AddressType::NESTED_PUBKEY_HASH,
            AddressType::UNUSED_WITNESS_PUBKEY_HASH,
            AddressType::UNUSED_NESTED_PUBKEY_HASH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AddressType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AddressType {
}

impl ::std::default::Default for AddressType {
    fn default() -> Self {
        AddressType::WITNESS_PUBKEY_HASH
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InvoiceHTLCState {
    ACCEPTED = 0,
    SETTLED = 1,
    CANCELLED = 2,
}

impl ::protobuf::ProtobufEnum for InvoiceHTLCState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InvoiceHTLCState> {
        match value {
            0 => ::std::option::Option::Some(InvoiceHTLCState::ACCEPTED),
            1 => ::std::option::Option::Some(InvoiceHTLCState::SETTLED),
            2 => ::std::option::Option::Some(InvoiceHTLCState::CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InvoiceHTLCState] = &[
            InvoiceHTLCState::ACCEPTED,
            InvoiceHTLCState::SETTLED,
            InvoiceHTLCState::CANCELLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("InvoiceHTLCState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for InvoiceHTLCState {
}

impl ::std::default::Default for InvoiceHTLCState {
    fn default() -> Self {
        InvoiceHTLCState::ACCEPTED
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceHTLCState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\trpc.proto\x12\x05lnrpc\x1a\x1cgoogle/api/annotations.proto\"`\n\x0eG\
    enSeedRequest\x12+\n\x11aezeed_passphrase\x18\x01\x20\x01(\x0cR\x10aezee\
    dPassphrase\x12!\n\x0cseed_entropy\x18\x02\x20\x01(\x0cR\x0bseedEntropy\
    \"l\n\x0fGenSeedResponse\x120\n\x14cipher_seed_mnemonic\x18\x01\x20\x03(\
    \tR\x12cipherSeedMnemonic\x12'\n\x0fenciphered_seed\x18\x02\x20\x01(\x0c\
    R\x0eencipheredSeed\"\x88\x02\n\x11InitWalletRequest\x12'\n\x0fwallet_pa\
    ssword\x18\x01\x20\x01(\x0cR\x0ewalletPassword\x120\n\x14cipher_seed_mne\
    monic\x18\x02\x20\x03(\tR\x12cipherSeedMnemonic\x12+\n\x11aezeed_passphr\
    ase\x18\x03\x20\x01(\x0cR\x10aezeedPassphrase\x12'\n\x0frecovery_window\
    \x18\x04\x20\x01(\x05R\x0erecoveryWindow\x12B\n\x0fchannel_backups\x18\
    \x05\x20\x01(\x0b2\x19.lnrpc.ChanBackupSnapshotR\x0echannelBackups\"\x14\
    \n\x12InitWalletResponse\"\xab\x01\n\x13UnlockWalletRequest\x12'\n\x0fwa\
    llet_password\x18\x01\x20\x01(\x0cR\x0ewalletPassword\x12'\n\x0frecovery\
    _window\x18\x02\x20\x01(\x05R\x0erecoveryWindow\x12B\n\x0fchannel_backup\
    s\x18\x03\x20\x01(\x0b2\x19.lnrpc.ChanBackupSnapshotR\x0echannelBackups\
    \"\x16\n\x14UnlockWalletResponse\"e\n\x15ChangePasswordRequest\x12)\n\
    \x10current_password\x18\x01\x20\x01(\x0cR\x0fcurrentPassword\x12!\n\x0c\
    new_password\x18\x02\x20\x01(\x0cR\x0bnewPassword\"\x18\n\x16ChangePassw\
    ordResponse\"\xe1\x01\n\x04Utxo\x12.\n\x04type\x18\x01\x20\x01(\x0e2\x12\
    .lnrpc.AddressTypeR\x0caddress_type\x12\x18\n\x07address\x18\x02\x20\x01\
    (\tR\x07address\x12\x1e\n\namount_sat\x18\x03\x20\x01(\x03R\namount_sat\
    \x12\x1c\n\tpk_script\x18\x04\x20\x01(\tR\tpk_script\x12+\n\x08outpoint\
    \x18\x05\x20\x01(\x0b2\x0f.lnrpc.OutPointR\x08outpoint\x12$\n\rconfirmat\
    ions\x18\x06\x20\x01(\x03R\rconfirmations\"\xb9\x02\n\x0bTransaction\x12\
    \x18\n\x07tx_hash\x18\x01\x20\x01(\tR\x07tx_hash\x12\x16\n\x06amount\x18\
    \x02\x20\x01(\x03R\x06amount\x12,\n\x11num_confirmations\x18\x03\x20\x01\
    (\x05R\x11num_confirmations\x12\x1e\n\nblock_hash\x18\x04\x20\x01(\tR\nb\
    lock_hash\x12\"\n\x0cblock_height\x18\x05\x20\x01(\x05R\x0cblock_height\
    \x12\x1e\n\ntime_stamp\x18\x06\x20\x01(\x03R\ntime_stamp\x12\x1e\n\ntota\
    l_fees\x18\x07\x20\x01(\x03R\ntotal_fees\x12&\n\x0edest_addresses\x18\
    \x08\x20\x03(\tR\x0edest_addresses\x12\x1e\n\nraw_tx_hex\x18\t\x20\x01(\
    \tR\nraw_tx_hex\"\x18\n\x16GetTransactionsRequest\"L\n\x12TransactionDet\
    ails\x126\n\x0ctransactions\x18\x01\x20\x03(\x0b2\x12.lnrpc.TransactionR\
    \x0ctransactions\"G\n\x08FeeLimit\x12\x16\n\x05fixed\x18\x01\x20\x01(\
    \x03H\0R\x05fixed\x12\x1a\n\x07percent\x18\x02\x20\x01(\x03H\0R\x07perce\
    ntB\x07\n\x05limit\"\xe9\x03\n\x0bSendRequest\x12\x12\n\x04dest\x18\x01\
    \x20\x01(\x0cR\x04dest\x12\x1f\n\x0bdest_string\x18\x02\x20\x01(\tR\ndes\
    tString\x12\x10\n\x03amt\x18\x03\x20\x01(\x03R\x03amt\x12!\n\x0cpayment_\
    hash\x18\x04\x20\x01(\x0cR\x0bpaymentHash\x12.\n\x13payment_hash_string\
    \x18\x05\x20\x01(\tR\x11paymentHashString\x12'\n\x0fpayment_request\x18\
    \x06\x20\x01(\tR\x0epaymentRequest\x12(\n\x10final_cltv_delta\x18\x07\
    \x20\x01(\x05R\x0efinalCltvDelta\x12,\n\tfee_limit\x18\x08\x20\x01(\x0b2\
    \x0f.lnrpc.FeeLimitR\x08feeLimit\x12(\n\x10outgoing_chan_id\x18\t\x20\
    \x01(\x04R\x0eoutgoingChanId\x12\x1d\n\ncltv_limit\x18\n\x20\x01(\rR\tcl\
    tvLimit\x12:\n\x08dest_tlv\x18\x0b\x20\x03(\x0b2\x1f.lnrpc.SendRequest.D\
    estTlvEntryR\x07destTlv\x1a:\n\x0cDestTlvEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x04R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\
    \x028\x01\"\xb8\x01\n\x0cSendResponse\x12$\n\rpayment_error\x18\x01\x20\
    \x01(\tR\rpayment_error\x12*\n\x10payment_preimage\x18\x02\x20\x01(\x0cR\
    \x10payment_preimage\x122\n\rpayment_route\x18\x03\x20\x01(\x0b2\x0c.lnr\
    pc.RouteR\rpayment_route\x12\"\n\x0cpayment_hash\x18\x04\x20\x01(\x0cR\
    \x0cpayment_hash\"\x91\x01\n\x12SendToRouteRequest\x12!\n\x0cpayment_has\
    h\x18\x01\x20\x01(\x0cR\x0bpaymentHash\x12.\n\x13payment_hash_string\x18\
    \x02\x20\x01(\tR\x11paymentHashString\x12\"\n\x05route\x18\x04\x20\x01(\
    \x0b2\x0c.lnrpc.RouteR\x05routeJ\x04\x08\x03\x10\x04\"\xa2\x01\n\x0cChan\
    nelPoint\x120\n\x12funding_txid_bytes\x18\x01\x20\x01(\x0cH\0R\x12fundin\
    g_txid_bytes\x12,\n\x10funding_txid_str\x18\x02\x20\x01(\tH\0R\x10fundin\
    g_txid_str\x12\"\n\x0coutput_index\x18\x03\x20\x01(\rR\x0coutput_indexB\
    \x0e\n\x0cfunding_txid\"j\n\x08OutPoint\x12\x1e\n\ntxid_bytes\x18\x01\
    \x20\x01(\x0cR\ntxid_bytes\x12\x1a\n\x08txid_str\x18\x02\x20\x01(\tR\x08\
    txid_str\x12\"\n\x0coutput_index\x18\x03\x20\x01(\rR\x0coutput_index\">\
    \n\x10LightningAddress\x12\x16\n\x06pubkey\x18\x01\x20\x01(\tR\x06pubkey\
    \x12\x12\n\x04host\x18\x02\x20\x01(\tR\x04host\"\xc7\x01\n\x12EstimateFe\
    eRequest\x12O\n\x0cAddrToAmount\x18\x01\x20\x03(\x0b2+.lnrpc.EstimateFee\
    Request.AddrToAmountEntryR\x0cAddrToAmount\x12\x1f\n\x0btarget_conf\x18\
    \x02\x20\x01(\x05R\ntargetConf\x1a?\n\x11AddrToAmountEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\
    \x05value:\x028\x01\"c\n\x13EstimateFeeResponse\x12\x18\n\x07fee_sat\x18\
    \x01\x20\x01(\x03R\x07fee_sat\x122\n\x14feerate_sat_per_byte\x18\x02\x20\
    \x01(\x03R\x14feerate_sat_per_byte\"\xe3\x01\n\x0fSendManyRequest\x12L\n\
    \x0cAddrToAmount\x18\x01\x20\x03(\x0b2(.lnrpc.SendManyRequest.AddrToAmou\
    ntEntryR\x0cAddrToAmount\x12\x1f\n\x0btarget_conf\x18\x03\x20\x01(\x05R\
    \ntargetConf\x12\x20\n\x0csat_per_byte\x18\x05\x20\x01(\x03R\nsatPerByte\
    \x1a?\n\x11AddrToAmountEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01\"&\n\x10Sen\
    dManyResponse\x12\x12\n\x04txid\x18\x01\x20\x01(\tR\x04txid\"\x9c\x01\n\
    \x10SendCoinsRequest\x12\x12\n\x04addr\x18\x01\x20\x01(\tR\x04addr\x12\
    \x16\n\x06amount\x18\x02\x20\x01(\x03R\x06amount\x12\x1f\n\x0btarget_con\
    f\x18\x03\x20\x01(\x05R\ntargetConf\x12\x20\n\x0csat_per_byte\x18\x05\
    \x20\x01(\x03R\nsatPerByte\x12\x19\n\x08send_all\x18\x06\x20\x01(\x08R\
    \x07sendAll\"'\n\x11SendCoinsResponse\x12\x12\n\x04txid\x18\x01\x20\x01(\
    \tR\x04txid\"N\n\x12ListUnspentRequest\x12\x1b\n\tmin_confs\x18\x01\x20\
    \x01(\x05R\x08minConfs\x12\x1b\n\tmax_confs\x18\x02\x20\x01(\x05R\x08max\
    Confs\"8\n\x13ListUnspentResponse\x12!\n\x05utxos\x18\x01\x20\x03(\x0b2\
    \x0b.lnrpc.UtxoR\x05utxos\";\n\x11NewAddressRequest\x12&\n\x04type\x18\
    \x01\x20\x01(\x0e2\x12.lnrpc.AddressTypeR\x04type\".\n\x12NewAddressResp\
    onse\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\"&\n\x12SignMes\
    sageRequest\x12\x10\n\x03msg\x18\x01\x20\x01(\x0cR\x03msg\"3\n\x13SignMe\
    ssageResponse\x12\x1c\n\tsignature\x18\x01\x20\x01(\tR\tsignature\"F\n\
    \x14VerifyMessageRequest\x12\x10\n\x03msg\x18\x01\x20\x01(\x0cR\x03msg\
    \x12\x1c\n\tsignature\x18\x02\x20\x01(\tR\tsignature\"E\n\x15VerifyMessa\
    geResponse\x12\x14\n\x05valid\x18\x01\x20\x01(\x08R\x05valid\x12\x16\n\
    \x06pubkey\x18\x02\x20\x01(\tR\x06pubkey\"U\n\x12ConnectPeerRequest\x12+\
    \n\x04addr\x18\x01\x20\x01(\x0b2\x17.lnrpc.LightningAddressR\x04addr\x12\
    \x12\n\x04perm\x18\x02\x20\x01(\x08R\x04perm\"\x15\n\x13ConnectPeerRespo\
    nse\"1\n\x15DisconnectPeerRequest\x12\x18\n\x07pub_key\x18\x01\x20\x01(\
    \tR\x07pub_key\"\x18\n\x16DisconnectPeerResponse\"\x86\x01\n\x04HTLC\x12\
    \x1a\n\x08incoming\x18\x01\x20\x01(\x08R\x08incoming\x12\x16\n\x06amount\
    \x18\x02\x20\x01(\x03R\x06amount\x12\x1c\n\thash_lock\x18\x03\x20\x01(\
    \x0cR\thash_lock\x12,\n\x11expiration_height\x18\x04\x20\x01(\rR\x11expi\
    ration_height\"\xbc\x06\n\x07Channel\x12\x16\n\x06active\x18\x01\x20\x01\
    (\x08R\x06active\x12$\n\rremote_pubkey\x18\x02\x20\x01(\tR\rremote_pubke\
    y\x12$\n\rchannel_point\x18\x03\x20\x01(\tR\rchannel_point\x12\x18\n\x07\
    chan_id\x18\x04\x20\x01(\x04R\x07chan_id\x12\x1a\n\x08capacity\x18\x05\
    \x20\x01(\x03R\x08capacity\x12$\n\rlocal_balance\x18\x06\x20\x01(\x03R\r\
    local_balance\x12&\n\x0eremote_balance\x18\x07\x20\x01(\x03R\x0eremote_b\
    alance\x12\x1e\n\ncommit_fee\x18\x08\x20\x01(\x03R\ncommit_fee\x12$\n\rc\
    ommit_weight\x18\t\x20\x01(\x03R\rcommit_weight\x12\x1e\n\nfee_per_kw\
    \x18\n\x20\x01(\x03R\nfee_per_kw\x12,\n\x11unsettled_balance\x18\x0b\x20\
    \x01(\x03R\x11unsettled_balance\x120\n\x13total_satoshis_sent\x18\x0c\
    \x20\x01(\x03R\x13total_satoshis_sent\x128\n\x17total_satoshis_received\
    \x18\r\x20\x01(\x03R\x17total_satoshis_received\x12\x20\n\x0bnum_updates\
    \x18\x0e\x20\x01(\x04R\x0bnum_updates\x121\n\rpending_htlcs\x18\x0f\x20\
    \x03(\x0b2\x0b.lnrpc.HTLCR\rpending_htlcs\x12\x1c\n\tcsv_delay\x18\x10\
    \x20\x01(\rR\tcsv_delay\x12\x18\n\x07private\x18\x11\x20\x01(\x08R\x07pr\
    ivate\x12\x1c\n\tinitiator\x18\x12\x20\x01(\x08R\tinitiator\x12,\n\x11ch\
    an_status_flags\x18\x13\x20\x01(\tR\x11chan_status_flags\x126\n\x16local\
    _chan_reserve_sat\x18\x14\x20\x01(\x03R\x16local_chan_reserve_sat\x128\n\
    \x17remote_chan_reserve_sat\x18\x15\x20\x01(\x03R\x17remote_chan_reserve\
    _sat\"\x9f\x01\n\x13ListChannelsRequest\x12\x1f\n\x0bactive_only\x18\x01\
    \x20\x01(\x08R\nactiveOnly\x12#\n\rinactive_only\x18\x02\x20\x01(\x08R\
    \x0cinactiveOnly\x12\x1f\n\x0bpublic_only\x18\x03\x20\x01(\x08R\npublicO\
    nly\x12!\n\x0cprivate_only\x18\x04\x20\x01(\x08R\x0bprivateOnly\"B\n\x14\
    ListChannelsResponse\x12*\n\x08channels\x18\x0b\x20\x03(\x0b2\x0e.lnrpc.\
    ChannelR\x08channels\"\xb6\x04\n\x13ChannelCloseSummary\x12$\n\rchannel_\
    point\x18\x01\x20\x01(\tR\rchannel_point\x12\x18\n\x07chan_id\x18\x02\
    \x20\x01(\x04R\x07chan_id\x12\x1e\n\nchain_hash\x18\x03\x20\x01(\tR\ncha\
    in_hash\x12(\n\x0fclosing_tx_hash\x18\x04\x20\x01(\tR\x0fclosing_tx_hash\
    \x12$\n\rremote_pubkey\x18\x05\x20\x01(\tR\rremote_pubkey\x12\x1a\n\x08c\
    apacity\x18\x06\x20\x01(\x03R\x08capacity\x12\"\n\x0cclose_height\x18\
    \x07\x20\x01(\rR\x0cclose_height\x12(\n\x0fsettled_balance\x18\x08\x20\
    \x01(\x03R\x0fsettled_balance\x120\n\x13time_locked_balance\x18\t\x20\
    \x01(\x03R\x13time_locked_balance\x12F\n\nclose_type\x18\n\x20\x01(\x0e2\
    &.lnrpc.ChannelCloseSummary.ClosureTypeR\nclose_type\"\x8a\x01\n\x0bClos\
    ureType\x12\x15\n\x11COOPERATIVE_CLOSE\x10\0\x12\x15\n\x11LOCAL_FORCE_CL\
    OSE\x10\x01\x12\x16\n\x12REMOTE_FORCE_CLOSE\x10\x02\x12\x10\n\x0cBREACH_\
    CLOSE\x10\x03\x12\x14\n\x10FUNDING_CANCELED\x10\x04\x12\r\n\tABANDONED\
    \x10\x05\"\xde\x01\n\x15ClosedChannelsRequest\x12\x20\n\x0bcooperative\
    \x18\x01\x20\x01(\x08R\x0bcooperative\x12\x1f\n\x0blocal_force\x18\x02\
    \x20\x01(\x08R\nlocalForce\x12!\n\x0cremote_force\x18\x03\x20\x01(\x08R\
    \x0bremoteForce\x12\x16\n\x06breach\x18\x04\x20\x01(\x08R\x06breach\x12)\
    \n\x10funding_canceled\x18\x05\x20\x01(\x08R\x0ffundingCanceled\x12\x1c\
    \n\tabandoned\x18\x06\x20\x01(\x08R\tabandoned\"P\n\x16ClosedChannelsRes\
    ponse\x126\n\x08channels\x18\x01\x20\x03(\x0b2\x1a.lnrpc.ChannelCloseSum\
    maryR\x08channels\"\xdf\x02\n\x04Peer\x12\x18\n\x07pub_key\x18\x01\x20\
    \x01(\tR\x07pub_key\x12\x18\n\x07address\x18\x03\x20\x01(\tR\x07address\
    \x12\x1e\n\nbytes_sent\x18\x04\x20\x01(\x04R\nbytes_sent\x12\x1e\n\nbyte\
    s_recv\x18\x05\x20\x01(\x04R\nbytes_recv\x12\x1a\n\x08sat_sent\x18\x06\
    \x20\x01(\x03R\x08sat_sent\x12\x1a\n\x08sat_recv\x18\x07\x20\x01(\x03R\
    \x08sat_recv\x12\x18\n\x07inbound\x18\x08\x20\x01(\x08R\x07inbound\x12\
    \x1c\n\tping_time\x18\t\x20\x01(\x03R\tping_time\x122\n\tsync_type\x18\n\
    \x20\x01(\x0e2\x14.lnrpc.Peer.SyncTypeR\tsync_type\"?\n\x08SyncType\x12\
    \x10\n\x0cUNKNOWN_SYNC\x10\0\x12\x0f\n\x0bACTIVE_SYNC\x10\x01\x12\x10\n\
    \x0cPASSIVE_SYNC\x10\x02\"\x12\n\x10ListPeersRequest\"6\n\x11ListPeersRe\
    sponse\x12!\n\x05peers\x18\x01\x20\x03(\x0b2\x0b.lnrpc.PeerR\x05peers\"\
    \x10\n\x0eGetInfoRequest\"\xe7\x04\n\x0fGetInfoResponse\x12(\n\x0fidenti\
    ty_pubkey\x18\x01\x20\x01(\tR\x0fidentity_pubkey\x12\x14\n\x05alias\x18\
    \x02\x20\x01(\tR\x05alias\x122\n\x14num_pending_channels\x18\x03\x20\x01\
    (\rR\x14num_pending_channels\x120\n\x13num_active_channels\x18\x04\x20\
    \x01(\rR\x13num_active_channels\x12\x1c\n\tnum_peers\x18\x05\x20\x01(\rR\
    \tnum_peers\x12\"\n\x0cblock_height\x18\x06\x20\x01(\rR\x0cblock_height\
    \x12\x1e\n\nblock_hash\x18\x08\x20\x01(\tR\nblock_hash\x12(\n\x0fsynced_\
    to_chain\x18\t\x20\x01(\x08R\x0fsynced_to_chain\x12\x1c\n\x07testnet\x18\
    \n\x20\x01(\x08R\x07testnetB\x02\x18\x01\x12\x12\n\x04uris\x18\x0c\x20\
    \x03(\tR\x04uris\x124\n\x15best_header_timestamp\x18\r\x20\x01(\x03R\x15\
    best_header_timestamp\x12\x18\n\x07version\x18\x0e\x20\x01(\tR\x07versio\
    n\x124\n\x15num_inactive_channels\x18\x0f\x20\x01(\rR\x15num_inactive_ch\
    annels\x12$\n\x06chains\x18\x10\x20\x03(\x0b2\x0c.lnrpc.ChainR\x06chains\
    \x12\x14\n\x05color\x18\x11\x20\x01(\tR\x05color\x12(\n\x0fsynced_to_gra\
    ph\x18\x12\x20\x01(\x08R\x0fsynced_to_graphJ\x04\x08\x0b\x10\x0c\"7\n\
    \x05Chain\x12\x14\n\x05chain\x18\x01\x20\x01(\tR\x05chain\x12\x18\n\x07n\
    etwork\x18\x02\x20\x01(\tR\x07network\"z\n\x12ConfirmationUpdate\x12\x1b\
    \n\tblock_sha\x18\x01\x20\x01(\x0cR\x08blockSha\x12!\n\x0cblock_height\
    \x18\x02\x20\x01(\x05R\x0bblockHeight\x12$\n\x0enum_confs_left\x18\x03\
    \x20\x01(\rR\x0cnumConfsLeft\"N\n\x11ChannelOpenUpdate\x129\n\rchannel_p\
    oint\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\rchannel_point\"R\n\
    \x12ChannelCloseUpdate\x12\"\n\x0cclosing_txid\x18\x01\x20\x01(\x0cR\x0c\
    closing_txid\x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07success\"\xa8\
    \x01\n\x13CloseChannelRequest\x128\n\rchannel_point\x18\x01\x20\x01(\x0b\
    2\x13.lnrpc.ChannelPointR\x0cchannelPoint\x12\x14\n\x05force\x18\x02\x20\
    \x01(\x08R\x05force\x12\x1f\n\x0btarget_conf\x18\x03\x20\x01(\x05R\ntarg\
    etConf\x12\x20\n\x0csat_per_byte\x18\x04\x20\x01(\x03R\nsatPerByte\"\x98\
    \x01\n\x11CloseStatusUpdate\x12<\n\rclose_pending\x18\x01\x20\x01(\x0b2\
    \x14.lnrpc.PendingUpdateH\0R\rclose_pending\x12;\n\nchan_close\x18\x03\
    \x20\x01(\x0b2\x19.lnrpc.ChannelCloseUpdateH\0R\nchan_closeB\x08\n\x06up\
    date\"G\n\rPendingUpdate\x12\x12\n\x04txid\x18\x01\x20\x01(\x0cR\x04txid\
    \x12\"\n\x0coutput_index\x18\x02\x20\x01(\rR\x0coutput_index\"\xb1\x03\n\
    \x12OpenChannelRequest\x12\x20\n\x0bnode_pubkey\x18\x02\x20\x01(\x0cR\
    \x0bnode_pubkey\x12.\n\x12node_pubkey_string\x18\x03\x20\x01(\tR\x12node\
    _pubkey_string\x122\n\x14local_funding_amount\x18\x04\x20\x01(\x03R\x14l\
    ocal_funding_amount\x12\x1a\n\x08push_sat\x18\x05\x20\x01(\x03R\x08push_\
    sat\x12\x1f\n\x0btarget_conf\x18\x06\x20\x01(\x05R\ntargetConf\x12\x20\n\
    \x0csat_per_byte\x18\x07\x20\x01(\x03R\nsatPerByte\x12\x18\n\x07private\
    \x18\x08\x20\x01(\x08R\x07private\x12$\n\rmin_htlc_msat\x18\t\x20\x01(\
    \x03R\rmin_htlc_msat\x12*\n\x10remote_csv_delay\x18\n\x20\x01(\rR\x10rem\
    ote_csv_delay\x12\x1c\n\tmin_confs\x18\x0b\x20\x01(\x05R\tmin_confs\x12,\
    \n\x11spend_unconfirmed\x18\x0c\x20\x01(\x08R\x11spend_unconfirmed\"\x92\
    \x01\n\x10OpenStatusUpdate\x12:\n\x0cchan_pending\x18\x01\x20\x01(\x0b2\
    \x14.lnrpc.PendingUpdateH\0R\x0cchan_pending\x128\n\tchan_open\x18\x03\
    \x20\x01(\x0b2\x18.lnrpc.ChannelOpenUpdateH\0R\tchan_openB\x08\n\x06upda\
    te\"\xcf\x01\n\x0bPendingHTLC\x12\x1a\n\x08incoming\x18\x01\x20\x01(\x08\
    R\x08incoming\x12\x16\n\x06amount\x18\x02\x20\x01(\x03R\x06amount\x12\
    \x1a\n\x08outpoint\x18\x03\x20\x01(\tR\x08outpoint\x12(\n\x0fmaturity_he\
    ight\x18\x04\x20\x01(\rR\x0fmaturity_height\x120\n\x13blocks_til_maturit\
    y\x18\x05\x20\x01(\x05R\x13blocks_til_maturity\x12\x14\n\x05stage\x18\
    \x06\x20\x01(\rR\x05stage\"\x18\n\x16PendingChannelsRequest\"\xaf\r\n\
    \x17PendingChannelsResponse\x120\n\x13total_limbo_balance\x18\x01\x20\
    \x01(\x03R\x13total_limbo_balance\x12g\n\x15pending_open_channels\x18\
    \x02\x20\x03(\x0b21.lnrpc.PendingChannelsResponse.PendingOpenChannelR\
    \x15pending_open_channels\x12h\n\x18pending_closing_channels\x18\x03\x20\
    \x03(\x0b2,.lnrpc.PendingChannelsResponse.ClosedChannelR\x18pending_clos\
    ing_channels\x12y\n\x1epending_force_closing_channels\x18\x04\x20\x03(\
    \x0b21.lnrpc.PendingChannelsResponse.ForceClosedChannelR\x1epending_forc\
    e_closing_channels\x12j\n\x16waiting_close_channels\x18\x05\x20\x03(\x0b\
    22.lnrpc.PendingChannelsResponse.WaitingCloseChannelR\x16waiting_close_c\
    hannels\x1a\xbc\x02\n\x0ePendingChannel\x12(\n\x0fremote_node_pub\x18\
    \x01\x20\x01(\tR\x0fremote_node_pub\x12$\n\rchannel_point\x18\x02\x20\
    \x01(\tR\rchannel_point\x12\x1a\n\x08capacity\x18\x03\x20\x01(\x03R\x08c\
    apacity\x12$\n\rlocal_balance\x18\x04\x20\x01(\x03R\rlocal_balance\x12&\
    \n\x0eremote_balance\x18\x05\x20\x01(\x03R\x0eremote_balance\x126\n\x16l\
    ocal_chan_reserve_sat\x18\x06\x20\x01(\x03R\x16local_chan_reserve_sat\
    \x128\n\x17remote_chan_reserve_sat\x18\x07\x20\x01(\x03R\x17remote_chan_\
    reserve_sat\x1a\xf5\x01\n\x12PendingOpenChannel\x12G\n\x07channel\x18\
    \x01\x20\x01(\x0b2-.lnrpc.PendingChannelsResponse.PendingChannelR\x07cha\
    nnel\x120\n\x13confirmation_height\x18\x02\x20\x01(\rR\x13confirmation_h\
    eight\x12\x1e\n\ncommit_fee\x18\x04\x20\x01(\x03R\ncommit_fee\x12$\n\rco\
    mmit_weight\x18\x05\x20\x01(\x03R\rcommit_weight\x12\x1e\n\nfee_per_kw\
    \x18\x06\x20\x01(\x03R\nfee_per_kw\x1a\x84\x01\n\x13WaitingCloseChannel\
    \x12G\n\x07channel\x18\x01\x20\x01(\x0b2-.lnrpc.PendingChannelsResponse.\
    PendingChannelR\x07channel\x12$\n\rlimbo_balance\x18\x02\x20\x01(\x03R\r\
    limbo_balance\x1a|\n\rClosedChannel\x12G\n\x07channel\x18\x01\x20\x01(\
    \x0b2-.lnrpc.PendingChannelsResponse.PendingChannelR\x07channel\x12\"\n\
    \x0cclosing_txid\x18\x02\x20\x01(\tR\x0cclosing_txid\x1a\xeb\x02\n\x12Fo\
    rceClosedChannel\x12G\n\x07channel\x18\x01\x20\x01(\x0b2-.lnrpc.PendingC\
    hannelsResponse.PendingChannelR\x07channel\x12\"\n\x0cclosing_txid\x18\
    \x02\x20\x01(\tR\x0cclosing_txid\x12$\n\rlimbo_balance\x18\x03\x20\x01(\
    \x03R\rlimbo_balance\x12(\n\x0fmaturity_height\x18\x04\x20\x01(\rR\x0fma\
    turity_height\x120\n\x13blocks_til_maturity\x18\x05\x20\x01(\x05R\x13blo\
    cks_til_maturity\x12,\n\x11recovered_balance\x18\x06\x20\x01(\x03R\x11re\
    covered_balance\x128\n\rpending_htlcs\x18\x08\x20\x03(\x0b2\x12.lnrpc.Pe\
    ndingHTLCR\rpending_htlcs\"\x1a\n\x18ChannelEventSubscription\"\xb5\x03\
    \n\x12ChannelEventUpdate\x124\n\x0copen_channel\x18\x01\x20\x01(\x0b2\
    \x0e.lnrpc.ChannelH\0R\x0copen_channel\x12D\n\x0eclosed_channel\x18\x02\
    \x20\x01(\x0b2\x1a.lnrpc.ChannelCloseSummaryH\0R\x0eclosed_channel\x12=\
    \n\x0eactive_channel\x18\x03\x20\x01(\x0b2\x13.lnrpc.ChannelPointH\0R\
    \x0eactive_channel\x12A\n\x10inactive_channel\x18\x04\x20\x01(\x0b2\x13.\
    lnrpc.ChannelPointH\0R\x10inactive_channel\x128\n\x04type\x18\x05\x20\
    \x01(\x0e2$.lnrpc.ChannelEventUpdate.UpdateTypeR\x04type\"\\\n\nUpdateTy\
    pe\x12\x10\n\x0cOPEN_CHANNEL\x10\0\x12\x12\n\x0eCLOSED_CHANNEL\x10\x01\
    \x12\x12\n\x0eACTIVE_CHANNEL\x10\x02\x12\x14\n\x10INACTIVE_CHANNEL\x10\
    \x03B\t\n\x07channel\"\x16\n\x14WalletBalanceRequest\"\x9d\x01\n\x15Wall\
    etBalanceResponse\x12$\n\rtotal_balance\x18\x01\x20\x01(\x03R\rtotal_bal\
    ance\x12,\n\x11confirmed_balance\x18\x02\x20\x01(\x03R\x11confirmed_bala\
    nce\x120\n\x13unconfirmed_balance\x18\x03\x20\x01(\x03R\x13unconfirmed_b\
    alance\"\x17\n\x15ChannelBalanceRequest\"f\n\x16ChannelBalanceResponse\
    \x12\x18\n\x07balance\x18\x01\x20\x01(\x03R\x07balance\x122\n\x14pending\
    _open_balance\x18\x02\x20\x01(\x03R\x14pending_open_balance\"\x8a\x04\n\
    \x12QueryRoutesRequest\x12\x17\n\x07pub_key\x18\x01\x20\x01(\tR\x06pubKe\
    y\x12\x10\n\x03amt\x18\x02\x20\x01(\x03R\x03amt\x12(\n\x10final_cltv_del\
    ta\x18\x04\x20\x01(\x05R\x0efinalCltvDelta\x12,\n\tfee_limit\x18\x05\x20\
    \x01(\x0b2\x0f.lnrpc.FeeLimitR\x08feeLimit\x12#\n\rignored_nodes\x18\x06\
    \x20\x03(\x0cR\x0cignoredNodes\x12;\n\rignored_edges\x18\x07\x20\x03(\
    \x0b2\x12.lnrpc.EdgeLocatorR\x0cignoredEdgesB\x02\x18\x01\x12$\n\x0esour\
    ce_pub_key\x18\x08\x20\x01(\tR\x0csourcePubKey\x12.\n\x13use_mission_con\
    trol\x18\t\x20\x01(\x08R\x11useMissionControl\x124\n\rignored_pairs\x18\
    \n\x20\x03(\x0b2\x0f.lnrpc.NodePairR\x0cignoredPairs\x12A\n\x08dest_tlv\
    \x18\x0b\x20\x03(\x0b2&.lnrpc.QueryRoutesRequest.DestTlvEntryR\x07destTl\
    v\x1a:\n\x0cDestTlvEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01J\x04\x08\
    \x03\x10\x04\".\n\x08NodePair\x12\x12\n\x04from\x18\x01\x20\x01(\x0cR\
    \x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\"Y\n\x0bEdgeLocator\
    \x12\x1d\n\nchannel_id\x18\x01\x20\x01(\x04R\tchannelId\x12+\n\x11direct\
    ion_reverse\x18\x02\x20\x01(\x08R\x10directionReverse\"_\n\x13QueryRoute\
    sResponse\x12$\n\x06routes\x18\x01\x20\x03(\x0b2\x0c.lnrpc.RouteR\x06rou\
    tes\x12\"\n\x0csuccess_prob\x18\x02\x20\x01(\x01R\x0csuccess_prob\"\xa6\
    \x03\n\x03Hop\x12\x18\n\x07chan_id\x18\x01\x20\x01(\x04R\x07chan_id\x12$\
    \n\rchan_capacity\x18\x02\x20\x01(\x03R\rchan_capacity\x12*\n\x0eamt_to_\
    forward\x18\x03\x20\x01(\x03R\x0eamt_to_forwardB\x02\x18\x01\x12\x14\n\
    \x03fee\x18\x04\x20\x01(\x03R\x03feeB\x02\x18\x01\x12\x16\n\x06expiry\
    \x18\x05\x20\x01(\rR\x06expiry\x120\n\x13amt_to_forward_msat\x18\x06\x20\
    \x01(\x03R\x13amt_to_forward_msat\x12\x1a\n\x08fee_msat\x18\x07\x20\x01(\
    \x03R\x08fee_msat\x12\x18\n\x07pub_key\x18\x08\x20\x01(\tR\x07pub_key\
    \x12\x20\n\x0btlv_payload\x18\t\x20\x01(\x08R\x0btlv_payload\x12<\n\x0bt\
    lv_records\x18\n\x20\x03(\x0b2\x1a.lnrpc.Hop.TlvRecordsEntryR\x0btlv_rec\
    ords\x1a=\n\x0fTlvRecordsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x04R\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\"\
    \xe9\x01\n\x05Route\x12(\n\x0ftotal_time_lock\x18\x01\x20\x01(\rR\x0ftot\
    al_time_lock\x12\"\n\ntotal_fees\x18\x02\x20\x01(\x03R\ntotal_feesB\x02\
    \x18\x01\x12\x20\n\ttotal_amt\x18\x03\x20\x01(\x03R\ttotal_amtB\x02\x18\
    \x01\x12\x1e\n\x04hops\x18\x04\x20\x03(\x0b2\n.lnrpc.HopR\x04hops\x12(\n\
    \x0ftotal_fees_msat\x18\x05\x20\x01(\x03R\x0ftotal_fees_msat\x12&\n\x0et\
    otal_amt_msat\x18\x06\x20\x01(\x03R\x0etotal_amt_msat\"U\n\x0fNodeInfoRe\
    quest\x12\x17\n\x07pub_key\x18\x01\x20\x01(\tR\x06pubKey\x12)\n\x10inclu\
    de_channels\x18\x02\x20\x01(\x08R\x0fincludeChannels\"\xb0\x01\n\x08Node\
    Info\x12(\n\x04node\x18\x01\x20\x01(\x0b2\x14.lnrpc.LightningNodeR\x04no\
    de\x12\"\n\x0cnum_channels\x18\x02\x20\x01(\rR\x0cnum_channels\x12&\n\
    \x0etotal_capacity\x18\x03\x20\x01(\x03R\x0etotal_capacity\x12.\n\x08cha\
    nnels\x18\x04\x20\x03(\x0b2\x12.lnrpc.ChannelEdgeR\x08channels\"\xa9\x01\
    \n\rLightningNode\x12\x20\n\x0blast_update\x18\x01\x20\x01(\rR\x0blast_u\
    pdate\x12\x18\n\x07pub_key\x18\x02\x20\x01(\tR\x07pub_key\x12\x14\n\x05a\
    lias\x18\x03\x20\x01(\tR\x05alias\x120\n\taddresses\x18\x04\x20\x03(\x0b\
    2\x12.lnrpc.NodeAddressR\taddresses\x12\x14\n\x05color\x18\x05\x20\x01(\
    \tR\x05color\";\n\x0bNodeAddress\x12\x18\n\x07network\x18\x01\x20\x01(\t\
    R\x07network\x12\x12\n\x04addr\x18\x02\x20\x01(\tR\x04addr\"\x91\x02\n\r\
    RoutingPolicy\x12(\n\x0ftime_lock_delta\x18\x01\x20\x01(\rR\x0ftime_lock\
    _delta\x12\x1a\n\x08min_htlc\x18\x02\x20\x01(\x03R\x08min_htlc\x12$\n\rf\
    ee_base_msat\x18\x03\x20\x01(\x03R\rfee_base_msat\x120\n\x13fee_rate_mil\
    li_msat\x18\x04\x20\x01(\x03R\x13fee_rate_milli_msat\x12\x1a\n\x08disabl\
    ed\x18\x05\x20\x01(\x08R\x08disabled\x12$\n\rmax_htlc_msat\x18\x06\x20\
    \x01(\x04R\rmax_htlc_msat\x12\x20\n\x0blast_update\x18\x07\x20\x01(\rR\
    \x0blast_update\"\xbf\x02\n\x0bChannelEdge\x12\x1e\n\nchannel_id\x18\x01\
    \x20\x01(\x04R\nchannel_id\x12\x1e\n\nchan_point\x18\x02\x20\x01(\tR\nch\
    an_point\x12$\n\x0blast_update\x18\x03\x20\x01(\rR\x0blast_updateB\x02\
    \x18\x01\x12\x1c\n\tnode1_pub\x18\x04\x20\x01(\tR\tnode1_pub\x12\x1c\n\t\
    node2_pub\x18\x05\x20\x01(\tR\tnode2_pub\x12\x1a\n\x08capacity\x18\x06\
    \x20\x01(\x03R\x08capacity\x128\n\x0cnode1_policy\x18\x07\x20\x01(\x0b2\
    \x14.lnrpc.RoutingPolicyR\x0cnode1_policy\x128\n\x0cnode2_policy\x18\x08\
    \x20\x01(\x0b2\x14.lnrpc.RoutingPolicyR\x0cnode2_policy\"G\n\x13ChannelG\
    raphRequest\x120\n\x13include_unannounced\x18\x01\x20\x01(\x08R\x13inclu\
    de_unannounced\"d\n\x0cChannelGraph\x12*\n\x05nodes\x18\x01\x20\x03(\x0b\
    2\x14.lnrpc.LightningNodeR\x05nodes\x12(\n\x05edges\x18\x02\x20\x03(\x0b\
    2\x12.lnrpc.ChannelEdgeR\x05edges\"*\n\x0fChanInfoRequest\x12\x17\n\x07c\
    han_id\x18\x01\x20\x01(\x04R\x06chanId\"\x14\n\x12NetworkInfoRequest\"\
    \xe9\x03\n\x0bNetworkInfo\x12&\n\x0egraph_diameter\x18\x01\x20\x01(\rR\
    \x0egraph_diameter\x12&\n\x0eavg_out_degree\x18\x02\x20\x01(\x01R\x0eavg\
    _out_degree\x12&\n\x0emax_out_degree\x18\x03\x20\x01(\rR\x0emax_out_degr\
    ee\x12\x1c\n\tnum_nodes\x18\x04\x20\x01(\rR\tnum_nodes\x12\"\n\x0cnum_ch\
    annels\x18\x05\x20\x01(\rR\x0cnum_channels\x126\n\x16total_network_capac\
    ity\x18\x06\x20\x01(\x03R\x16total_network_capacity\x12*\n\x10avg_channe\
    l_size\x18\x07\x20\x01(\x01R\x10avg_channel_size\x12*\n\x10min_channel_s\
    ize\x18\x08\x20\x01(\x03R\x10min_channel_size\x12*\n\x10max_channel_size\
    \x18\t\x20\x01(\x03R\x10max_channel_size\x128\n\x17median_channel_size_s\
    at\x18\n\x20\x01(\x03R\x17median_channel_size_sat\x12*\n\x10num_zombie_c\
    hans\x18\x0b\x20\x01(\x04R\x10num_zombie_chans\"\r\n\x0bStopRequest\"\
    \x0e\n\x0cStopResponse\"\x1b\n\x19GraphTopologySubscription\"\xcd\x01\n\
    \x13GraphTopologyUpdate\x124\n\x0cnode_updates\x18\x01\x20\x03(\x0b2\x11\
    .lnrpc.NodeUpdateR\x0bnodeUpdates\x12A\n\x0fchannel_updates\x18\x02\x20\
    \x03(\x0b2\x18.lnrpc.ChannelEdgeUpdateR\x0echannelUpdates\x12=\n\x0cclos\
    ed_chans\x18\x03\x20\x03(\x0b2\x1a.lnrpc.ClosedChannelUpdateR\x0bclosedC\
    hans\"\xa2\x01\n\nNodeUpdate\x12\x1c\n\taddresses\x18\x01\x20\x03(\tR\ta\
    ddresses\x12!\n\x0cidentity_key\x18\x02\x20\x01(\tR\x0bidentityKey\x12'\
    \n\x0fglobal_features\x18\x03\x20\x01(\x0cR\x0eglobalFeatures\x12\x14\n\
    \x05alias\x18\x04\x20\x01(\tR\x05alias\x12\x14\n\x05color\x18\x05\x20\
    \x01(\tR\x05color\"\x8d\x02\n\x11ChannelEdgeUpdate\x12\x17\n\x07chan_id\
    \x18\x01\x20\x01(\x04R\x06chanId\x122\n\nchan_point\x18\x02\x20\x01(\x0b\
    2\x13.lnrpc.ChannelPointR\tchanPoint\x12\x1a\n\x08capacity\x18\x03\x20\
    \x01(\x03R\x08capacity\x12;\n\x0erouting_policy\x18\x04\x20\x01(\x0b2\
    \x14.lnrpc.RoutingPolicyR\rroutingPolicy\x12)\n\x10advertising_node\x18\
    \x05\x20\x01(\tR\x0fadvertisingNode\x12'\n\x0fconnecting_node\x18\x06\
    \x20\x01(\tR\x0econnectingNode\"\xa3\x01\n\x13ClosedChannelUpdate\x12\
    \x17\n\x07chan_id\x18\x01\x20\x01(\x04R\x06chanId\x12\x1a\n\x08capacity\
    \x18\x02\x20\x01(\x03R\x08capacity\x12#\n\rclosed_height\x18\x03\x20\x01\
    (\rR\x0cclosedHeight\x122\n\nchan_point\x18\x04\x20\x01(\x0b2\x13.lnrpc.\
    ChannelPointR\tchanPoint\"\xd3\x01\n\x07HopHint\x12\x18\n\x07node_id\x18\
    \x01\x20\x01(\tR\x07node_id\x12\x18\n\x07chan_id\x18\x02\x20\x01(\x04R\
    \x07chan_id\x12$\n\rfee_base_msat\x18\x03\x20\x01(\rR\rfee_base_msat\x12\
    @\n\x1bfee_proportional_millionths\x18\x04\x20\x01(\rR\x1bfee_proportion\
    al_millionths\x12,\n\x11cltv_expiry_delta\x18\x05\x20\x01(\rR\x11cltv_ex\
    piry_delta\"9\n\tRouteHint\x12,\n\thop_hints\x18\x01\x20\x03(\x0b2\x0e.l\
    nrpc.HopHintR\thop_hints\"\xbf\x06\n\x07Invoice\x12\x12\n\x04memo\x18\
    \x01\x20\x01(\tR\x04memo\x12\x1c\n\x07receipt\x18\x02\x20\x01(\x0cR\x07r\
    eceiptB\x02\x18\x01\x12\x1e\n\nr_preimage\x18\x03\x20\x01(\x0cR\nr_preim\
    age\x12\x16\n\x06r_hash\x18\x04\x20\x01(\x0cR\x06r_hash\x12\x14\n\x05val\
    ue\x18\x05\x20\x01(\x03R\x05value\x12\x1c\n\x07settled\x18\x06\x20\x01(\
    \x08R\x07settledB\x02\x18\x01\x12$\n\rcreation_date\x18\x07\x20\x01(\x03\
    R\rcreation_date\x12\x20\n\x0bsettle_date\x18\x08\x20\x01(\x03R\x0bsettl\
    e_date\x12(\n\x0fpayment_request\x18\t\x20\x01(\tR\x0fpayment_request\
    \x12*\n\x10description_hash\x18\n\x20\x01(\x0cR\x10description_hash\x12\
    \x16\n\x06expiry\x18\x0b\x20\x01(\x03R\x06expiry\x12$\n\rfallback_addr\
    \x18\x0c\x20\x01(\tR\rfallback_addr\x12\x20\n\x0bcltv_expiry\x18\r\x20\
    \x01(\x04R\x0bcltv_expiry\x122\n\x0broute_hints\x18\x0e\x20\x03(\x0b2\
    \x10.lnrpc.RouteHintR\x0broute_hints\x12\x18\n\x07private\x18\x0f\x20\
    \x01(\x08R\x07private\x12\x1c\n\tadd_index\x18\x10\x20\x01(\x04R\tadd_in\
    dex\x12\"\n\x0csettle_index\x18\x11\x20\x01(\x04R\x0csettle_index\x12\
    \x1e\n\x08amt_paid\x18\x12\x20\x01(\x03R\x08amt_paidB\x02\x18\x01\x12\"\
    \n\x0camt_paid_sat\x18\x13\x20\x01(\x03R\x0camt_paid_sat\x12$\n\ramt_pai\
    d_msat\x18\x14\x20\x01(\x03R\ramt_paid_msat\x121\n\x05state\x18\x15\x20\
    \x01(\x0e2\x1b.lnrpc.Invoice.InvoiceStateR\x05state\x12(\n\x05htlcs\x18\
    \x16\x20\x03(\x0b2\x12.lnrpc.InvoiceHTLCR\x05htlcs\"A\n\x0cInvoiceState\
    \x12\x08\n\x04OPEN\x10\0\x12\x0b\n\x07SETTLED\x10\x01\x12\x0c\n\x08CANCE\
    LED\x10\x02\x12\x0c\n\x08ACCEPTED\x10\x03\"\xa4\x02\n\x0bInvoiceHTLC\x12\
    \x18\n\x07chan_id\x18\x01\x20\x01(\x04R\x07chan_id\x12\x1e\n\nhtlc_index\
    \x18\x02\x20\x01(\x04R\nhtlc_index\x12\x1a\n\x08amt_msat\x18\x03\x20\x01\
    (\x04R\x08amt_msat\x12$\n\raccept_height\x18\x04\x20\x01(\x05R\raccept_h\
    eight\x12\x20\n\x0baccept_time\x18\x05\x20\x01(\x03R\x0baccept_time\x12\
    \"\n\x0cresolve_time\x18\x06\x20\x01(\x03R\x0cresolve_time\x12$\n\rexpir\
    y_height\x18\x07\x20\x01(\x05R\rexpiry_height\x12-\n\x05state\x18\x08\
    \x20\x01(\x0e2\x17.lnrpc.InvoiceHTLCStateR\x05state\"t\n\x12AddInvoiceRe\
    sponse\x12\x16\n\x06r_hash\x18\x01\x20\x01(\x0cR\x06r_hash\x12(\n\x0fpay\
    ment_request\x18\x02\x20\x01(\tR\x0fpayment_request\x12\x1c\n\tadd_index\
    \x18\x10\x20\x01(\x04R\tadd_index\"E\n\x0bPaymentHash\x12\x1e\n\nr_hash_\
    str\x18\x01\x20\x01(\tR\nr_hash_str\x12\x16\n\x06r_hash\x18\x02\x20\x01(\
    \x0cR\x06r_hash\"\xa4\x01\n\x12ListInvoiceRequest\x12\"\n\x0cpending_onl\
    y\x18\x01\x20\x01(\x08R\x0cpending_only\x12\"\n\x0cindex_offset\x18\x04\
    \x20\x01(\x04R\x0cindex_offset\x12*\n\x10num_max_invoices\x18\x05\x20\
    \x01(\x04R\x10num_max_invoices\x12\x1a\n\x08reversed\x18\x06\x20\x01(\
    \x08R\x08reversed\"\x9f\x01\n\x13ListInvoiceResponse\x12*\n\x08invoices\
    \x18\x01\x20\x03(\x0b2\x0e.lnrpc.InvoiceR\x08invoices\x12,\n\x11last_ind\
    ex_offset\x18\x02\x20\x01(\x04R\x11last_index_offset\x12.\n\x12first_ind\
    ex_offset\x18\x03\x20\x01(\x04R\x12first_index_offset\"W\n\x13InvoiceSub\
    scription\x12\x1c\n\tadd_index\x18\x01\x20\x01(\x04R\tadd_index\x12\"\n\
    \x0csettle_index\x18\x02\x20\x01(\x04R\x0csettle_index\"\xdf\x03\n\x07Pa\
    yment\x12\"\n\x0cpayment_hash\x18\x01\x20\x01(\tR\x0cpayment_hash\x12\
    \x18\n\x05value\x18\x02\x20\x01(\x03R\x05valueB\x02\x18\x01\x12$\n\rcrea\
    tion_date\x18\x03\x20\x01(\x03R\rcreation_date\x12\x12\n\x04path\x18\x04\
    \x20\x03(\tR\x04path\x12\x14\n\x03fee\x18\x05\x20\x01(\x03R\x03feeB\x02\
    \x18\x01\x12*\n\x10payment_preimage\x18\x06\x20\x01(\tR\x10payment_preim\
    age\x12\x1c\n\tvalue_sat\x18\x07\x20\x01(\x03R\tvalue_sat\x12\x1e\n\nval\
    ue_msat\x18\x08\x20\x01(\x03R\nvalue_msat\x12(\n\x0fpayment_request\x18\
    \t\x20\x01(\tR\x0fpayment_request\x124\n\x06status\x18\n\x20\x01(\x0e2\
    \x1c.lnrpc.Payment.PaymentStatusR\x06status\x12\x18\n\x07fee_sat\x18\x0b\
    \x20\x01(\x03R\x07fee_sat\x12\x1a\n\x08fee_msat\x18\x0c\x20\x01(\x03R\
    \x08fee_msat\"F\n\rPaymentStatus\x12\x0b\n\x07UNKNOWN\x10\0\x12\r\n\tIN_\
    FLIGHT\x10\x01\x12\r\n\tSUCCEEDED\x10\x02\x12\n\n\x06FAILED\x10\x03\"D\n\
    \x13ListPaymentsRequest\x12-\n\x12include_incomplete\x18\x01\x20\x01(\
    \x08R\x11includeIncomplete\"B\n\x14ListPaymentsResponse\x12*\n\x08paymen\
    ts\x18\x01\x20\x03(\x0b2\x0e.lnrpc.PaymentR\x08payments\"\x1a\n\x18Delet\
    eAllPaymentsRequest\"\x1b\n\x19DeleteAllPaymentsResponse\"Q\n\x15Abandon\
    ChannelRequest\x128\n\rchannel_point\x18\x01\x20\x01(\x0b2\x13.lnrpc.Cha\
    nnelPointR\x0cchannelPoint\"\x18\n\x16AbandonChannelResponse\"F\n\x11Deb\
    ugLevelRequest\x12\x12\n\x04show\x18\x01\x20\x01(\x08R\x04show\x12\x1d\n\
    \nlevel_spec\x18\x02\x20\x01(\tR\tlevelSpec\"6\n\x12DebugLevelResponse\
    \x12\x20\n\x0bsub_systems\x18\x01\x20\x01(\tR\x0bsub_systems\"'\n\x0cPay\
    ReqString\x12\x17\n\x07pay_req\x18\x01\x20\x01(\tR\x06payReq\"\xf2\x02\n\
    \x06PayReq\x12\x20\n\x0bdestination\x18\x01\x20\x01(\tR\x0bdestination\
    \x12\"\n\x0cpayment_hash\x18\x02\x20\x01(\tR\x0cpayment_hash\x12\"\n\x0c\
    num_satoshis\x18\x03\x20\x01(\x03R\x0cnum_satoshis\x12\x1c\n\ttimestamp\
    \x18\x04\x20\x01(\x03R\ttimestamp\x12\x16\n\x06expiry\x18\x05\x20\x01(\
    \x03R\x06expiry\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescript\
    ion\x12*\n\x10description_hash\x18\x07\x20\x01(\tR\x10description_hash\
    \x12$\n\rfallback_addr\x18\x08\x20\x01(\tR\rfallback_addr\x12\x20\n\x0bc\
    ltv_expiry\x18\t\x20\x01(\x03R\x0bcltv_expiry\x122\n\x0broute_hints\x18\
    \n\x20\x03(\x0b2\x10.lnrpc.RouteHintR\x0broute_hints\"\x12\n\x10FeeRepor\
    tRequest\"\x99\x01\n\x10ChannelFeeReport\x12!\n\nchan_point\x18\x01\x20\
    \x01(\tR\rchannel_point\x12$\n\rbase_fee_msat\x18\x02\x20\x01(\x03R\rbas\
    e_fee_msat\x12\x20\n\x0bfee_per_mil\x18\x03\x20\x01(\x03R\x0bfee_per_mil\
    \x12\x1a\n\x08fee_rate\x18\x04\x20\x01(\x01R\x08fee_rate\"\xbc\x01\n\x11\
    FeeReportResponse\x12;\n\x0cchannel_fees\x18\x01\x20\x03(\x0b2\x17.lnrpc\
    .ChannelFeeReportR\x0cchannel_fees\x12\x20\n\x0bday_fee_sum\x18\x02\x20\
    \x01(\x04R\x0bday_fee_sum\x12\"\n\x0cweek_fee_sum\x18\x03\x20\x01(\x04R\
    \x0cweek_fee_sum\x12$\n\rmonth_fee_sum\x18\x04\x20\x01(\x04R\rmonth_fee_\
    sum\"\xdb\x01\n\x13PolicyUpdateRequest\x12\x18\n\x06global\x18\x01\x20\
    \x01(\x08H\0R\x06global\x125\n\nchan_point\x18\x02\x20\x01(\x0b2\x13.lnr\
    pc.ChannelPointH\0R\nchan_point\x12$\n\rbase_fee_msat\x18\x03\x20\x01(\
    \x03R\rbase_fee_msat\x12\x1a\n\x08fee_rate\x18\x04\x20\x01(\x01R\x08fee_\
    rate\x12(\n\x0ftime_lock_delta\x18\x05\x20\x01(\rR\x0ftime_lock_deltaB\
    \x07\n\x05scope\"\x16\n\x14PolicyUpdateResponse\"\xa2\x01\n\x18Forwardin\
    gHistoryRequest\x12\x1e\n\nstart_time\x18\x01\x20\x01(\x04R\nstart_time\
    \x12\x1a\n\x08end_time\x18\x02\x20\x01(\x04R\x08end_time\x12\"\n\x0cinde\
    x_offset\x18\x03\x20\x01(\rR\x0cindex_offset\x12&\n\x0enum_max_events\
    \x18\x04\x20\x01(\rR\x0enum_max_events\"\xd1\x01\n\x0fForwardingEvent\
    \x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x04R\ttimestamp\x12\x1e\n\nchan_i\
    d_in\x18\x02\x20\x01(\x04R\nchan_id_in\x12\x20\n\x0bchan_id_out\x18\x04\
    \x20\x01(\x04R\x0bchan_id_out\x12\x16\n\x06amt_in\x18\x05\x20\x01(\x04R\
    \x06amt_in\x12\x18\n\x07amt_out\x18\x06\x20\x01(\x04R\x07amt_out\x12\x10\
    \n\x03fee\x18\x07\x20\x01(\x04R\x03fee\x12\x1a\n\x08fee_msat\x18\x08\x20\
    \x01(\x04R\x08fee_msat\"\x8f\x01\n\x19ForwardingHistoryResponse\x12D\n\
    \x11forwarding_events\x18\x01\x20\x03(\x0b2\x16.lnrpc.ForwardingEventR\
    \x11forwarding_events\x12,\n\x11last_offset_index\x18\x02\x20\x01(\rR\
    \x11last_offset_index\"P\n\x1aExportChannelBackupRequest\x122\n\nchan_po\
    int\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPointR\tchanPoint\"f\n\rChann\
    elBackup\x123\n\nchan_point\x18\x01\x20\x01(\x0b2\x13.lnrpc.ChannelPoint\
    R\nchan_point\x12\x20\n\x0bchan_backup\x18\x02\x20\x01(\x0cR\x0bchan_bac\
    kup\"v\n\x0fMultiChanBackup\x125\n\x0bchan_points\x18\x01\x20\x03(\x0b2\
    \x13.lnrpc.ChannelPointR\x0bchan_points\x12,\n\x11multi_chan_backup\x18\
    \x02\x20\x01(\x0cR\x11multi_chan_backup\"\x19\n\x17ChanBackupExportReque\
    st\"\xa3\x01\n\x12ChanBackupSnapshot\x12G\n\x13single_chan_backups\x18\
    \x01\x20\x01(\x0b2\x15.lnrpc.ChannelBackupsR\x13single_chan_backups\x12D\
    \n\x11multi_chan_backup\x18\x02\x20\x01(\x0b2\x16.lnrpc.MultiChanBackupR\
    \x11multi_chan_backup\"J\n\x0eChannelBackups\x128\n\x0cchan_backups\x18\
    \x01\x20\x03(\x0b2\x14.lnrpc.ChannelBackupR\x0cchan_backups\"\x91\x01\n\
    \x18RestoreChanBackupRequest\x12;\n\x0cchan_backups\x18\x01\x20\x01(\x0b\
    2\x15.lnrpc.ChannelBackupsH\0R\x0cchan_backups\x12.\n\x11multi_chan_back\
    up\x18\x02\x20\x01(\x0cH\0R\x11multi_chan_backupB\x08\n\x06backup\"\x17\
    \n\x15RestoreBackupResponse\"\x1b\n\x19ChannelBackupSubscription\"\x1a\n\
    \x18VerifyChanBackupResponse*}\n\x0bAddressType\x12\x17\n\x13WITNESS_PUB\
    KEY_HASH\x10\0\x12\x16\n\x12NESTED_PUBKEY_HASH\x10\x01\x12\x1e\n\x1aUNUS\
    ED_WITNESS_PUBKEY_HASH\x10\x02\x12\x1d\n\x19UNUSED_NESTED_PUBKEY_HASH\
    \x10\x03*<\n\x10InvoiceHTLCState\x12\x0c\n\x08ACCEPTED\x10\0\x12\x0b\n\
    \x07SETTLED\x10\x01\x12\r\n\tCANCELLED\x10\x022\x91\x03\n\x0eWalletUnloc\
    ker\x12M\n\x07GenSeed\x12\x15.lnrpc.GenSeedRequest\x1a\x16.lnrpc.GenSeed\
    Response\"\x13\x82\xd3\xe4\x93\x02\r\x12\x0b/v1/genseed\x12\\\n\nInitWal\
    let\x12\x18.lnrpc.InitWalletRequest\x1a\x19.lnrpc.InitWalletResponse\"\
    \x19\x82\xd3\xe4\x93\x02\x13\"\x0e/v1/initwallet:\x01*\x12d\n\x0cUnlockW\
    allet\x12\x1a.lnrpc.UnlockWalletRequest\x1a\x1b.lnrpc.UnlockWalletRespon\
    se\"\x1b\x82\xd3\xe4\x93\x02\x15\"\x10/v1/unlockwallet:\x01*\x12l\n\x0eC\
    hangePassword\x12\x1c.lnrpc.ChangePasswordRequest\x1a\x1d.lnrpc.ChangePa\
    sswordResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\"\x12/v1/changepassword:\
    \x01*2\x96&\n\tLightning\x12j\n\rWalletBalance\x12\x1b.lnrpc.WalletBalan\
    ceRequest\x1a\x1c.lnrpc.WalletBalanceResponse\"\x1e\x82\xd3\xe4\x93\x02\
    \x18\x12\x16/v1/balance/blockchain\x12k\n\x0eChannelBalance\x12\x1c.lnrp\
    c.ChannelBalanceRequest\x1a\x1d.lnrpc.ChannelBalanceResponse\"\x1c\x82\
    \xd3\xe4\x93\x02\x16\x12\x14/v1/balance/channels\x12e\n\x0fGetTransactio\
    ns\x12\x1d.lnrpc.GetTransactionsRequest\x1a\x19.lnrpc.TransactionDetails\
    \"\x18\x82\xd3\xe4\x93\x02\x12\x12\x10/v1/transactions\x12b\n\x0bEstimat\
    eFee\x12\x19.lnrpc.EstimateFeeRequest\x1a\x1a.lnrpc.EstimateFeeResponse\
    \"\x1c\x82\xd3\xe4\x93\x02\x16\x12\x14/v1/transactions/fee\x12[\n\tSendC\
    oins\x12\x17.lnrpc.SendCoinsRequest\x1a\x18.lnrpc.SendCoinsResponse\"\
    \x1b\x82\xd3\xe4\x93\x02\x15\"\x10/v1/transactions:\x01*\x12W\n\x0bListU\
    nspent\x12\x19.lnrpc.ListUnspentRequest\x1a\x1a.lnrpc.ListUnspentRespons\
    e\"\x11\x82\xd3\xe4\x93\x02\x0b\x12\t/v1/utxos\x12L\n\x15SubscribeTransa\
    ctions\x12\x1d.lnrpc.GetTransactionsRequest\x1a\x12.lnrpc.Transaction0\
    \x01\x12;\n\x08SendMany\x12\x16.lnrpc.SendManyRequest\x1a\x17.lnrpc.Send\
    ManyResponse\x12Y\n\nNewAddress\x12\x18.lnrpc.NewAddressRequest\x1a\x19.\
    lnrpc.NewAddressResponse\"\x16\x82\xd3\xe4\x93\x02\x10\x12\x0e/v1/newadd\
    ress\x12`\n\x0bSignMessage\x12\x19.lnrpc.SignMessageRequest\x1a\x1a.lnrp\
    c.SignMessageResponse\"\x1a\x82\xd3\xe4\x93\x02\x14\"\x0f/v1/signmessage\
    :\x01*\x12h\n\rVerifyMessage\x12\x1b.lnrpc.VerifyMessageRequest\x1a\x1c.\
    lnrpc.VerifyMessageResponse\"\x1c\x82\xd3\xe4\x93\x02\x16\"\x11/v1/verif\
    ymessage:\x01*\x12Z\n\x0bConnectPeer\x12\x19.lnrpc.ConnectPeerRequest\
    \x1a\x1a.lnrpc.ConnectPeerResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\"\t/v1/\
    peers:\x01*\x12j\n\x0eDisconnectPeer\x12\x1c.lnrpc.DisconnectPeerRequest\
    \x1a\x1d.lnrpc.DisconnectPeerResponse\"\x1b\x82\xd3\xe4\x93\x02\x15*\x13\
    /v1/peers/{pub_key}\x12Q\n\tListPeers\x12\x17.lnrpc.ListPeersRequest\x1a\
    \x18.lnrpc.ListPeersResponse\"\x11\x82\xd3\xe4\x93\x02\x0b\x12\t/v1/peer\
    s\x12M\n\x07GetInfo\x12\x15.lnrpc.GetInfoRequest\x1a\x16.lnrpc.GetInfoRe\
    sponse\"\x13\x82\xd3\xe4\x93\x02\r\x12\x0b/v1/getinfo\x12n\n\x0fPendingC\
    hannels\x12\x1d.lnrpc.PendingChannelsRequest\x1a\x1e.lnrpc.PendingChanne\
    lsResponse\"\x1c\x82\xd3\xe4\x93\x02\x16\x12\x14/v1/channels/pending\x12\
    ]\n\x0cListChannels\x12\x1a.lnrpc.ListChannelsRequest\x1a\x1b.lnrpc.List\
    ChannelsResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\x12\x0c/v1/channels\x12V\
    \n\x16SubscribeChannelEvents\x12\x1f.lnrpc.ChannelEventSubscription\x1a\
    \x19.lnrpc.ChannelEventUpdate0\x01\x12j\n\x0eClosedChannels\x12\x1c.lnrp\
    c.ClosedChannelsRequest\x1a\x1d.lnrpc.ClosedChannelsResponse\"\x1b\x82\
    \xd3\xe4\x93\x02\x15\x12\x13/v1/channels/closed\x12Z\n\x0fOpenChannelSyn\
    c\x12\x19.lnrpc.OpenChannelRequest\x1a\x13.lnrpc.ChannelPoint\"\x17\x82\
    \xd3\xe4\x93\x02\x11\"\x0c/v1/channels:\x01*\x12C\n\x0bOpenChannel\x12\
    \x19.lnrpc.OpenChannelRequest\x1a\x17.lnrpc.OpenStatusUpdate0\x01\x12\
    \x9a\x01\n\x0cCloseChannel\x12\x1a.lnrpc.CloseChannelRequest\x1a\x18.lnr\
    pc.CloseStatusUpdate\"R\x82\xd3\xe4\x93\x02L*J/v1/channels/{channel_poin\
    t.funding_txid_str}/{channel_point.output_index}0\x01\x12\xa9\x01\n\x0eA\
    bandonChannel\x12\x1c.lnrpc.AbandonChannelRequest\x1a\x1d.lnrpc.AbandonC\
    hannelResponse\"Z\x82\xd3\xe4\x93\x02T*R/v1/channels/abandon/{channel_po\
    int.funding_txid_str}/{channel_point.output_index}\x12:\n\x0bSendPayment\
    \x12\x12.lnrpc.SendRequest\x1a\x13.lnrpc.SendResponse(\x010\x01\x12`\n\
    \x0fSendPaymentSync\x12\x12.lnrpc.SendRequest\x1a\x13.lnrpc.SendResponse\
    \"$\x82\xd3\xe4\x93\x02\x1e\"\x19/v1/channels/transactions:\x01*\x12A\n\
    \x0bSendToRoute\x12\x19.lnrpc.SendToRouteRequest\x1a\x13.lnrpc.SendRespo\
    nse(\x010\x01\x12m\n\x0fSendToRouteSync\x12\x19.lnrpc.SendToRouteRequest\
    \x1a\x13.lnrpc.SendResponse\"*\x82\xd3\xe4\x93\x02$\"\x1f/v1/channels/tr\
    ansactions/route:\x01*\x12P\n\nAddInvoice\x12\x0e.lnrpc.Invoice\x1a\x19.\
    lnrpc.AddInvoiceResponse\"\x17\x82\xd3\xe4\x93\x02\x11\"\x0c/v1/invoices\
    :\x01*\x12[\n\x0cListInvoices\x12\x19.lnrpc.ListInvoiceRequest\x1a\x1a.l\
    nrpc.ListInvoiceResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\x12\x0c/v1/invoic\
    es\x12U\n\rLookupInvoice\x12\x12.lnrpc.PaymentHash\x1a\x0e.lnrpc.Invoice\
    \"\x20\x82\xd3\xe4\x93\x02\x1a\x12\x18/v1/invoice/{r_hash_str}\x12a\n\
    \x11SubscribeInvoices\x12\x1a.lnrpc.InvoiceSubscription\x1a\x0e.lnrpc.In\
    voice\"\x1e\x82\xd3\xe4\x93\x02\x18\x12\x16/v1/invoices/subscribe0\x01\
    \x12P\n\x0cDecodePayReq\x12\x13.lnrpc.PayReqString\x1a\r.lnrpc.PayReq\"\
    \x1c\x82\xd3\xe4\x93\x02\x16\x12\x14/v1/payreq/{pay_req}\x12]\n\x0cListP\
    ayments\x12\x1a.lnrpc.ListPaymentsRequest\x1a\x1b.lnrpc.ListPaymentsResp\
    onse\"\x14\x82\xd3\xe4\x93\x02\x0e\x12\x0c/v1/payments\x12l\n\x11DeleteA\
    llPayments\x12\x1f.lnrpc.DeleteAllPaymentsRequest\x1a\x20.lnrpc.DeleteAl\
    lPaymentsResponse\"\x14\x82\xd3\xe4\x93\x02\x0e*\x0c/v1/payments\x12S\n\
    \rDescribeGraph\x12\x1a.lnrpc.ChannelGraphRequest\x1a\x13.lnrpc.ChannelG\
    raph\"\x11\x82\xd3\xe4\x93\x02\x0b\x12\t/v1/graph\x12[\n\x0bGetChanInfo\
    \x12\x16.lnrpc.ChanInfoRequest\x1a\x12.lnrpc.ChannelEdge\"\x20\x82\xd3\
    \xe4\x93\x02\x1a\x12\x18/v1/graph/edge/{chan_id}\x12X\n\x0bGetNodeInfo\
    \x12\x16.lnrpc.NodeInfoRequest\x1a\x0f.lnrpc.NodeInfo\"\x20\x82\xd3\xe4\
    \x93\x02\x1a\x12\x18/v1/graph/node/{pub_key}\x12n\n\x0bQueryRoutes\x12\
    \x19.lnrpc.QueryRoutesRequest\x1a\x1a.lnrpc.QueryRoutesResponse\"(\x82\
    \xd3\xe4\x93\x02\"\x12\x20/v1/graph/routes/{pub_key}/{amt}\x12W\n\x0eGet\
    NetworkInfo\x12\x19.lnrpc.NetworkInfoRequest\x1a\x12.lnrpc.NetworkInfo\"\
    \x16\x82\xd3\xe4\x93\x02\x10\x12\x0e/v1/graph/info\x125\n\nStopDaemon\
    \x12\x12.lnrpc.StopRequest\x1a\x13.lnrpc.StopResponse\x12W\n\x15Subscrib\
    eChannelGraph\x12\x20.lnrpc.GraphTopologySubscription\x1a\x1a.lnrpc.Grap\
    hTopologyUpdate0\x01\x12A\n\nDebugLevel\x12\x18.lnrpc.DebugLevelRequest\
    \x1a\x19.lnrpc.DebugLevelResponse\x12P\n\tFeeReport\x12\x17.lnrpc.FeeRep\
    ortRequest\x1a\x18.lnrpc.FeeReportResponse\"\x10\x82\xd3\xe4\x93\x02\n\
    \x12\x08/v1/fees\x12i\n\x13UpdateChannelPolicy\x12\x1a.lnrpc.PolicyUpdat\
    eRequest\x1a\x1b.lnrpc.PolicyUpdateResponse\"\x19\x82\xd3\xe4\x93\x02\
    \x13\"\x0e/v1/chanpolicy:\x01*\x12m\n\x11ForwardingHistory\x12\x1f.lnrpc\
    .ForwardingHistoryRequest\x1a\x20.lnrpc.ForwardingHistoryResponse\"\x15\
    \x82\xd3\xe4\x93\x02\x0f\"\n/v1/switch:\x01*\x12\xa3\x01\n\x13ExportChan\
    nelBackup\x12!.lnrpc.ExportChannelBackupRequest\x1a\x14.lnrpc.ChannelBac\
    kup\"S\x82\xd3\xe4\x93\x02M\x12K/v1/channels/backup/{chan_point.funding_\
    txid_str}/{chan_point.output_index}\x12q\n\x17ExportAllChannelBackups\
    \x12\x1e.lnrpc.ChanBackupExportRequest\x1a\x19.lnrpc.ChanBackupSnapshot\
    \"\x1b\x82\xd3\xe4\x93\x02\x15\x12\x13/v1/channels/backup\x12u\n\x10Veri\
    fyChanBackup\x12\x19.lnrpc.ChanBackupSnapshot\x1a\x1f.lnrpc.VerifyChanBa\
    ckupResponse\"%\x82\xd3\xe4\x93\x02\x1f\"\x1a/v1/channels/backup/verify:\
    \x01*\x12~\n\x15RestoreChannelBackups\x12\x1f.lnrpc.RestoreChanBackupReq\
    uest\x1a\x1c.lnrpc.RestoreBackupResponse\"&\x82\xd3\xe4\x93\x02\x20\"\
    \x1b/v1/channels/backup/restore:\x01*\x12Z\n\x17SubscribeChannelBackups\
    \x12\x20.lnrpc.ChannelBackupSubscription\x1a\x19.lnrpc.ChanBackupSnapsho\
    t\"\00\x01B'Z%github.com/lightningnetwork/lnd/lnrpcb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
